<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lt</title>
</head>
<body>
    2
<br>

<br>
JavaScript for impatient programmers
<br>
Dr. Axel Rauschmayer
<br>
2019
<br>

<br>
“An exhaustive resource, yet cuts out the ﬂuff that clutters many
<br>
programming books – with explanations that are understandable and to
<br>
the point, as promised by the title! The quizzes and exercises are a very
<br>
useful feature to check and lock in your knowledge. And you can
<br>
deﬁnitely tear through the book fairly quickly, to get up and running in
<br>
JavaScript.”
<br>
— Pam Selle, thewebivore.com
<br>

<br>
“The best introductory book for modern JavaScript.”
<br>
— Tejinder Singh, Senior Software Engineer, IBM
<br>

<br>
“This is JavaScript. No ﬁller. No frameworks. No third-party libraries.
<br>
If you want to learn JavaScript, you need this book.”
<br>
— Shelley Powers, Software Engineer/Writer
<br>

<br>
Copyright © 2019 by Dr. Axel Rauschmayer
<br>
Cover by Fran Caye
<br>
All rights reserved. This book or any portion thereof may not be reproduced or used in
<br>
any manner whatsoever without the express written permission of the publisher except
<br>
for the use of brief quotations in a book review or scholarly journal.
<br>
ISBN 978-1-09-121009-7
<br>
exploringjs.com
<br>

<br>
Contents
<br>
I Background
<br>

<br>
13
<br>

<br>
1 About this book (ES2019 edition)
<br>
1.1 Can I preview the supplementary material for this book?
<br>
1.2 What’s in this book? . . . . . . . . . . . . . . . . . . . .
<br>
1.3 What is not covered by this book? . . . . . . . . . . . . .
<br>
1.4 Isn’t this book too long for impatient people? . . . . . . .
<br>
1.5 About the author . . . . . . . . . . . . . . . . . . . . . .
<br>
1.6 Acknowledgements . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
15
<br>
15
<br>
15
<br>
16
<br>
16
<br>
16
<br>
16
<br>

<br>
2 FAQ: Book and supplementary material
<br>
2.1 How to read this book . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
2.2 Digital editions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
2.3 Notations and conventions . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
17
<br>
17
<br>
18
<br>
18
<br>

<br>
3 Why JavaScript? (bonus)
<br>
3.1 The cons of JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
3.2 The pros of JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
3.3 Pro and con of JavaScript: innovation . . . . . . . . . . . . . . . . . . . .
<br>

<br>
21
<br>
21
<br>
22
<br>
23
<br>

<br>
4 The nature of JavaScript (bonus)
<br>
4.1 JavaScript’s inﬂuences . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
4.2 The nature of JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
4.3 Tips for getting started with JavaScript . . . . . . . . . . . . . . . . . . .
<br>

<br>
25
<br>
25
<br>
25
<br>
26
<br>

<br>
5 History and evolution of JavaScript
<br>
5.1 How JavaScript was created . . . . . . .
<br>
5.2 Standardizing JavaScript . . . . . . . . .
<br>
5.3 Timeline of ECMAScript versions . . . .
<br>
5.4 Ecma Technical Committee 39 (TC39) . .
<br>
5.5 The TC39 process . . . . . . . . . . . . .
<br>
5.6 FAQ: TC39 process . . . . . . . . . . . .
<br>
5.7 Evolving JavaScript: Don’t break the web
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
29
<br>
29
<br>
30
<br>
30
<br>
31
<br>
31
<br>
33
<br>
33
<br>

<br>
6 FAQ: JavaScript
<br>
6.1 What are good references for JavaScript? . . . . . . . . . . . . . . . . . .
<br>
6.2 How do I ﬁnd out what JavaScript features are supported where? . . . . .
<br>
6.3 Where can I look up what features are planned for JavaScript? . . . . . .
<br>

<br>
35
<br>
35
<br>
35
<br>
36
<br>

<br>
3
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
4
<br>

<br>
CONTENTS
<br>

<br>
6.4
<br>
6.5
<br>
6.6
<br>

<br>
Why does JavaScript fail silently so often? . . . . . . . . . . . . . . . . .
<br>
Why can’t we clean up JavaScript, by removing quirks and outdated features? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
How can I quickly try out a piece of JavaScript code? . . . . . . . . . . .
<br>

<br>
II First steps
<br>

<br>
36
<br>
36
<br>
36
<br>

<br>
37
<br>

<br>
7 The big picture
<br>
7.1 What are you learning in this book? .
<br>
7.2 The structure of browsers and Node.js
<br>
7.3 JavaScript references . . . . . . . . .
<br>
7.4 Further reading . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
39
<br>
39
<br>
39
<br>
40
<br>
40
<br>

<br>
8 Syntax
<br>
8.1 An overview of JavaScript’s syntax .
<br>
8.2 (Advanced) . . . . . . . . . . . . . .
<br>
8.3 Identiﬁers . . . . . . . . . . . . . . .
<br>
8.4 Statement vs. expression . . . . . . .
<br>
8.5 Ambiguous syntax . . . . . . . . . .
<br>
8.6 Semicolons . . . . . . . . . . . . . .
<br>
8.7 Automatic semicolon insertion (ASI)
<br>
8.8 Semicolons: best practices . . . . . .
<br>
8.9 Strict mode vs. sloppy mode . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
41
<br>
42
<br>
47
<br>
47
<br>
48
<br>
49
<br>
50
<br>
51
<br>
53
<br>
53
<br>

<br>
9 Consoles: interactive JavaScript command lines
<br>
9.1 Trying out JavaScript code . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
9.2 The console.* API: printing data and more . . . . . . . . . . . . . . . .
<br>

<br>
57
<br>
57
<br>
59
<br>

<br>
10 Assertion API
<br>
10.1 Assertions in software development . . .
<br>
10.2 How assertions are used in this book . .
<br>
10.3 Normal comparison vs. deep comparison
<br>
10.4 Quick reference: module assert . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
63
<br>
63
<br>
63
<br>
64
<br>
65
<br>

<br>
11 Getting started with quizzes and exercises
<br>
11.1 Quizzes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
11.2 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
11.3 Unit tests in JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
69
<br>
69
<br>
69
<br>
70
<br>

<br>
III Variables and values
<br>

<br>
73
<br>

<br>
12 Variables and assignment
<br>
12.1 let . . . . . . . . . . . . . . . . .
<br>
12.2 const . . . . . . . . . . . . . . .
<br>
12.3 Deciding between const and let
<br>
12.4 The scope of a variable . . . . . .
<br>
12.5 (Advanced) . . . . . . . . . . . .
<br>
12.6 Terminology: static vs. dynamic .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
75
<br>
76
<br>
76
<br>
77
<br>
77
<br>
79
<br>
79
<br>

<br>
5
<br>

<br>
CONTENTS
<br>

<br>
12.7 Global variables and the global object
<br>
12.8 Declarations: scope and activation . .
<br>
12.9 Closures . . . . . . . . . . . . . . . .
<br>
12.10Further reading . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
80
<br>
82
<br>
86
<br>
88
<br>

<br>
13 Values
<br>
13.1 What’s a type? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
13.2 JavaScript’s type hierarchy . . . . . . . . . . . . . . . . . . . . . .
<br>
13.3 The types of the language speciﬁcation . . . . . . . . . . . . . . .
<br>
13.4 Primitive values vs. objects . . . . . . . . . . . . . . . . . . . . . .
<br>
13.5 The operators typeof and instanceof: what’s the type of a value?
<br>
13.6 Classes and constructor functions . . . . . . . . . . . . . . . . . .
<br>
13.7 Converting between types . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
89
<br>
89
<br>
90
<br>
90
<br>
91
<br>
93
<br>
95
<br>
96
<br>

<br>
14 Operators
<br>
14.1 Making sense of operators
<br>
14.2 The plus operator (+) . . .
<br>
14.3 Assignment operators . .
<br>
14.4 Equality: == vs. === . . . .
<br>
14.5 Ordering operators . . . .
<br>
14.6 Various other operators . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
99
<br>
99
<br>
100
<br>
101
<br>
102
<br>
105
<br>
105
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
IV Primitive values
<br>

<br>
107
<br>

<br>
15 The non-values undefined and null
<br>
15.1 undefined vs. null . . . . . . . . . . . . .
<br>
15.2 Occurrences of undefined and null . . . .
<br>
15.3 Checking for undefined or null . . . . . .
<br>
15.4 undefined and null don’t have properties
<br>
15.5 The history of undefined and null . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
109
<br>
109
<br>
110
<br>
111
<br>
111
<br>
112
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
|| y)
<br>
. . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
113
<br>
113
<br>
114
<br>
115
<br>
117
<br>
117
<br>
119
<br>

<br>
17 Numbers
<br>
17.1 JavaScript only has ﬂoating point numbers . . . . . . . .
<br>
17.2 Number literals . . . . . . . . . . . . . . . . . . . . . . .
<br>
17.3 Arithmetic operators . . . . . . . . . . . . . . . . . . . .
<br>
17.4 Converting to number . . . . . . . . . . . . . . . . . . .
<br>
17.5 Error values . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
17.6 Error value: NaN . . . . . . . . . . . . . . . . . . . . . . .
<br>
17.7 Error value: Infinity . . . . . . . . . . . . . . . . . . .
<br>
17.8 The precision of numbers: careful with decimal fractions
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
121
<br>
122
<br>
122
<br>
123
<br>
125
<br>
126
<br>
126
<br>
128
<br>
129
<br>

<br>
16 Booleans
<br>
16.1 Converting to boolean . . . . . . .
<br>
16.2 Falsy and truthy values . . . . . . .
<br>
16.3 Truthiness-based existence checks .
<br>
16.4 Conditional operator (? :) . . . . .
<br>
16.5 Binary logical operators: And (x &&
<br>
16.6 Logical Not (!) . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
. . . .
<br>
. . . .
<br>
. . . .
<br>
. . . .
<br>
y), Or (x
<br>
. . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
6
<br>

<br>
CONTENTS
<br>

<br>
17.9 (Advanced) . . . . . . . . . . . . . .
<br>
17.10Background: ﬂoating point precision
<br>
17.11 Integers in JavaScript . . . . . . . . .
<br>
17.12Bitwise operators . . . . . . . . . . .
<br>
17.13Quick reference: numbers . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
129
<br>
129
<br>
131
<br>
133
<br>
136
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
141
<br>
141
<br>
142
<br>
143
<br>
144
<br>
146
<br>
147
<br>

<br>
19 Unicode – a brief introduction (advanced)
<br>
19.1 Code points vs. code units . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
19.2 Encodings used in web development: UTF-16 and UTF-8 . . . . . . . . .
<br>
19.3 Grapheme clusters – the real characters . . . . . . . . . . . . . . . . . . .
<br>

<br>
149
<br>
149
<br>
152
<br>
152
<br>

<br>
18 Math
<br>
18.1 Data properties . . . . . . .
<br>
18.2 Exponents, roots, logarithms
<br>
18.3 Rounding . . . . . . . . . .
<br>
18.4 Trigonometric Functions . .
<br>
18.5 Various other functions . . .
<br>
18.6 Sources . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
20 Strings
<br>
155
<br>
20.1 Plain string literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
<br>
20.2 Accessing characters and code points . . . . . . . . . . . . . . . . . . . . 156
<br>
20.3 String concatenation via + . . . . . . . . . . . . . . . . . . . . . . . . . . 157
<br>
20.4 Converting to string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
<br>
20.5 Comparing strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
<br>
20.6 Atoms of text: Unicode characters, JavaScript characters, grapheme clusters160
<br>
20.7 Quick reference: Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
<br>
21 Using template literals and tagged templates
<br>
21.1 Disambiguation: “template” . . . . . . . .
<br>
21.2 Template literals . . . . . . . . . . . . . . .
<br>
21.3 Tagged templates . . . . . . . . . . . . . .
<br>
21.4 Raw string literals . . . . . . . . . . . . . .
<br>
21.5 (Advanced) . . . . . . . . . . . . . . . . .
<br>
21.6 Multiline template literals and indentation
<br>
21.7 Simple templating via template literals . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
171
<br>
171
<br>
172
<br>
173
<br>
175
<br>
175
<br>
176
<br>
177
<br>

<br>
22 Symbols
<br>
22.1 Use cases for symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
22.2 Publicly known symbols . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
22.3 Converting symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
181
<br>
182
<br>
184
<br>
184
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
V Control ﬂow and data ﬂow
<br>
23 Control ﬂow statements
<br>
23.1 Conditions of control ﬂow statements .
<br>
23.2 Controlling loops: break and continue
<br>
23.3 if statements . . . . . . . . . . . . . .
<br>
23.4 switch statements . . . . . . . . . . . .
<br>

<br>
187
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
189
<br>
190
<br>
190
<br>
192
<br>
193
<br>

<br>
7
<br>

<br>
CONTENTS
<br>

<br>
23.5 while loops . . . . .
<br>
23.6 do-while loops . . .
<br>
23.7 for loops . . . . . .
<br>
23.8 for-of loops . . . .
<br>
23.9 for-await-of loops .
<br>
23.10 for-in loops (avoid)
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
195
<br>
196
<br>
196
<br>
197
<br>
199
<br>
199
<br>

<br>
24 Exception handling
<br>
24.1 Motivation: throwing and catching exceptions
<br>
24.2 throw . . . . . . . . . . . . . . . . . . . . . .
<br>
24.3 The try statement . . . . . . . . . . . . . . . .
<br>
24.4 Error classes . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
201
<br>
201
<br>
202
<br>
203
<br>
205
<br>

<br>
25 Callable values
<br>
25.1 Kinds of functions . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
25.2 Ordinary functions . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
25.3 Specialized functions . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
25.4 More kinds of functions and methods . . . . . . . . . . . . . . . .
<br>
25.5 Returning values from functions and methods . . . . . . . . . . .
<br>
25.6 Parameter handling . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
25.7 Dynamically evaluating code: eval(), new Function() (advanced)
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
207
<br>
207
<br>
208
<br>
210
<br>
213
<br>
214
<br>
215
<br>
219
<br>

<br>
26 Environments: under the hood of variables (bonus)
<br>
26.1 Environment: data structure for managing variables
<br>
26.2 Recursion via environments . . . . . . . . . . . . .
<br>
26.3 Nested scopes via environments . . . . . . . . . . .
<br>
26.4 Closures and environments . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
223
<br>
223
<br>
223
<br>
224
<br>
228
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
VI Modularity
<br>
27 Modules
<br>
27.1 Overview: syntax of ECMAScript modules . . . . . . . . . .
<br>
27.2 JavaScript source code formats . . . . . . . . . . . . . . . . .
<br>
27.3 Before we had modules, we had scripts . . . . . . . . . . . .
<br>
27.4 Module systems created prior to ES6 . . . . . . . . . . . . .
<br>
27.5 ECMAScript modules . . . . . . . . . . . . . . . . . . . . . .
<br>
27.6 Named exports and imports . . . . . . . . . . . . . . . . . .
<br>
27.7 Default exports and imports . . . . . . . . . . . . . . . . . .
<br>
27.8 More details on exporting and importing . . . . . . . . . . .
<br>
27.9 npm packages . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
27.10Naming modules . . . . . . . . . . . . . . . . . . . . . . . .
<br>
27.11 Module speciﬁers . . . . . . . . . . . . . . . . . . . . . . . .
<br>
27.12Loading modules dynamically via import() . . . . . . . . .
<br>
27.13Preview: import.meta.url . . . . . . . . . . . . . . . . . . .
<br>
27.14Polyﬁlls: emulating native web platform features (advanced)
<br>

<br>
231
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
233
<br>
234
<br>
235
<br>
235
<br>
236
<br>
238
<br>
239
<br>
241
<br>
244
<br>
245
<br>
247
<br>
248
<br>
250
<br>
252
<br>
254
<br>

<br>
28 Single objects
<br>
255
<br>
28.1 What is an object? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
<br>

<br>
8
<br>

<br>
CONTENTS
<br>

<br>
28.2
<br>
28.3
<br>
28.4
<br>
28.5
<br>
28.6
<br>
28.7
<br>

<br>
Objects as records . . . . . . . . .
<br>
Spreading into object literals (...)
<br>
Methods . . . . . . . . . . . . . .
<br>
Objects as dictionaries (advanced)
<br>
Standard methods (advanced) . .
<br>
Advanced topics . . . . . . . . .
<br>

<br>
29 Prototype chains and classes
<br>
29.1 Prototype chains . . . .
<br>
29.2 Classes . . . . . . . . . .
<br>
29.3 Private data for classes .
<br>
29.4 Subclassing . . . . . . .
<br>
29.5 FAQ: objects . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
257
<br>
260
<br>
262
<br>
269
<br>
277
<br>
277
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
281
<br>
282
<br>
287
<br>
291
<br>
293
<br>
301
<br>

<br>
VII Collections
<br>

<br>
303
<br>

<br>
30 Synchronous iteration
<br>
30.1 What is synchronous iteration about? . . . . . .
<br>
30.2 Core iteration constructs: iterables and iterators
<br>
30.3 Iterating manually . . . . . . . . . . . . . . . .
<br>
30.4 Iteration in practice . . . . . . . . . . . . . . . .
<br>
30.5 Quick reference: synchronous iteration . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
305
<br>
305
<br>
306
<br>
307
<br>
308
<br>
309
<br>

<br>
31 Arrays (Array)
<br>
31.1 The two roles of Arrays in JavaScript . . . . . . . . . . . . . . . . . . . .
<br>
31.2 Basic Array operations . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
31.3 for-of and Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
31.4 Array-like objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
31.5 Converting iterable and Array-like values to Arrays . . . . . . . . . . . .
<br>
31.6 Creating and ﬁlling Arrays with arbitrary lengths . . . . . . . . . . . . .
<br>
31.7 Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
31.8 More Array features (advanced) . . . . . . . . . . . . . . . . . . . . . . .
<br>
31.9 Adding and removing elements (destructively and non-destructively) . .
<br>
31.10Methods: iteration and transformation (.find(), .map(), .filter(), etc.)
<br>
31.11 .sort(): sorting Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
31.12Quick reference: Array<T> . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
311
<br>
312
<br>
312
<br>
315
<br>
316
<br>
317
<br>
318
<br>
319
<br>
320
<br>
323
<br>
325
<br>
332
<br>
334
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>
32.1 The basics of the API . . . . . . . . . . . . .
<br>
32.2 Element types . . . . . . . . . . . . . . . . .
<br>
32.3 More information on Typed Arrays . . . . .
<br>
32.4 Quick references: indices vs. offsets . . . . .
<br>
32.5 Quick reference: ArrayBuffers . . . . . . . .
<br>
32.6 Quick reference: Typed Arrays . . . . . . . .
<br>
32.7 Quick reference: DataViews . . . . . . . . .
<br>

<br>
343
<br>
344
<br>
346
<br>
348
<br>
352
<br>
353
<br>
354
<br>
357
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
33 Maps (Map)
<br>
359
<br>
33.1 Using Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
<br>

<br>
9
<br>

<br>
CONTENTS
<br>

<br>
33.2
<br>
33.3
<br>
33.4
<br>
33.5
<br>
33.6
<br>

<br>
Example: Counting characters . . . . . . . . . . . . . .
<br>
A few more details about the keys of Maps (advanced)
<br>
Missing Map operations . . . . . . . . . . . . . . . . .
<br>
Quick reference: Map<K,V> . . . . . . . . . . . . . . . .
<br>
FAQ: Maps . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
34 WeakMaps (WeakMap)
<br>
34.1 WeakMaps are black boxes . . . . . . .
<br>
34.2 The keys of a WeakMap are weakly held
<br>
34.3 Examples . . . . . . . . . . . . . . . .
<br>
34.4 WeakMap API . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
363
<br>
363
<br>
364
<br>
366
<br>
368
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
371
<br>
371
<br>
372
<br>
373
<br>
374
<br>

<br>
35 Sets (Set)
<br>
35.1 Using Sets . . . . . . . . . . . . . . . . .
<br>
35.2 Examples of using Sets . . . . . . . . . .
<br>
35.3 What Set elements are considered equal?
<br>
35.4 Missing Set operations . . . . . . . . . .
<br>
35.5 Quick reference: Set<T> . . . . . . . . .
<br>
35.6 FAQ: Sets . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
375
<br>
376
<br>
377
<br>
377
<br>
378
<br>
379
<br>
381
<br>

<br>
36 WeakSets (WeakSet)
<br>
383
<br>
36.1 Example: Marking objects as safe to use with a method . . . . . . . . . . 383
<br>
36.2 WeakSet API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384
<br>
37 Destructuring
<br>
37.1 A ﬁrst taste of destructuring . . . . . . . . . . . . . . . .
<br>
37.2 Constructing vs. extracting . . . . . . . . . . . . . . . . .
<br>
37.3 Where can we destructure? . . . . . . . . . . . . . . . . .
<br>
37.4 Object-destructuring . . . . . . . . . . . . . . . . . . . .
<br>
37.5 Array-destructuring . . . . . . . . . . . . . . . . . . . .
<br>
37.6 Examples of destructuring . . . . . . . . . . . . . . . . .
<br>
37.7 What happens if a pattern part does not match anything?
<br>
37.8 What values can’t be destructured? . . . . . . . . . . . .
<br>
37.9 (Advanced) . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
37.10Default values . . . . . . . . . . . . . . . . . . . . . . . .
<br>
37.11 Parameter deﬁnitions are similar to destructuring . . . .
<br>
37.12Nested destructuring . . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
385
<br>
386
<br>
386
<br>
387
<br>
388
<br>
389
<br>
390
<br>
392
<br>
392
<br>
393
<br>
393
<br>
394
<br>
395
<br>

<br>
38 Synchronous generators (advanced)
<br>
38.1 What are synchronous generators? . . . . . . . . . .
<br>
38.2 Calling generators from generators (advanced) . . .
<br>
38.3 Background: external iteration vs. internal iteration
<br>
38.4 Use case for generators: reusing traversals . . . . .
<br>
38.5 Advanced features of generators . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
397
<br>
397
<br>
401
<br>
403
<br>
404
<br>
405
<br>

<br>
VIII Asynchronicity
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
407
<br>

<br>
39 Asynchronous programming in JavaScript
<br>
409
<br>
39.1 A roadmap for asynchronous programming in JavaScript . . . . . . . . . 410
<br>

<br>
10
<br>

<br>
CONTENTS
<br>

<br>
39.2
<br>
39.3
<br>
39.4
<br>
39.5
<br>
39.6
<br>
39.7
<br>

<br>
The call stack . . . . . . . . . . . . . . . . . .
<br>
The event loop . . . . . . . . . . . . . . . . .
<br>
How to avoid blocking the JavaScript process .
<br>
Patterns for delivering asynchronous results .
<br>
Asynchronous code: the downsides . . . . . .
<br>
Resources . . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
412
<br>
413
<br>
414
<br>
416
<br>
419
<br>
420
<br>

<br>
40 Promises for asynchronous programming
<br>
40.1 The basics of using Promises . . . . . . . . . . . . . . . . . . . . . .
<br>
40.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
40.3 Error handling: don’t mix rejections and exceptions . . . . . . . . .
<br>
40.4 Promise-based functions start synchronously, settle asynchronously
<br>
40.5 Promise.all(): concurrency and Arrays of Promises . . . . . . . .
<br>
40.6 Tips for chaining Promises . . . . . . . . . . . . . . . . . . . . . . .
<br>
40.7 Advanced topics . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
421
<br>
422
<br>
427
<br>
431
<br>
433
<br>
434
<br>
437
<br>
439
<br>

<br>
41 Async functions
<br>
41.1 Async functions: the basics . . . . . . . . . .
<br>
41.2 Returning from async functions . . . . . . .
<br>
41.3 await: working with Promises . . . . . . . .
<br>
41.4 (Advanced) . . . . . . . . . . . . . . . . . .
<br>
41.5 Immediately invoked async arrow functions
<br>
41.6 Concurrency and await . . . . . . . . . . . .
<br>
41.7 Tips for using async functions . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
441
<br>
441
<br>
443
<br>
445
<br>
447
<br>
447
<br>
448
<br>
449
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
42 Asynchronous iteration
<br>
451
<br>
42.1 Basic asynchronous iteration . . . . . . . . . . . . . . . . . . . . . . . . . 451
<br>
42.2 Asynchronous generators . . . . . . . . . . . . . . . . . . . . . . . . . . 454
<br>
42.3 Async iteration over Node.js streams . . . . . . . . . . . . . . . . . . . . 458
<br>

<br>
IX More standard library
<br>

<br>
461
<br>

<br>
43 Regular expressions (RegExp)
<br>
43.1 Creating regular expressions . . . . . . . . . . .
<br>
43.2 Syntax . . . . . . . . . . . . . . . . . . . . . . .
<br>
43.3 Flags . . . . . . . . . . . . . . . . . . . . . . . .
<br>
43.4 Properties of regular expression objects . . . . .
<br>
43.5 Methods for working with regular expressions .
<br>
43.6 Flag /g and its pitfalls . . . . . . . . . . . . . . .
<br>
43.7 Techniques for working with regular expressions
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
463
<br>
464
<br>
465
<br>
469
<br>
472
<br>
473
<br>
478
<br>
481
<br>

<br>
44 Dates (Date)
<br>
44.1 Best practice: avoid the built-in Date
<br>
44.2 Time standards . . . . . . . . . . . .
<br>
44.3 Background: date time formats (ISO)
<br>
44.4 Time values . . . . . . . . . . . . . .
<br>
44.5 Creating Dates . . . . . . . . . . . .
<br>
44.6 Getters and setters . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
483
<br>
483
<br>
484
<br>
485
<br>
486
<br>
487
<br>
488
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
11
<br>

<br>
CONTENTS
<br>

<br>
44.7 Converting Dates to strings
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . 489
<br>

<br>
45 Creating and parsing JSON (JSON)
<br>
45.1 The discovery and standardization of JSON . . . . .
<br>
45.2 JSON syntax . . . . . . . . . . . . . . . . . . . . . .
<br>
45.3 Using the JSON API . . . . . . . . . . . . . . . . . .
<br>
45.4 Customizing stringiﬁcation and parsing (advanced)
<br>
45.5 FAQ . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
X Miscellaneous topics
<br>
46 Next steps: overview of web development (bonus)
<br>
46.1 Tips against feeling overwhelmed . . . . . . .
<br>
46.2 Things worth learning for web development .
<br>
46.3 Example: tool-based JavaScript workﬂow . . .
<br>
46.4 An overview of JavaScript tools . . . . . . . .
<br>
46.5 Tools not related to JavaScript . . . . . . . . .
<br>

<br>
XI Appendices
<br>
47 Index
<br>

<br>
491
<br>
492
<br>
492
<br>
493
<br>
495
<br>
499
<br>

<br>
501
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
503
<br>
503
<br>
504
<br>
506
<br>
508
<br>
510
<br>

<br>
513
<br>
515
<br>

<br>
12
<br>

<br>
CONTENTS
<br>

<br>
Part I
<br>

<br>
Background
<br>

<br>
13
<br>

<br>
Chapter 1
<br>

<br>
About this book (ES2019 edition)
<br>
Contents
<br>
1.1
<br>

<br>
Can I preview the supplementary material for this book? . . . . . .
<br>

<br>
15
<br>

<br>
1.2
<br>

<br>
What’s in this book? . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
15
<br>

<br>
1.3
<br>

<br>
What is not covered by this book? . . . . . . . . . . . . . . . . . . .
<br>

<br>
16
<br>

<br>
1.4
<br>

<br>
Isn’t this book too long for impatient people? . . . . . . . . . . . . .
<br>

<br>
16
<br>

<br>
1.5
<br>

<br>
About the author . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
16
<br>

<br>
1.6
<br>

<br>
Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
16
<br>

<br>
1.1 Can I preview the supplementary material for this
<br>
book?
<br>
Yes! On the homepage of this book, you’ll ﬁnd:
<br>
• Comprehensive previews (about 50%) of the exercises and quizzes.
<br>
• Additionally, all essential chapters of this book are free to read online.
<br>

<br>
1.2 What’s in this book?
<br>
This book makes JavaScript less challenging to learn for newcomers, by offering a modern
<br>
view that is as consistent as possible.
<br>
Highlights:
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Get started quickly by initially focusing on modern features.
<br>
Test-driven exercises and quizzes available for most chapters.
<br>
Covers all essential features of JavaScript, up to and including ES2019.
<br>
Optional advanced sections let you dig deeper.
<br>

<br>
No prior knowledge of JavaScript is required, but you should know how to program.
<br>
15
<br>

<br>
16
<br>

<br>
1 About this book (ES2019 edition)
<br>

<br>
1.3 What is not covered by this book?
<br>
• Some advanced language features are not explained, but references to appropriate material are provided – for example, to my other JavaScript books at ExploringJS.com, which are free to read online.
<br>
• This book deliberately focuses on the language. Browser-only features, etc. are not
<br>
described.
<br>

<br>
1.4 Isn’t this book too long for impatient people?
<br>
There are several ways in which you can read this book. One of them involves skipping
<br>
much of the content in order to get started quickly. For details, see §2.1.1 “In which order
<br>
should I read the content in this book?”.
<br>

<br>
1.5 About the author
<br>
Dr. Axel Rauschmayer specializes in JavaScript and web development. He has been developing web applications since 1995. In 1999, he was technical manager at a German
<br>
internet startup that later expanded internationally. In 2006, he held his ﬁrst talk on Ajax.
<br>
In 2010, he received a PhD in Informatics from the University of Munich.
<br>
Since 2011, he has been blogging about web development at 2ality.com and has written
<br>
several books on JavaScript. He has held trainings and talks for companies such as eBay,
<br>
Bank of America, and O’Reilly.
<br>
He lives in Munich, Germany.
<br>

<br>
1.6 Acknowledgements
<br>
• Cover by Fran Caye
<br>
• Parts of this book were edited by Adaobi Obi Tulton.
<br>
• Thanks for answering questions, discussing language topics, etc.:
<br>
– Allen Wirfs-Brock (@awbjs)
<br>
– Daniel Ehrenberg (@littledan)
<br>
– Mathias Bynens (@mathias)
<br>
– And many others
<br>
• Thanks for reviewing:
<br>
– Johannes Weber (@jowe)
<br>
[Generated: 2019-08-20 15:34]
<br>

<br>
Chapter 2
<br>

<br>
FAQ: Book and supplementary
<br>
material
<br>
Contents
<br>
2.1
<br>

<br>
2.2
<br>

<br>
2.3
<br>

<br>
How to read this book . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
17
<br>

<br>
2.1.1
<br>

<br>
In which order should I read the content in this book? . . . . .
<br>

<br>
17
<br>

<br>
2.1.2
<br>

<br>
Why are some chapters and sections marked with “(advanced)”? 18
<br>

<br>
2.1.3
<br>

<br>
Why are some chapters marked with “(bonus)”? . . . . . . . .
<br>

<br>
18
<br>

<br>
Digital editions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
18
<br>

<br>
2.2.1
<br>

<br>
How can I buy a digital edition of this book? . . . . . . . . . .
<br>

<br>
18
<br>

<br>
2.2.2
<br>

<br>
How do I submit feedback and corrections? . . . . . . . . . . .
<br>

<br>
18
<br>

<br>
2.2.3
<br>

<br>
How do I get updates for the downloads I bought at Payhip? .
<br>

<br>
18
<br>

<br>
Notations and conventions . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
18
<br>

<br>
2.3.1
<br>

<br>
What is a type signature? Why am I seeing static types in this
<br>
book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
18
<br>

<br>
2.3.2
<br>

<br>
What do the notes with icons mean? . . . . . . . . . . . . . . .
<br>

<br>
19
<br>

<br>
This chapter answers questions you may have and gives tips for reading this book.
<br>

<br>
2.1 How to read this book
<br>
2.1.1 In which order should I read the content in this book?
<br>
This book is three books in one:
<br>
• You can use it to get started with JavaScript as quickly as possible. This “mode” is
<br>
for impatient people:
<br>
– Start reading with §7 “The big picture”.
<br>
– Skip all chapters and sections marked as “advanced”, and all quick references.
<br>
• It gives you a comprehensive look at current JavaScript. In this “mode”, you read
<br>
everything and don’t skip advanced content and quick references.
<br>
17
<br>

<br>
18
<br>

<br>
2 FAQ: Book and supplementary material
<br>

<br>
• It serves as a reference. If there is a topic that you are interested in, you can ﬁnd information on it via the table of contents or via the index. Due to basic and advanced
<br>
content being mixed, everything you need is usually in a single location.
<br>
The quizzes and exercises play an important part in helping you practice and retain what
<br>
you have learned.
<br>

<br>
2.1.2 Why are some chapters and sections marked with “(advanced)”?
<br>
Several chapters and sections are marked with “(advanced)”. The idea is that you can
<br>
initially skip them. That is, you can get a quick working knowledge of JavaScript by only
<br>
reading the basic (non-advanced) content.
<br>
As your knowledge evolves, you can later come back to some or all of the advanced
<br>
content.
<br>

<br>
2.1.3 Why are some chapters marked with “(bonus)”?
<br>
The bonus chapters are only available in the paid versions of this book (print and ebook).
<br>
They are listed in the full table of contents.
<br>

<br>
2.2 Digital editions
<br>
2.2.1 How can I buy a digital edition of this book?
<br>
There are two digital editions of “JavaScript for impatient programmers”:
<br>
• Ebooks: PDF, EPUB, MOBI, HTML (all without DRM)
<br>
• Ebooks plus exercises and quizzes
<br>
The home page of this book describes how you can buy them.
<br>

<br>
2.2.2 How do I submit feedback and corrections?
<br>
The HTML version of this book (online, or ad-free archive in the paid version) has a link
<br>
at the end of each chapter that enables you to give feedback.
<br>

<br>
2.2.3 How do I get updates for the downloads I bought at Payhip?
<br>
• The receipt email for the purchase includes a link. You’ll always be able to download the latest version of the ﬁles at that location.
<br>
• If you opted into emails while buying, then you’ll get an email whenever there is
<br>
new content. To opt in later, you must contact Payhip (see bottom of payhip.com).
<br>

<br>
2.3 Notations and conventions
<br>
2.3.1 What is a type signature? Why am I seeing static types in this
<br>
book?
<br>
For example, you may see:
<br>

<br>
2.3 Notations and conventions
<br>

<br>
19
<br>

<br>
Number.isFinite(num: number): boolean
<br>

<br>
That is called the type signature of Number.isFinite(). This notation, especially the static
<br>
types number of num and boolean of the result, are not real JavaScript. The notation
<br>
is borrowed from the compile-to-JavaScript language TypeScript (which is mostly just
<br>
JavaScript plus static typing).
<br>
Why is this notation being used? It helps give you a quick idea of how a function works.
<br>
The notation is explained in detail in a 2ality blog post, but is usually relatively intuitive.
<br>

<br>
2.3.2 What do the notes with icons mean?
<br>
Reading instructions
<br>
Explains how to best read the content.
<br>

<br>
External content
<br>
Points to additional, external, content.
<br>

<br>
Tip
<br>
Gives a tip related to the current content.
<br>

<br>
Question
<br>
Asks and answers a question pertinent to the current content (think FAQ).
<br>

<br>
Warning
<br>
Warns about pitfalls, etc.
<br>

<br>
Details
<br>
Provides additional details, complementing the current content. It is similar to a
<br>
footnote.
<br>

<br>
20
<br>

<br>
2 FAQ: Book and supplementary material
<br>

<br>
Exercise
<br>
Mentions the path of a test-driven exercise that you can do at that point.
<br>

<br>
Quiz
<br>
Indicates that there is a quiz for the current (part of a) chapter.
<br>

<br>
Chapter 3
<br>

<br>
Why JavaScript? (bonus)
<br>
Contents
<br>
3.1
<br>

<br>
The cons of JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
21
<br>

<br>
3.2
<br>

<br>
The pros of JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
22
<br>

<br>
3.2.1
<br>

<br>
Community . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
22
<br>

<br>
3.2.2
<br>

<br>
Practically useful . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
22
<br>

<br>
3.2.3
<br>

<br>
Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
23
<br>

<br>
Pro and con of JavaScript: innovation . . . . . . . . . . . . . . . . .
<br>

<br>
23
<br>

<br>
3.3
<br>

<br>
In this chapter, we examine the pros and cons of JavaScript.
<br>

<br>
“ECMAScript 6” and “ES6” refer to versions of JavaScript
<br>
ECMAScript is the name of the language standard; the number refers to the version
<br>
of that standard. For more information, consult §5.2 “Standardizing JavaScript”.
<br>

<br>
3.1 The cons of JavaScript
<br>
Among programmers, JavaScript isn’t always well liked. One reason is that it has a fair
<br>
amount of quirks. Some of them are just unusual ways of doing something. Others are
<br>
considered bugs. Either way, learning why JavaScript does something the way it does,
<br>
helps with dealing with the quirks and with accepting JavaScript (maybe even liking it).
<br>
Hopefully, this book can be of assistance here.
<br>
Additionally, many traditional quirks have been eliminated now. For example:
<br>
• Traditionally, JavaScript variables weren’t block-scoped. ES6 introduced let and
<br>
const, which let you declare block-scoped variables.
<br>
• Prior to ES6, implementing object factories and inheritance via function and .prototype was clumsy. ES6 introduced classes, which provide more convenient syntax for these mechanisms.
<br>
21
<br>

<br>
22
<br>

<br>
3 Why JavaScript? (bonus)
<br>

<br>
• Traditionally, JavaScript did not have built-in modules. ES6 added them to the
<br>
language.
<br>
Lastly, JavaScript’s standard library is limited, but:
<br>
• There are plans for adding more functionality.
<br>
• Many libraries are easily available via the npm software registry.
<br>

<br>
3.2 The pros of JavaScript
<br>
On the plus side, JavaScript offers many beneﬁts.
<br>

<br>
3.2.1 Community
<br>
JavaScript’s popularity means that it’s well supported and well documented. Whenever
<br>
you create something in JavaScript, you can rely on many people being (potentially) interested. And there is a large pool of JavaScript programmers from which you can hire,
<br>
if you need to.
<br>
No single party controls JavaScript – it is evolved by TC39, a committee comprising many
<br>
organizations. The language is evolved via an open process that encourages feedback
<br>
from the public.
<br>

<br>
3.2.2 Practically useful
<br>
With JavaScript, you can write apps for many client platforms. These are a few example
<br>
technologies:
<br>
• Progressive Web Apps can be installed natively on Android and many desktop operating systems.
<br>
• Electron lets you build cross-platform desktop apps.
<br>
• React Native lets you write apps for iOS and Android that have native user interfaces.
<br>
• Node.js provides extensive support for writing shell scripts (in addition to being a
<br>
platform for web servers).
<br>
JavaScript is supported by many server platforms and services – for example:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Node.js (many of the following services are based on Node.js or support its APIs)
<br>
ZEIT Now
<br>
Microsoft Azure Functions
<br>
AWS Lambda
<br>
Google Cloud Functions
<br>

<br>
There are many data technologies available for JavaScript: many databases support it
<br>
and intermediate layers (such as GraphQL) exist. Additionally, the standard data format
<br>
JSON (JavaScript Object Notation) is based on JavaScript and supported by its standard
<br>
library.
<br>
Lastly, many, if not most, tools for JavaScript are written in JavaScript. That includes IDEs,
<br>
build tools, and more. As a consequence, you install them the same way you install your
<br>
libraries and you can customize them in JavaScript.
<br>

<br>
3.3 Pro and con of JavaScript: innovation
<br>

<br>
23
<br>

<br>
3.2.3 Language
<br>
• Many libraries are available, via the de-facto standard in the JavaScript universe,
<br>
the npm software registry.
<br>
• If you are unhappy with “plain” JavaScript, it is relatively easy to add more features:
<br>
– You can compile future and modern language features to current and past
<br>
versions of JavaScript, via Babel.
<br>
– You can add static typing, via TypeScript and Flow.
<br>
– You can work with ReasonML, which is, roughly, OCaml with JavaScript syntax. It can be compiled to JavaScript or native code.
<br>
• The language is ﬂexible: it is dynamic and supports both object-oriented programming and functional programming.
<br>
• JavaScript has become suprisingly fast for such a dynamic language.
<br>
– Whenever it isn’t fast enough, you can switch to WebAssembly, a universal
<br>
virtual machine built into most JavaScript engines. It can run static code at
<br>
nearly native speeds.
<br>

<br>
3.3 Pro and con of JavaScript: innovation
<br>
There is much innovation in the JavaScript ecosystem: new approaches to implementing
<br>
user interfaces, new ways of optimizing the delivery of software, and more. The upside is
<br>
that you will constantly learn new things. The downside is that the constant change can
<br>
be exhausting at times. Thankfully, things have somewhat slowed down, recently: all of
<br>
ES6 (which was a considerable modernization of the language) is becoming established,
<br>
as are certain tools and workﬂows.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
24
<br>

<br>
3 Why JavaScript? (bonus)
<br>

<br>
Chapter 4
<br>

<br>
The nature of JavaScript (bonus)
<br>
Contents
<br>
4.1
<br>

<br>
JavaScript’s inﬂuences . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
25
<br>

<br>
4.2
<br>

<br>
The nature of JavaScript . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
25
<br>

<br>
4.2.1
<br>

<br>
JavaScript often fails silently . . . . . . . . . . . . . . . . . . .
<br>

<br>
26
<br>

<br>
Tips for getting started with JavaScript . . . . . . . . . . . . . . . . .
<br>

<br>
26
<br>

<br>
4.3
<br>

<br>
4.1 JavaScript’s inﬂuences
<br>
When JavaScript was created in 1995, it was inﬂuenced by several programming languages:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
JavaScript’s syntax is largely based on Java.
<br>
Self inspired JavaScript’s prototypal inheritance.
<br>
Closures and environments were borrowed from Scheme.
<br>
AWK inﬂuenced JavaScript’s functions (including the keyword function).
<br>
JavaScript’s strings, Arrays, and regular expressions take cues from Perl.
<br>
HyperTalk inspired event handling via onclick in web browsers.
<br>

<br>
With ECMAScript 6, new inﬂuences came to JavaScript:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Generators were borrowed from Python.
<br>
The syntax of arrow functions came from CoffeeScript.
<br>
C++ contributed the keyword const.
<br>
Destructuring was inspired by Lisp’s destructuring bind.
<br>
Template literals came from the E language (where they are called quasi literals).
<br>

<br>
4.2 The nature of JavaScript
<br>
These are a few traits of the language:
<br>
• Its syntax is part of the C family of languages (curly braces, etc.).
<br>
25
<br>

<br>
26
<br>

<br>
4 The nature of JavaScript (bonus)
<br>

<br>
• It is a dynamic language: most objects can be changed in various ways at runtime,
<br>
objects can be created directly, etc.
<br>
• It is a dynamically typed language: variables don’t have ﬁxed static types and you
<br>
can assign any value to a given (mutable) variable.
<br>
• It has functional programming features: ﬁrst-class functions, closures, partial application via bind(), etc.
<br>
• It has object-oriented features: mutable state, objects, inheritance, classes, etc.
<br>
• It often fails silently: see the next subsection for details.
<br>
• It is deployed as source code. But that source code is often miniﬁed (rewritten to
<br>
require less storage). And there are plans for a binary source code format.
<br>
• JavaScript is part of the web platform – it is the language built into web browsers.
<br>
But it is also used elsewhere – for example, in Node.js, for server things, and shell
<br>
scripting.
<br>
• JavaScript engines often optimize less-efﬁcient language mechanisms under the
<br>
hood. For example, in principle, JavaScript Arrays are dictionaries. But under the
<br>
hood, engines store Arrays contiguously if they have contiguous indices.
<br>

<br>
4.2.1 JavaScript often fails silently
<br>
JavaScript often fails silently. Let’s look at two examples.
<br>
First example: If the operands of an operator don’t have the appropriate types, they are
<br>
converted as necessary.
<br>
> '3' * '5'
<br>
15
<br>

<br>
Second example: If an arithmetic computation fails, you get an error value, not an exception.
<br>
> 1 / 0
<br>
Infinity
<br>

<br>
The reason for the silent failures is historical: JavaScript did not have exceptions until
<br>
ECMAScript 3. Since then, its designers have tried to avoid silent failures.
<br>

<br>
4.3 Tips for getting started with JavaScript
<br>
These are a few tips to help you get started with JavaScript:
<br>
• Take your time to really get to know this language. The conventional C-style syntax
<br>
hides that this is a very unconventional language. Learn especially the quirks and
<br>
the rationales behind them. Then you will understand and appreciate the language
<br>
better.
<br>
– In addition to details, this book also teaches simple rules of thumb to be safe
<br>
– for example, “Always use === to determine if two values are equal, never
<br>
==.”
<br>

<br>
4.3 Tips for getting started with JavaScript
<br>

<br>
27
<br>

<br>
• Language tools make it easier to work with JavaScript. For example:
<br>
– You can statically type JavaScript via TypeScript or Flow.
<br>
– You can check for problems and anti-patterns via linters such as ESLint.
<br>
– You can format your code automatically via code formatters such as Prettier.
<br>
• Get in contact with the community:
<br>
– Twitter is popular among JavaScript programmers. As a mode of communication that sits between the spoken and the written word, it is well suited for
<br>
exchanging knowledge.
<br>
– Many cities have regular free meetups where people come together to learn
<br>
topics related to JavaScript.
<br>
– JavaScript conferences are another convenient way of meeting other
<br>
JavaScript programmers.
<br>
• Read books and blogs. Much material is free online!
<br>

<br>
28
<br>

<br>
4 The nature of JavaScript (bonus)
<br>

<br>
Chapter 5
<br>

<br>
History and evolution of
<br>
JavaScript
<br>
Contents
<br>
5.1
<br>

<br>
How JavaScript was created . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
29
<br>

<br>
5.2
<br>

<br>
Standardizing JavaScript . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
30
<br>

<br>
5.3
<br>

<br>
Timeline of ECMAScript versions . . . . . . . . . . . . . . . . . . .
<br>

<br>
30
<br>

<br>
5.4
<br>

<br>
Ecma Technical Committee 39 (TC39) . . . . . . . . . . . . . . . . . .
<br>

<br>
31
<br>

<br>
5.5
<br>

<br>
The TC39 process . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
31
<br>

<br>
5.5.1
<br>
5.6
<br>

<br>
5.7
<br>

<br>
Tip: Think in individual features and stages, not ECMAScript
<br>
versions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
31
<br>

<br>
FAQ: TC39 process . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
33
<br>

<br>
5.6.1
<br>

<br>
How is [my favorite proposed feature] doing? . . . . . . . . .
<br>

<br>
33
<br>

<br>
5.6.2
<br>

<br>
Is there an ofﬁcial list of ECMAScript features? . . . . . . . . .
<br>

<br>
33
<br>

<br>
Evolving JavaScript: Don’t break the web . . . . . . . . . . . . . . .
<br>

<br>
33
<br>

<br>
5.1 How JavaScript was created
<br>
JavaScript was created in May 1995 in 10 days, by Brendan Eich. Eich worked at Netscape
<br>
and implemented JavaScript for their web browser, Netscape Navigator.
<br>
The idea was that major interactive parts of the client-side web were to be implemented
<br>
in Java. JavaScript was supposed to be a glue language for those parts and to also make
<br>
HTML slightly more interactive. Given its role of assisting Java, JavaScript had to look
<br>
like Java. That ruled out existing solutions such as Perl, Python, TCL, and others.
<br>
Initially, JavaScript’s name changed several times:
<br>
• Its code name was Mocha.
<br>
• In the Netscape Navigator 2.0 betas (September 1995), it was called LiveScript.
<br>
• In Netscape Navigator 2.0 beta 3 (December 1995), it got its ﬁnal name, JavaScript.
<br>
29
<br>

<br>
30
<br>

<br>
5 History and evolution of JavaScript
<br>

<br>
5.2 Standardizing JavaScript
<br>
There are two standards for JavaScript:
<br>
• ECMA-262 is hosted by Ecma International. It is the primary standard.
<br>
• ISO/IEC 16262 is hosted by the International Organization for Standardization
<br>
(ISO) and the International Electrotechnical Commission (IEC). This is a secondary
<br>
standard.
<br>
The language described by these standards is called ECMAScript, not JavaScript. A different name was chosen because Sun (now Oracle) had a trademark for the latter name. The
<br>
“ECMA” in “ECMAScript” comes from the organization that hosts the primary standard.
<br>
The original name of that organization was ECMA, an acronym for European Computer
<br>
Manufacturers Association. It was later changed to Ecma International (with “Ecma” being
<br>
a proper name, not an acronym) because the organization’s activities had expanded beyond Europe. The initial all-caps acronym explains the spelling of ECMAScript.
<br>
In principle, JavaScript and ECMAScript mean the same thing. Sometimes the following
<br>
distinction is made:
<br>
• The term JavaScript refers to the language and its implementations.
<br>
• The term ECMAScript refers to the language standard and language versions.
<br>
Therefore, ECMAScript 6 is a version of the language (its 6th edition).
<br>

<br>
5.3 Timeline of ECMAScript versions
<br>
This is a brief timeline of ECMAScript versions:
<br>
• ECMAScript 1 (June 1997): First version of the standard.
<br>
• ECMAScript 2 (June 1998): Small update to keep ECMA-262 in sync with the ISO
<br>
standard.
<br>
• ECMAScript 3 (December 1999): Adds many core features – “[…] regular expressions, better string handling, new control statements [do-while, switch], try/catch
<br>
exception handling, […]”
<br>
• ECMAScript 4 (abandoned in July 2008): Would have been a massive upgrade
<br>
(with static typing, modules, namespaces, and more), but ended up being too ambitious and dividing the language’s stewards.
<br>
• ECMAScript 5 (December 2009): Brought minor improvements – a few standard
<br>
library features and strict mode.
<br>
• ECMAScript 5.1 (June 2011): Another small update to keep Ecma and ISO standards in sync.
<br>
• ECMAScript 6 (June 2015): A large update that fulﬁlled many of the promises of
<br>
ECMAScript 4. This version is the ﬁrst one whose ofﬁcial name – ECMAScript 2015
<br>
– is based on the year of publication.
<br>
• ECMAScript 2016 (June 2016): First yearly release. The shorter release life cycle
<br>
resulted in fewer new features compared to the large ES6.
<br>
• ECMAScript 2017 (June 2017). Second yearly release.
<br>
• Subsequent ECMAScript versions (ES2018, etc.) are always ratiﬁed in June.
<br>

<br>
5.4 Ecma Technical Committee 39 (TC39)
<br>

<br>
31
<br>

<br>
5.4 Ecma Technical Committee 39 (TC39)
<br>
TC39 is the committee that evolves JavaScript. Its member are, strictly speaking, companies: Adobe, Apple, Facebook, Google, Microsoft, Mozilla, Opera, Twitter, and others.
<br>
That is, companies that are usually ﬁerce competitors are working together for the good
<br>
of the language.
<br>
Every two months, TC39 has meetings that member-appointed delegates and invited
<br>
experts attend. The minutes of those meetings are public in a GitHub repository.
<br>

<br>
5.5 The TC39 process
<br>
With ECMAScript 6, two issues with the release process used at that time became obvious:
<br>
• If too much time passes between releases then features that are ready early, have
<br>
to wait a long time until they can be released. And features that are ready late, risk
<br>
being rushed to make the deadline.
<br>
• Features were often designed long before they were implemented and used. Design deﬁciencies related to implementation and use were therefore discovered too
<br>
late.
<br>
In response to these issues, TC39 instituted the new TC39 process:
<br>
• ECMAScript features are designed independently and go through stages, starting
<br>
at 0 (“strawman”), ending at 4 (“ﬁnished”).
<br>
• Especially the later stages require prototype implementations and real-world testing, leading to feedback loops between designs and implementations.
<br>
• ECMAScript versions are released once per year and include all features that have
<br>
reached stage 4 prior to a release deadline.
<br>
The result: smaller, incremental releases, whose features have already been ﬁeld-tested.
<br>
Fig. 5.1 illustrates the TC39 process.
<br>
ES2016 was the ﬁrst ECMAScript version that was designed according to the TC39 process.
<br>

<br>
5.5.1 Tip: Think in individual features and stages, not ECMAScript
<br>
versions
<br>
Up to and including ES6, it was most common to think about JavaScript in terms of
<br>
ECMAScript versions – for example, “Does this browser support ES6 yet?”
<br>
Starting with ES2016, it’s better to think in individual features: once a feature reaches
<br>
stage 4, you can safely use it (if it’s supported by the JavaScript engines you are targeting).
<br>
You don’t have to wait until the next ECMAScript release.
<br>

<br>
32
<br>

<br>
5 History and evolution of JavaScript
<br>

<br>
Review at TC39 meeting
<br>
Stage 0: strawman
<br>

<br>
Sketch
<br>

<br>
Pick champions
<br>
Stage 1: proposal
<br>

<br>
TC39 helps
<br>

<br>
First spec text, 2 implementations
<br>
Stage 2: draft
<br>

<br>
Likely to be standardized
<br>

<br>
Spec complete
<br>
Stage 3: candidate
<br>

<br>
Done, needs feedback from implementations
<br>

<br>
Test 262 acceptance tests
<br>
Stage 4: finished
<br>

<br>
Ready for standardization
<br>

<br>
Figure 5.1: Each ECMAScript feature proposal goes through stages that are numbered
<br>
from 0 to 4. Champions are TC39 members that support the authors of a feature. Test
<br>
262 is a suite of tests that checks JavaScript engines for compliance with the language
<br>
speciﬁcation.
<br>

<br>
5.6 FAQ: TC39 process
<br>

<br>
33
<br>

<br>
5.6 FAQ: TC39 process
<br>
5.6.1 How is [my favorite proposed feature] doing?
<br>
If you are wondering what stages various proposed features are in, consult the GitHub
<br>
repository proposals.
<br>

<br>
5.6.2 Is there an ofﬁcial list of ECMAScript features?
<br>
Yes, the TC39 repo lists ﬁnished proposals and mentions in which ECMAScript versions
<br>
they were introduced.
<br>

<br>
5.7 Evolving JavaScript: Don’t break the web
<br>
One idea that occasionally comes up is to clean up JavaScript by removing old features
<br>
and quirks. While the appeal of that idea is obvious, it has signiﬁcant downsides.
<br>
Let’s assume we create a new version of JavaScript that is not backward compatible and
<br>
ﬁx all of its ﬂaws. As a result, we’d encounter the following problems:
<br>
• JavaScript engines become bloated: they need to support both the old and the new
<br>
version. The same is true for tools such as IDEs and build tools.
<br>
• Programmers need to know, and be continually conscious of, the differences between the versions.
<br>
• You can either migrate all of an existing code base to the new version (which can
<br>
be a lot of work). Or you can mix versions and refactoring becomes harder because
<br>
you can’t move code between versions without changing it.
<br>
• You somehow have to specify per piece of code – be it a ﬁle or code embedded in
<br>
a web page – what version it is written in. Every conceivable solution has pros
<br>
and cons. For example, strict mode is a slightly cleaner version of ES5. One of the
<br>
reasons why it wasn’t as popular as it should have been: it was a hassle to opt in
<br>
via a directive at the beginning of a ﬁle or a function.
<br>
So what is the solution? Can we have our cake and eat it? The approach that was chosen
<br>
for ES6 is called “One JavaScript”:
<br>
• New versions are always completely backward compatible (but there may occasionally be minor, hardly noticeable clean-ups).
<br>
• Old features aren’t removed or ﬁxed. Instead, better versions of them are introduced. One example is declaring variables via let – which is an improved version
<br>
of var.
<br>
• If aspects of the language are changed, it is done inside new syntactic constructs.
<br>
That is, you opt in implicitly. For example, yield is only a keyword inside generators (which were introduced in ES6). And all code inside modules and classes
<br>
(both introduced in ES6) is implicitly in strict mode.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
34
<br>

<br>
5 History and evolution of JavaScript
<br>

<br>
Chapter 6
<br>

<br>
FAQ: JavaScript
<br>
Contents
<br>
6.1
<br>

<br>
What are good references for JavaScript? . . . . . . . . . . . . . . . .
<br>

<br>
35
<br>

<br>
6.2
<br>

<br>
How do I ﬁnd out what JavaScript features are supported where? . .
<br>

<br>
35
<br>

<br>
6.3
<br>

<br>
Where can I look up what features are planned for JavaScript? . . .
<br>

<br>
36
<br>

<br>
6.4
<br>

<br>
Why does JavaScript fail silently so often? . . . . . . . . . . . . . . .
<br>

<br>
36
<br>

<br>
6.5
<br>

<br>
Why can’t we clean up JavaScript, by removing quirks and outdated
<br>
features? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
36
<br>

<br>
6.6
<br>

<br>
How can I quickly try out a piece of JavaScript code? . . . . . . . . .
<br>

<br>
36
<br>

<br>
6.1 What are good references for JavaScript?
<br>
Please consult §7.3 “JavaScript references”.
<br>

<br>
6.2 How do I ﬁnd out what JavaScript features are supported where?
<br>
This book usually mentions if a feature is part of ECMAScript 5 (as required by older
<br>
browsers) or a newer version. For more detailed information (including pre-ES5 versions), there are several good compatibility tables available online:
<br>
• ECMAScript compatibility tables for various engines (by kangax, webbedspace,
<br>
zloirock)
<br>
• Node.js compatibility tables (by William Kapke)
<br>
• Mozilla’s MDN web docs have tables for each feature that describe relevant ECMAScript versions and browser support.
<br>
• “Can I use…” documents what features (including JavaScript language features)
<br>
are supported by web browsers.
<br>
35
<br>

<br>
36
<br>

<br>
6 FAQ: JavaScript
<br>

<br>
6.3 Where can I look up what features are planned for
<br>
JavaScript?
<br>
Please consult the following sources:
<br>
• §5.5 “The TC39 process” describes how upcoming features are planned.
<br>
• §5.6 “FAQ: TC39 process” answers various questions regarding upcoming features.
<br>

<br>
6.4 Why does JavaScript fail silently so often?
<br>
JavaScript often fails silently. Let’s look at two examples.
<br>
First example: If the operands of an operator don’t have the appropriate types, they are
<br>
converted as necessary.
<br>
> '3' * '5'
<br>
15
<br>

<br>
Second example: If an arithmetic computation fails, you get an error value, not an exception.
<br>
> 1 / 0
<br>
Infinity
<br>

<br>
The reason for the silent failures is historical: JavaScript did not have exceptions until
<br>
ECMAScript 3. Since then, its designers have tried to avoid silent failures.
<br>

<br>
6.5 Why can’t we clean up JavaScript, by removing quirks
<br>
and outdated features?
<br>
This question is answered in §5.7 “Evolving JavaScript: Don’t break the web”.
<br>

<br>
6.6 How can I quickly try out a piece of JavaScript code?
<br>
§9.1 “Trying out JavaScript code” explains how to do that.
<br>

<br>
Part II
<br>

<br>
First steps
<br>

<br>
37
<br>

<br>
Chapter 7
<br>

<br>
The big picture
<br>
Contents
<br>
7.1
<br>
7.2
<br>
7.3
<br>
7.4
<br>

<br>
What are you learning in this book? .
<br>
The structure of browsers and Node.js
<br>
JavaScript references . . . . . . . . . .
<br>
Further reading . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
39
<br>
39
<br>
40
<br>
40
<br>

<br>
In this chapter, I’d like to paint the big picture: what are you learning in this book, and
<br>
how does it ﬁt into the overall landscape of web development?
<br>

<br>
7.1 What are you learning in this book?
<br>
This book teaches the JavaScript language. It focuses on just the language, but offers
<br>
occasional glimpses at two platforms where JavaScript can be used:
<br>
• Web browser
<br>
• Node.js
<br>
Node.js is important for web development in three ways:
<br>
• You can use it to write server-side software in JavaScript.
<br>
• You can also use it to write software for the command line (think Unix shell, Windows PowerShell, etc.). Many JavaScript-related tools are based on (and executed
<br>
via) Node.js.
<br>
• Node’s software registry, npm, has become the dominant way of installing tools
<br>
(such as compilers and build tools) and libraries – even for client-side development.
<br>

<br>
7.2 The structure of browsers and Node.js
<br>
The structures of the two JavaScript platforms web browser and Node.js are similar (ﬁg. 7.1):
<br>
• The foundational layer consists of the JavaScript engine and platform-speciﬁc
<br>
“core” functionality.
<br>
39
<br>

<br>
40
<br>

<br>
7 The big picture
<br>

<br>
JS standard
<br>
library
<br>
JavaScript engine
<br>

<br>
Platform API
<br>
Platform core
<br>

<br>
Figure 7.1: The structure of the two JavaScript platforms web browser and Node.js. The
<br>
APIs “standard library” and “platform API” are hosted on top of a foundational layer
<br>
with a JavaScript engine and a platform-speciﬁc “core”.
<br>
• Two APIs are hosted on top of this foundation:
<br>
– The JavaScript standard library is part of JavaScript proper and runs on top
<br>
of the engine.
<br>
– The platform API are also available from JavaScript – it provides access to
<br>
platform-speciﬁc functionality. For example:
<br>
* In browsers, you need to use the platform-speciﬁc API if you want to do
<br>
anything related to the user interface: react to mouse clicks, play sounds,
<br>
etc.
<br>
* In Node.js, the platform-speciﬁc API lets you read and write ﬁles, download data via HTTP, etc.
<br>

<br>
7.3 JavaScript references
<br>
When you have a question about a JavaScript, a web search usually helps. I can recommend the following online sources:
<br>
• MDN web docs: cover various web technologies such as CSS, HTML, JavaScript,
<br>
and more. An excellent reference.
<br>
• Node.js Docs: document the Node.js API.
<br>
• ExploringJS.com: My other books on JavaScript go into greater detail than this
<br>
book and are free to read online. You can look up features by ECMAScript version:
<br>
– ES1–ES5: Speaking JavaScript
<br>
– ES6: Exploring ES6
<br>
– ES2016–ES2017: Exploring ES2016 and ES2017
<br>
– Etc.
<br>

<br>
7.4 Further reading
<br>
• §46 “Next steps: overview of web development” provides a more comprehensive
<br>
look at web development.
<br>

<br>
Chapter 8
<br>

<br>
Syntax
<br>
Contents
<br>
8.1
<br>

<br>
An overview of JavaScript’s syntax . . . . . . . . . . . . . . . . . . .
<br>

<br>
42
<br>

<br>
8.1.1
<br>

<br>
Basic syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
42
<br>

<br>
8.1.2
<br>

<br>
Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
44
<br>

<br>
8.1.3
<br>

<br>
Legal variable and property names . . . . . . . . . . . . . . .
<br>

<br>
45
<br>

<br>
8.1.4
<br>

<br>
Casing styles
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
45
<br>

<br>
8.1.5
<br>

<br>
Capitalization of names . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
45
<br>

<br>
8.1.6
<br>

<br>
More naming conventions . . . . . . . . . . . . . . . . . . . .
<br>

<br>
46
<br>

<br>
8.1.7
<br>

<br>
Where to put semicolons? . . . . . . . . . . . . . . . . . . . .
<br>

<br>
46
<br>

<br>
8.2
<br>

<br>
(Advanced) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
47
<br>

<br>
8.3
<br>

<br>
Identiﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
47
<br>

<br>
8.3.1
<br>

<br>
Valid identiﬁers (variable names, etc.) . . . . . . . . . . . . . .
<br>

<br>
47
<br>

<br>
8.3.2
<br>
8.4
<br>

<br>
8.5
<br>

<br>
Reserved words . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
47
<br>

<br>
Statement vs. expression . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
48
<br>

<br>
8.4.1
<br>

<br>
Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
48
<br>

<br>
8.4.2
<br>

<br>
Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
48
<br>

<br>
8.4.3
<br>

<br>
What is allowed where? . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
49
<br>

<br>
Ambiguous syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
49
<br>

<br>
8.5.1
<br>

<br>
Same syntax: function declaration and function expression . .
<br>

<br>
49
<br>

<br>
8.5.2
<br>

<br>
Same syntax: object literal and block
<br>

<br>
. . . . . . . . . . . . . .
<br>

<br>
50
<br>

<br>
8.5.3
<br>

<br>
Disambiguation . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
50
<br>

<br>
Semicolons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
50
<br>

<br>
8.6.1
<br>

<br>
Rule of thumb for semicolons . . . . . . . . . . . . . . . . . .
<br>

<br>
50
<br>

<br>
8.6.2
<br>

<br>
Semicolons: control statements . . . . . . . . . . . . . . . . . .
<br>

<br>
51
<br>

<br>
Automatic semicolon insertion (ASI) . . . . . . . . . . . . . . . . . .
<br>

<br>
51
<br>

<br>
8.7.1
<br>

<br>
ASI triggered unexpectedly
<br>

<br>
. . . . . . . . . . . . . . . . . . .
<br>

<br>
52
<br>

<br>
8.7.2
<br>

<br>
ASI unexpectedly not triggered . . . . . . . . . . . . . . . . .
<br>

<br>
52
<br>

<br>
8.8
<br>

<br>
Semicolons: best practices . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
53
<br>

<br>
8.9
<br>

<br>
Strict mode vs. sloppy mode . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
53
<br>

<br>
8.6
<br>

<br>
8.7
<br>

<br>
41
<br>

<br>
42
<br>

<br>
8 Syntax
<br>
8.9.1
<br>

<br>
Switching on strict mode . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
54
<br>

<br>
8.9.2
<br>

<br>
Improvements in strict mode . . . . . . . . . . . . . . . . . . .
<br>

<br>
54
<br>

<br>
8.1 An overview of JavaScript’s syntax
<br>
8.1.1 Basic syntax
<br>
Comments:
<br>
// single-line comment
<br>
/*
<br>
Comment with
<br>
multiple lines
<br>
*/
<br>

<br>
Primitive (atomic) values:
<br>
// Booleans
<br>
true
<br>
false
<br>
// Numbers (JavaScript only has a single type for numbers)
<br>
-123
<br>
1.141
<br>
// Strings (JavaScript has no type for characters)
<br>
'abc'
<br>
"abc"
<br>

<br>
An assertion describes what the result of a computation is expected to look like and throws
<br>
an exception if those expectations aren’t correct. For example, the following assertion
<br>
states that the result of the computation 7 plus 1 must be 8:
<br>
assert.equal(7 + 1, 8);
<br>
assert.equal() is a method call (the object is assert, the method is .equal()) with two
<br>

<br>
arguments: the actual result and the expected result. It is part of a Node.js assertion API
<br>
that is explained later in this book.
<br>
Logging to the console of a browser or Node.js:
<br>
// Printing a value to standard out (another method call)
<br>
console.log('Hello!');
<br>
// Printing error information to standard error
<br>
console.error('Something went wrong!');
<br>

<br>
Operators:
<br>
// Operators for booleans
<br>
assert.equal(true && false, false); // And
<br>

<br>
8.1 An overview of JavaScript’s syntax
<br>

<br>
43
<br>

<br>
assert.equal(true || false, true); // Or
<br>
// Operators for numbers
<br>
assert.equal(3 + 4, 7);
<br>
assert.equal(5 - 1, 4);
<br>
assert.equal(3 * 4, 12);
<br>
assert.equal(9 / 3, 3);
<br>
// Operators for strings
<br>
assert.equal('a' + 'b', 'ab');
<br>
assert.equal('I see ' + 3 + ' monkeys', 'I see 3 monkeys');
<br>
// Comparison operators
<br>
assert.equal(3 < 4, true);
<br>
assert.equal(3 <= 4, true);
<br>
assert.equal('abc' === 'abc', true);
<br>
assert.equal('abc' !== 'def', true);
<br>

<br>
Declaring variables:
<br>
let x; // declaring x (mutable)
<br>
x = 3 * 5; // assign a value to x
<br>
let y = 3 * 5; // declaring and assigning
<br>
const z = 8; // declaring z (immutable)
<br>

<br>
Control ﬂow statements:
<br>
// Conditional statement
<br>
if (x < 0) { // is x less than zero?
<br>
x = -x;
<br>
}
<br>

<br>
Ordinary function declarations:
<br>
// add1() has the parameters a and b
<br>
function add1(a, b) {
<br>
return a + b;
<br>
}
<br>
// Calling function add1()
<br>
assert.equal(add1(5, 2), 7);
<br>

<br>
Arrow function expressions (used especially as arguments of function calls and method
<br>
calls):
<br>
const add2 = (a, b) => { return a + b };
<br>
// Calling function add2()
<br>
assert.equal(add2(5, 2), 7);
<br>
// Equivalent to add2:
<br>
const add3 = (a, b) => a + b;
<br>

<br>
44
<br>

<br>
8 Syntax
<br>

<br>
The previous code contains the following two arrow functions (the terms expression and
<br>
statement are explained later in this chapter):
<br>
// An arrow function whose body is a code block
<br>
(a, b) => { return a + b }
<br>
// An arrow function whose body is an expression
<br>
(a, b) => a + b
<br>

<br>
Objects:
<br>
// Creating a plain object via an object literal
<br>
const obj = {
<br>
first: 'Jane', // property
<br>
last: 'Doe', // property
<br>
getFullName() { // property (method)
<br>
return this.first + ' ' + this.last;
<br>
},
<br>
};
<br>
// Getting a property value
<br>
assert.equal(obj.first, 'Jane');
<br>
// Setting a property value
<br>
obj.first = 'Janey';
<br>
// Calling the method
<br>
assert.equal(obj.getFullName(), 'Janey Doe');
<br>

<br>
Arrays (Arrays are also objects):
<br>
// Creating an Array via an Array literal
<br>
const arr = ['a', 'b', 'c'];
<br>
// Getting an Array element
<br>
assert.equal(arr[1], 'b');
<br>
// Setting an Array element
<br>
arr[1] = 'β';
<br>

<br>
8.1.2 Modules
<br>
Each module is a single ﬁle. Consider, for example, the following two ﬁles with modules
<br>
in them:
<br>
file-tools.mjs
<br>
main.mjs
<br>

<br>
The module in file-tools.mjs exports its function isTextFilePath():
<br>
export function isTextFilePath(filePath) {
<br>
return filePath.endsWith('.txt');
<br>
}
<br>

<br>
8.1 An overview of JavaScript’s syntax
<br>

<br>
45
<br>

<br>
The module in main.mjs imports the whole module path and the function isTextFilePath():
<br>
// Import whole module as namespace object `path`
<br>
import * as path from 'path';
<br>
// Import a single export of module file-tools.mjs
<br>
import {isTextFilePath} from './file-tools.mjs';
<br>

<br>
8.1.3 Legal variable and property names
<br>
The grammatical category of variable names and property names is called identiﬁer.
<br>
Identiﬁers are allowed to have the following characters:
<br>
• Unicode letters: A–Z, a–z (etc.)
<br>
• $, _
<br>
• Unicode digits: 0–9 (etc.)
<br>
– Variable names can’t start with a digit
<br>
Some words have special meaning in JavaScript and are called reserved. Examples include:
<br>
if, true, const.
<br>
Reserved words can’t be used as variable names:
<br>
const if = 123;
<br>
// SyntaxError: Unexpected token if
<br>

<br>
But they are allowed as names of properties:
<br>
> const obj = { if: 123 };
<br>
> obj.if
<br>
123
<br>

<br>
8.1.4 Casing styles
<br>
Common casing styles for concatenating words are:
<br>
• Camel case: threeConcatenatedWords
<br>
• Underscore case (also called snake case): three_concatenated_words
<br>
• Dash case (also called kebab case): three-concatenated-words
<br>

<br>
8.1.5 Capitalization of names
<br>
In general, JavaScript uses camel case, except for constants.
<br>
Lowercase:
<br>
• Functions, variables: myFunction
<br>
• Methods: obj.myMethod
<br>
• CSS:
<br>
– CSS entity: special-class
<br>
– Corresponding JavaScript variable: specialClass
<br>
Uppercase:
<br>

<br>
46
<br>

<br>
8 Syntax
<br>

<br>
• Classes: MyClass
<br>
• Constants: MY_CONSTANT
<br>
– Constants are also often written in camel case: myConstant
<br>

<br>
8.1.6 More naming conventions
<br>
The following naming conventions are popular in JavaScript.
<br>
If the name of a parameter starts with an underscore (or is an underscore) it means that
<br>
this parameter is not used – for example:
<br>
arr.map((_x, i) => i)
<br>

<br>
If the name of a property of an object starts with an underscore then that property is
<br>
considered private:
<br>
class ValueWrapper {
<br>
constructor(value) {
<br>
this._value = value;
<br>
}
<br>
}
<br>

<br>
8.1.7 Where to put semicolons?
<br>
At the end of a statement:
<br>
const x = 123;
<br>
func();
<br>

<br>
But not if that statement ends with a curly brace:
<br>
while (false) {
<br>
// ···
<br>
} // no semicolon
<br>
function func() {
<br>
// ···
<br>
} // no semicolon
<br>

<br>
However, adding a semicolon after such a statement is not a syntax error – it is interpreted
<br>
as an empty statement:
<br>
// Function declaration followed by empty statement:
<br>
function func() {
<br>
// ···
<br>
};
<br>

<br>
Quiz: basic
<br>
See quiz app.
<br>

<br>
8.2 (Advanced)
<br>

<br>
47
<br>

<br>
8.2 (Advanced)
<br>
All remaining sections of this chapter are advanced.
<br>

<br>
8.3 Identiﬁers
<br>
8.3.1 Valid identiﬁers (variable names, etc.)
<br>
First character:
<br>
• Unicode letter (including accented characters such as é and ü and characters from
<br>
non-latin alphabets, such as α)
<br>
• $
<br>
• _
<br>
Subsequent characters:
<br>
• Legal ﬁrst characters
<br>
• Unicode digits (including Eastern Arabic numerals)
<br>
• Some other Unicode marks and punctuations
<br>
Examples:
<br>
const ε = 0.0001;
<br>
const строка = '';
<br>
let _tmp = 0;
<br>
const $foo2 = true;
<br>

<br>
8.3.2 Reserved words
<br>
Reserved words can’t be variable names, but they can be property names.
<br>
All JavaScript keywords are reserved words:
<br>
await break case catch class const continue debugger default delete
<br>
do else export extends finally for function if import in instanceof
<br>
let new return static super switch this throw try typeof var void while
<br>
with yield
<br>

<br>
The following tokens are also keywords, but currently not used in the language:
<br>
enum implements package protected interface private public
<br>

<br>
The following literals are reserved words:
<br>
true false null
<br>

<br>
Technically, these words are not reserved, but you should avoid them, too, because they
<br>
effectively are keywords:
<br>
Infinity NaN undefined async
<br>

<br>
You shouldn’t use the names of global variables (String, Math, etc.) for your own variables and parameters, either.
<br>

<br>
48
<br>

<br>
8 Syntax
<br>

<br>
8.4 Statement vs. expression
<br>
In this section, we explore how JavaScript distinguishes two kinds of syntactic constructs:
<br>
statements and expressions. Afterward, we’ll see that that can cause problems because the
<br>
same syntax can mean different things, depending on where it is used.
<br>

<br>
We pretend there are only statements and expressions
<br>
For the sake of simplicity, we pretend that there are only statements and expressions
<br>
in JavaScript.
<br>

<br>
8.4.1 Statements
<br>
A statement is a piece of code that can be executed and performs some kind of action. For
<br>
example, if is a statement:
<br>
let myStr;
<br>
if (myBool) {
<br>
myStr = 'Yes';
<br>
} else {
<br>
myStr = 'No';
<br>
}
<br>

<br>
One more example of a statement: a function declaration.
<br>
function twice(x) {
<br>
return x + x;
<br>
}
<br>

<br>
8.4.2 Expressions
<br>
An expression is a piece of code that can be evaluated to produce a value. For example, the
<br>
code between the parentheses is an expression:
<br>
let myStr = (myBool ? 'Yes' : 'No');
<br>

<br>
The operator _?_:_ used between the parentheses is called the ternary operator. It is the
<br>
expression version of the if statement.
<br>
Let’s look at more examples of expressions. We enter expressions and the REPL evaluates
<br>
them for us:
<br>
> 'ab' + 'cd'
<br>
'abcd'
<br>
> Number('123')
<br>
123
<br>
> true || false
<br>
true
<br>

<br>
8.5 Ambiguous syntax
<br>

<br>
49
<br>

<br>
8.4.3 What is allowed where?
<br>
The current location within JavaScript source code determines which kind of syntactic
<br>
constructs you are allowed to use:
<br>
• The body of a function must be a sequence of statements:
<br>
function max(x, y) {
<br>
if (x > y) {
<br>
return x;
<br>
} else {
<br>
return y;
<br>
}
<br>
}
<br>

<br>
• The arguments of a function call or a method call must be expressions:
<br>
console.log('ab' + 'cd', Number('123'));
<br>

<br>
However, expressions can be used as statements. Then they are called expression statements. The opposite is not true: when the context requires an expression, you can’t use a
<br>
statement.
<br>
The following code demonstrates that any expression bar() can be either expression or
<br>
statement – it depends on the context:
<br>
function f() {
<br>
console.log(bar()); // bar() is expression
<br>
bar(); // bar(); is (expression) statement
<br>
}
<br>

<br>
8.5 Ambiguous syntax
<br>
JavaScript has several programming constructs that are syntactically ambiguous: the
<br>
same syntax is interpreted differently, depending on whether it is used in statement context or in expression context. This section explores the phenomenon and the pitfalls it
<br>
causes.
<br>

<br>
8.5.1 Same syntax: function declaration and function expression
<br>
A function declaration is a statement:
<br>
function id(x) {
<br>
return x;
<br>
}
<br>

<br>
A function expression is an expression (right-hand side of =):
<br>
const id = function me(x) {
<br>
return x;
<br>
};
<br>

<br>
50
<br>

<br>
8 Syntax
<br>

<br>
8.5.2 Same syntax: object literal and block
<br>
In the following code, {} is an object literal: an expression that creates an empty object.
<br>
const obj = {};
<br>

<br>
This is an empty code block (a statement):
<br>
{
<br>
}
<br>

<br>
8.5.3 Disambiguation
<br>
The ambiguities are only a problem in statement context: If the JavaScript parser encounters ambiguous syntax, it doesn’t know if it’s a plain statement or an expression statement.
<br>
For example:
<br>
• If a statement starts with function: Is it a function declaration or a function expression?
<br>
• If a statement starts with {: Is it an object literal or a code block?
<br>
To resolve the ambiguity, statements starting with function or { are never interpreted as
<br>
expressions. If you want an expression statement to start with either one of these tokens,
<br>
you must wrap it in parentheses:
<br>
(function (x) { console.log(x) })('abc');
<br>
// Output:
<br>
// 'abc'
<br>

<br>
In this code:
<br>
1. We ﬁrst create a function via a function expression:
<br>
function (x) { console.log(x) }
<br>

<br>
2. Then we invoke that function: ('abc')
<br>
The code fragment shown in (1) is only interpreted as an expression because we wrap it in
<br>
parentheses. If we didn’t, we would get a syntax error because then JavaScript expects a
<br>
function declaration and complains about the missing function name. Additionally, you
<br>
can’t put a function call immediately after a function declaration.
<br>
Later in this book, we’ll see more examples of pitfalls caused by syntactic ambiguity:
<br>
• Assigning via object destructuring
<br>
• Returning an object literal from an arrow function
<br>

<br>
8.6 Semicolons
<br>
8.6.1 Rule of thumb for semicolons
<br>
Each statement is terminated by a semicolon:
<br>

<br>
8.7 Automatic semicolon insertion (ASI)
<br>

<br>
51
<br>

<br>
const x = 3;
<br>
someFunction('abc');
<br>
i++;
<br>

<br>
except statements ending with blocks:
<br>
function foo() {
<br>
// ···
<br>
}
<br>
if (y > 0) {
<br>
// ···
<br>
}
<br>

<br>
The following case is slightly tricky:
<br>
const func = () => {}; // semicolon!
<br>

<br>
The whole const declaration (a statement) ends with a semicolon, but inside it, there is
<br>
an arrow function expression. That is, it’s not the statement per se that ends with a curly
<br>
brace; it’s the embedded arrow function expression. That’s why there is a semicolon at
<br>
the end.
<br>

<br>
8.6.2 Semicolons: control statements
<br>
The body of a control statement is itself a statement. For example, this is the syntax of
<br>
the while loop:
<br>
while (condition)
<br>
statement
<br>

<br>
The body can be a single statement:
<br>
while (a > 0) a--;
<br>

<br>
But blocks are also statements and therefore legal bodies of control statements:
<br>
while (a > 0) {
<br>
a--;
<br>
}
<br>

<br>
If you want a loop to have an empty body, your ﬁrst option is an empty statement (which
<br>
is just a semicolon):
<br>
while (processNextItem() > 0);
<br>

<br>
Your second option is an empty block:
<br>
while (processNextItem() > 0) {}
<br>

<br>
8.7 Automatic semicolon insertion (ASI)
<br>
While I recommend to always write semicolons, most of them are optional in JavaScript.
<br>
The mechanism that makes this possible is called automatic semicolon insertion (ASI). In a
<br>
way, it corrects syntax errors.
<br>

<br>
52
<br>

<br>
8 Syntax
<br>

<br>
ASI works as follows. Parsing of a statement continues until there is either:
<br>
• A semicolon
<br>
• A line terminator followed by an illegal token
<br>
In other words, ASI can be seen as inserting semicolons at line breaks. The next subsections cover the pitfalls of ASI.
<br>

<br>
8.7.1 ASI triggered unexpectedly
<br>
The good news about ASI is that – if you don’t rely on it and always write semicolons
<br>
– there is only one pitfall that you need to be aware of. It is that JavaScript forbids line
<br>
breaks after some tokens. If you do insert a line break, a semicolon will be inserted, too.
<br>
The token where this is most practically relevant is return. Consider, for example, the
<br>
following code:
<br>
return
<br>
{
<br>
first: 'jane'
<br>
};
<br>

<br>
This code is parsed as:
<br>
return;
<br>
{
<br>
first: 'jane';
<br>
}
<br>
;
<br>

<br>
That is:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Return statement without operand: return;
<br>
Start of code block: {
<br>
Expression statement 'jane'; with label first:
<br>
End of code block: }
<br>
Empty statement: ;
<br>

<br>
Why does JavaScript do this? It protects against accidentally returning a value in a line
<br>
after a return.
<br>

<br>
8.7.2 ASI unexpectedly not triggered
<br>
In some cases, ASI is not triggered when you think it should be. That makes life more
<br>
complicated for people who don’t like semicolons because they need to be aware of those
<br>
cases. The following are three examples. There are more.
<br>
Example 1: Unintended function call.
<br>
a = b + c
<br>
(d + e).print()
<br>

<br>
Parsed as:
<br>
a = b + c(d + e).print();
<br>

<br>
8.8 Semicolons: best practices
<br>

<br>
53
<br>

<br>
Example 2: Unintended division.
<br>
a = b
<br>
/hi/g.exec(c).map(d)
<br>

<br>
Parsed as:
<br>
a = b / hi / g.exec(c).map(d);
<br>

<br>
Example 3: Unintended property access.
<br>
someFunction()
<br>
['ul', 'ol'].map(x => x + x)
<br>

<br>
Executed as:
<br>
const propKey = ('ul','ol'); // comma operator
<br>
assert.equal(propKey, 'ol');
<br>
someFunction()[propKey].map(x => x + x);
<br>

<br>
8.8 Semicolons: best practices
<br>
I recommend that you always write semicolons:
<br>
• I like the visual structure it gives code – you clearly see when a statement ends.
<br>
• There are less rules to keep in mind.
<br>
• The majority of JavaScript programmers use semicolons.
<br>
However, there are also many people who don’t like the added visual clutter of semicolons. If you are one of them: Code without them is legal. I recommend that you use
<br>
tools to help you avoid mistakes. The following are two examples:
<br>
• The automatic code formatter Prettier can be conﬁgured to not use semicolons. It
<br>
then automatically ﬁxes problems. For example, if it encounters a line that starts
<br>
with a square bracket, it preﬁxes that line with a semicolon.
<br>
• The static checker ESLint has a rule that you tell your preferred style (always semicolons or as few semicolons as possible) and that warns you about critical issues.
<br>

<br>
8.9 Strict mode vs. sloppy mode
<br>
Starting with ECMAScript 5, JavaScript has two modes in which JavaScript can be executed:
<br>
• Normal “sloppy” mode is the default in scripts (code fragments that are a precursor
<br>
to modules and supported by browsers).
<br>
• Strict mode is the default in modules and classes, and can be switched on in scripts
<br>
(how, is explained later). In this mode, several pitfalls of normal mode are removed
<br>
and more exceptions are thrown.
<br>
You’ll rarely encounter sloppy mode in modern JavaScript code, which is almost always
<br>
located in modules. In this book, I assume that strict mode is always switched on.
<br>

<br>
54
<br>

<br>
8 Syntax
<br>

<br>
8.9.1 Switching on strict mode
<br>
In script ﬁles and CommonJS modules, you switch on strict mode for a complete ﬁle, by
<br>
putting the following code in the ﬁrst line:
<br>
'use strict';
<br>

<br>
The neat thing about this “directive” is that ECMAScript versions before 5 simply ignore
<br>
it: it’s an expression statement that does nothing.
<br>
You can also switch on strict mode for just a single function:
<br>
function functionInStrictMode() {
<br>
'use strict';
<br>
}
<br>

<br>
8.9.2 Improvements in strict mode
<br>
Let’s look at three things that strict mode does better than sloppy mode. Just in this one
<br>
section, all code fragments are executed in sloppy mode.
<br>

<br>
8.9.2.1 Sloppy mode pitfall: changing an undeclared variable creates a global variable
<br>
In non-strict mode, changing an undeclared variable creates a global variable.
<br>
function sloppyFunc() {
<br>
undeclaredVar1 = 123;
<br>
}
<br>
sloppyFunc();
<br>
// Created global variable `undeclaredVar1`:
<br>
assert.equal(undeclaredVar1, 123);
<br>

<br>
Strict mode does it better and throws a ReferenceError. That makes it easier to detect
<br>
typos.
<br>
function strictFunc() {
<br>
'use strict';
<br>
undeclaredVar2 = 123;
<br>
}
<br>
assert.throws(
<br>
() => strictFunc(),
<br>
{
<br>
name: 'ReferenceError',
<br>
message: 'undeclaredVar2 is not defined',
<br>
});
<br>

<br>
The assert.throws() states that its ﬁrst argument, a function, throws a ReferenceError
<br>
when it is called.
<br>

<br>
8.9 Strict mode vs. sloppy mode
<br>

<br>
55
<br>

<br>
8.9.2.2 Function declarations are block-scoped in strict mode, function-scoped in
<br>
sloppy mode
<br>
In strict mode, a variable created via a function declaration only exists within the innermost enclosing block:
<br>
function strictFunc() {
<br>
'use strict';
<br>
{
<br>
function foo() { return 123 }
<br>
}
<br>
return foo(); // ReferenceError
<br>
}
<br>
assert.throws(
<br>
() => strictFunc(),
<br>
{
<br>
name: 'ReferenceError',
<br>
message: 'foo is not defined',
<br>
});
<br>

<br>
In sloppy mode, function declarations are function-scoped:
<br>
function sloppyFunc() {
<br>
{
<br>
function foo() { return 123 }
<br>
}
<br>
return foo(); // works
<br>
}
<br>
assert.equal(sloppyFunc(), 123);
<br>

<br>
8.9.2.3 Sloppy mode doesn’t throw exceptions when changing immutable data
<br>
In strict mode, you get an exception if you try to change immutable data:
<br>
function strictFunc() {
<br>
'use strict';
<br>
true.prop = 1; // TypeError
<br>
}
<br>
assert.throws(
<br>
() => strictFunc(),
<br>
{
<br>
name: 'TypeError',
<br>
message: "Cannot create property 'prop' on boolean 'true'",
<br>
});
<br>

<br>
In sloppy mode, the assignment fails silently:
<br>
function sloppyFunc() {
<br>
true.prop = 1; // fails silently
<br>
return true.prop;
<br>
}
<br>
assert.equal(sloppyFunc(), undefined);
<br>

<br>
56
<br>

<br>
8 Syntax
<br>

<br>
Further reading: sloppy mode
<br>
For more information on how sloppy mode differs from strict mode, see MDN.
<br>

<br>
Quiz: advanced
<br>
See quiz app.
<br>

<br>
Chapter 9
<br>

<br>
Consoles: interactive JavaScript
<br>
command lines
<br>
Contents
<br>
9.1
<br>

<br>
9.2
<br>

<br>
Trying out JavaScript code . . . . . . . . . . . . . . . . . . .
<br>
9.1.1 Browser consoles . . . . . . . . . . . . . . . . . . . .
<br>
9.1.2 The Node.js REPL . . . . . . . . . . . . . . . . . . . .
<br>
9.1.3 Other options . . . . . . . . . . . . . . . . . . . . . .
<br>
The console.* API: printing data and more . . . . . . . . .
<br>
9.2.1 Printing values: console.log() (stdout) . . . . . . .
<br>
9.2.2 Printing error information: console.error() (stderr)
<br>
9.2.3 Printing nested objects via JSON.stringify() . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
57
<br>
57
<br>
59
<br>
59
<br>
59
<br>
60
<br>
61
<br>
61
<br>

<br>
9.1 Trying out JavaScript code
<br>
You have many options for quickly running pieces of JavaScript code. The following
<br>
subsections describe a few of them.
<br>

<br>
9.1.1 Browser consoles
<br>
Web browsers have so-called consoles: interactive command lines to which you can print
<br>
text via console.log() and where you can run pieces of code. How to open the console
<br>
differs from browser to browser. Fig. 9.1 shows the console of Google Chrome.
<br>
To ﬁnd out how to open the console in your web browser, you can do a web search
<br>
for “console «name-of-your-browser»”. These are pages for a few commonly used web
<br>
browsers:
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Apple Safari
<br>
Google Chrome
<br>
Microsoft Edge
<br>
Mozilla Firefox
<br>
57
<br>

<br>
58
<br>

<br>
9 Consoles: interactive JavaScript command lines
<br>

<br>
Figure 9.1: The console of the web browser “Google Chrome” is open (in the bottom half
<br>
of window) while visiting a web page.
<br>

<br>
9.2 The console.* API: printing data and more
<br>

<br>
59
<br>

<br>
9.1.2 The Node.js REPL
<br>
REPL stands for read-eval-print loop and basically means command line. To use it, you must
<br>
ﬁrst start Node.js from an operating system command line, via the command node. Then
<br>
an interaction with it looks as depicted in ﬁg. 9.2: The text after > is input from the user;
<br>
everything else is output from Node.js.
<br>

<br>
Figure 9.2: Starting and using the Node.js REPL (interactive command line).
<br>

<br>
Reading: REPL interactions
<br>
I occasionally demonstrate JavaScript via REPL interactions. Then I also use greaterthan symbols (>) to mark input – for example:
<br>
> 3 + 5
<br>
8
<br>

<br>
9.1.3 Other options
<br>
Other options include:
<br>
• There are many web apps that let you experiment with JavaScript in web browsers
<br>
– for example, Babel’s REPL.
<br>
• There are also native apps and IDE plugins for running JavaScript.
<br>

<br>
Consoles often run in non-strict mode
<br>
In modern JavaScript, most code (e.g., modules) is executed in strict mode. However, consoles often run in non-strict mode. Therefore, you may occasionally get
<br>
slightly different results when using a console to execute code from this book.
<br>

<br>
9.2 The console.* API: printing data and more
<br>
In browsers, the console is something you can bring up that is normally hidden. For
<br>
Node.js, the console is the terminal that Node.js is currently running in.
<br>

<br>
60
<br>

<br>
9 Consoles: interactive JavaScript command lines
<br>

<br>
The full console.* API is documented on MDN web docs and on the Node.js website. It
<br>
is not part of the JavaScript language standard, but much functionality is supported by
<br>
both browsers and Node.js.
<br>
In this chapter, we only look at the following two methods for printing data (“printing”
<br>
means displaying in the console):
<br>
• console.log()
<br>
• console.error()
<br>

<br>
9.2.1 Printing values: console.log() (stdout)
<br>
There are two variants of this operation:
<br>
console.log(...values: any[]): void
<br>
console.log(pattern: string, ...values: any[]): void
<br>

<br>
9.2.1.1 Printing multiple values
<br>
The ﬁrst variant prints (text representations of) values on the console:
<br>
console.log('abc', 123, true);
<br>
// Output:
<br>
// abc 123 true
<br>

<br>
At the end, console.log() always prints a newline. Therefore, if you call it with zero
<br>
arguments, it just prints a newline.
<br>
9.2.1.2 Printing a string with substitutions
<br>
The second variant performs string substitution:
<br>
console.log('Test: %s %j', 123, 'abc');
<br>
// Output:
<br>
// Test: 123 "abc"
<br>

<br>
These are some of the directives you can use for substitutions:
<br>
• %s converts the corresponding value to a string and inserts it.
<br>
console.log('%s %s', 'abc', 123);
<br>
// Output:
<br>
// abc 123
<br>

<br>
• %o inserts a string representation of an object.
<br>
console.log('%o', {foo: 123, bar: 'abc'});
<br>
// Output:
<br>
// { foo: 123, bar: 'abc' }
<br>

<br>
• %j converts a value to a JSON string and inserts it.
<br>
console.log('%j', {foo: 123, bar: 'abc'});
<br>
// Output:
<br>
// {"foo":123,"bar":"abc"}
<br>

<br>
9.2 The console.* API: printing data and more
<br>

<br>
61
<br>

<br>
• %% inserts a single %.
<br>
console.log('%s%%', 99);
<br>
// Output:
<br>
// 99%
<br>

<br>
9.2.2 Printing error information: console.error() (stderr)
<br>
console.error() works the same as console.log(), but what it logs is considered error
<br>
information. For Node.js, that means that the output goes to stderr instead of stdout on
<br>
Unix.
<br>

<br>
9.2.3 Printing nested objects via JSON.stringify()
<br>
JSON.stringify() is occasionally useful for printing nested objects:
<br>
console.log(JSON.stringify({first: 'Jane', last: 'Doe'}, null, 2));
<br>

<br>
Output:
<br>
{
<br>
"first": "Jane",
<br>
"last": "Doe"
<br>
}
<br>

<br>
62
<br>

<br>
9 Consoles: interactive JavaScript command lines
<br>

<br>
Chapter 10
<br>

<br>
Assertion API
<br>
Contents
<br>
10.1 Assertions in software development . . . . . . . . . . . . . . . . . .
<br>

<br>
63
<br>

<br>
10.2 How assertions are used in this book . . . . . . . . . . . . . . . . . .
<br>

<br>
63
<br>

<br>
10.2.1 Documenting results in code examples via assertions . . . . .
<br>

<br>
64
<br>

<br>
10.2.2 Implementing test-driven exercises via assertions . . . . . . .
<br>

<br>
64
<br>

<br>
10.3 Normal comparison vs. deep comparison . . . . . . . . . . . . . . .
<br>

<br>
64
<br>

<br>
10.4 Quick reference: module assert . . . . . . . . . . . . . . . . . . . .
<br>

<br>
65
<br>

<br>
10.4.1 Normal equality . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
65
<br>

<br>
10.4.2 Deep equality . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
65
<br>

<br>
10.4.3 Expecting exceptions . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
65
<br>

<br>
10.4.4 Another tool function . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
66
<br>

<br>
10.1 Assertions in software development
<br>
In software development, assertions state facts about values or pieces of code that must
<br>
be true. If they aren’t, an exception is thrown. Node.js supports assertions via its built-in
<br>
module assert – for example:
<br>
import {strict as assert} from 'assert';
<br>
assert.equal(3 + 5, 8);
<br>

<br>
This assertion states that the expected result of 3 plus 5 is 8. The import statement uses
<br>
the recommended strict version of assert.
<br>

<br>
10.2 How assertions are used in this book
<br>
In this book, assertions are used in two ways: to document results in code examples and
<br>
to implement test-driven exercises.
<br>
63
<br>

<br>
64
<br>

<br>
10 Assertion API
<br>

<br>
10.2.1 Documenting results in code examples via assertions
<br>
In code examples, assertions express expected results. Take, for example, the following
<br>
function:
<br>
function id(x) {
<br>
return x;
<br>
}
<br>
id() returns its parameter. We can show it in action via an assertion:
<br>
assert.equal(id('abc'), 'abc');
<br>

<br>
In the examples, I usually omit the statement for importing assert.
<br>
The motivation behind using assertions is:
<br>
• You can specify precisely what is expected.
<br>
• Code examples can be tested automatically, which ensures that they really work.
<br>

<br>
10.2.2 Implementing test-driven exercises via assertions
<br>
The exercises for this book are test-driven, via the test framework AVA. Checks inside the
<br>
tests are made via methods of assert.
<br>
The following is an example of such a test:
<br>
// For the exercise, you must implement the function hello().
<br>
// The test checks if you have done it properly.
<br>
test('First exercise', t => {
<br>
assert.equal(hello('world'), 'Hello world!');
<br>
assert.equal(hello('Jane'), 'Hello Jane!');
<br>
assert.equal(hello('John'), 'Hello John!');
<br>
assert.equal(hello(''), 'Hello !');
<br>
});
<br>

<br>
For more information, consult §11 “Getting started with quizzes and exercises”.
<br>

<br>
10.3 Normal comparison vs. deep comparison
<br>
The strict equal() uses === to compare values. Therefore, an object is only equal to itself
<br>
– even if another object has the same content (because === does not compare the contents
<br>
of objects, only their identities):
<br>
assert.notEqual({foo: 1}, {foo: 1});
<br>
deepEqual() is a better choice for comparing objects:
<br>
assert.deepEqual({foo: 1}, {foo: 1});
<br>

<br>
This method works for Arrays, too:
<br>
assert.notEqual(['a', 'b', 'c'], ['a', 'b', 'c']);
<br>
assert.deepEqual(['a', 'b', 'c'], ['a', 'b', 'c']);
<br>

<br>
10.4 Quick reference: module assert
<br>

<br>
65
<br>

<br>
10.4 Quick reference: module assert
<br>
For the full documentation, see the Node.js docs.
<br>

<br>
10.4.1 Normal equality
<br>
• function equal(actual: any, expected: any, message?: string): void
<br>
actual === expected must be true. If not, an AssertionError is thrown.
<br>
assert.equal(3+3, 6);
<br>

<br>
• function notEqual(actual: any, expected: any, message?: string): void
<br>
actual !== expected must be true. If not, an AssertionError is thrown.
<br>
assert.notEqual(3+3, 22);
<br>

<br>
The optional last parameter message can be used to explain what is asserted. If the assertion fails, the message is used to set up the AssertionError that is thrown.
<br>
let e;
<br>
try {
<br>
const x = 3;
<br>
assert.equal(x, 8, 'x must be equal to 8')
<br>
} catch (err) {
<br>
assert.equal(
<br>
String(err),
<br>
'AssertionError [ERR_ASSERTION]: x must be equal to 8');
<br>
}
<br>

<br>
10.4.2 Deep equality
<br>
• function deepEqual(actual: any, expected: any, message?: string): void
<br>
actual must be deeply equal to expected. If not, an AssertionError is thrown.
<br>
assert.deepEqual([1,2,3], [1,2,3]);
<br>
assert.deepEqual([], []);
<br>
// To .equal(), an object is only equal to itself:
<br>
assert.notEqual([], []);
<br>

<br>
• function notDeepEqual(actual: any, expected: any, message?: string):
<br>
void
<br>
actual must not be deeply equal to expected. If it is, an AssertionError is thrown.
<br>
assert.notDeepEqual([1,2,3], [1,2]);
<br>

<br>
10.4.3 Expecting exceptions
<br>
If you want to (or expect to) receive an exception, you need throws(): This function
<br>
calls its ﬁrst parameter, the function block, and only succeeds if it throws an exception.
<br>
Additional parameters can be used to specify what that exception must look like.
<br>

<br>
66
<br>

<br>
10 Assertion API
<br>

<br>
• function throws(block: Function, message?: string): void
<br>
assert.throws(
<br>
() => {
<br>
null.prop;
<br>
}
<br>
);
<br>

<br>
• function throws(block: Function, error: Function, message?: string):
<br>
void
<br>
assert.throws(
<br>
() => {
<br>
null.prop;
<br>
},
<br>
TypeError
<br>
);
<br>

<br>
• function throws(block: Function, error: RegExp, message?: string): void
<br>
assert.throws(
<br>
() => {
<br>
null.prop;
<br>
},
<br>
/^TypeError: Cannot read property 'prop' of null$/
<br>
);
<br>

<br>
• function throws(block: Function, error: Object, message?: string): void
<br>
assert.throws(
<br>
() => {
<br>
null.prop;
<br>
},
<br>
{
<br>
name: 'TypeError',
<br>
message: `Cannot read property 'prop' of null`,
<br>
}
<br>
);
<br>

<br>
10.4.4 Another tool function
<br>
• function fail(message: string | Error): never
<br>
Always throws an AssertionError when it is called. That is occasionally useful
<br>
for unit testing.
<br>
try {
<br>
functionThatShouldThrow();
<br>
assert.fail();
<br>
} catch (_) {
<br>
// Success
<br>
}
<br>

<br>
10.4 Quick reference: module assert
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
67
<br>

<br>
68
<br>

<br>
10 Assertion API
<br>

<br>
Chapter 11
<br>

<br>
Getting started with quizzes and
<br>
exercises
<br>
Contents
<br>
11.1 Quizzes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
69
<br>

<br>
11.2 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
69
<br>

<br>
11.2.1 Installing the exercises . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
69
<br>

<br>
11.2.2 Running exercises . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
70
<br>

<br>
11.3 Unit tests in JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
70
<br>

<br>
11.3.1 A typical test . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
70
<br>

<br>
11.3.2 Asynchronous tests in AVA . . . . . . . . . . . . . . . . . . . .
<br>

<br>
71
<br>

<br>
Throughout most chapters, there are quizzes and exercises. These are a paid feature, but a
<br>
comprehensive preview is available. This chapter explains how to get started with them.
<br>

<br>
11.1 Quizzes
<br>
Installation:
<br>
• Download and unzip impatient-js-quiz.zip
<br>
Running the quiz app:
<br>
• Open impatient-js-quiz/index.html in a web browser
<br>
• You’ll see a TOC of all the quizzes.
<br>

<br>
11.2 Exercises
<br>
11.2.1 Installing the exercises
<br>
To install the exercises:
<br>
69
<br>

<br>
70
<br>

<br>
11 Getting started with quizzes and exercises
<br>

<br>
• Download and unzip impatient-js-code.zip
<br>
• Follow the instructions in README.txt
<br>

<br>
11.2.2 Running exercises
<br>
• Exercises are referred to by path in this book.
<br>
– For example: exercises/quizzes-exercises/first_module_test.mjs
<br>
• Within each ﬁle:
<br>
– The ﬁrst line contains the command for running the exercise.
<br>
– The following lines describe what you have to do.
<br>

<br>
11.3 Unit tests in JavaScript
<br>
All exercises in this book are tests that are run via the test framework AVA. This section
<br>
gives a brief introduction.
<br>

<br>
11.3.1 A typical test
<br>
Typical test code is split into two parts:
<br>
• Part 1: the code to be tested.
<br>
• Part 2: the tests for the code.
<br>
Take, for example, the following two ﬁles:
<br>
• id.mjs (code to be tested)
<br>
• id_test.mjs (tests)
<br>
11.3.1.1 Part 1: the code
<br>
The code itself resides in id.mjs:
<br>
export function id(x) {
<br>
return x;
<br>
}
<br>

<br>
The key thing here is: everything you want to test must be exported. Otherwise, the test
<br>
code can’t access it.
<br>
11.3.1.2 Part 2: the tests
<br>
Don’t worry about the exact details of tests
<br>
You don’t need to worry about the exact details of tests: They are always implemented for you. Therefore, you only need to read them, but not write them.
<br>
The tests for the code reside in id_test.mjs:
<br>
// npm t demos/quizzes-exercises/id_test.mjs
<br>
import test from 'ava'; // (A)
<br>

<br>
11.3 Unit tests in JavaScript
<br>

<br>
71
<br>

<br>
import {strict as assert} from 'assert'; // (B)
<br>
import {id} from './id.mjs'; // (C)
<br>
test('My test', t => { // (D)
<br>
assert.equal(id('abc'), 'abc'); // (E)
<br>
});
<br>

<br>
The core of this test ﬁle is line E – an assertion: assert.equal() speciﬁes that the expected
<br>
result of id('abc') is 'abc'.
<br>
As for the other lines:
<br>
• The comment at the very beginning shows the shell command for running the test.
<br>
• Line A: We import the test framework.
<br>
• Line B: We import the assertion library. AVA has built-in assertions, but module
<br>
assert lets us remain compatible with plain Node.js.
<br>
• Line C: We import the function to test.
<br>
• Line D: We deﬁne a test. This is done by calling the function test():
<br>
– First parameter: the name of the test.
<br>
– Second parameter: the test code, which is provided via an arrow function.
<br>
The parameter t gives us access to AVA’s testing API (assertions, etc.).
<br>
To run the test, we execute the following in a command line:
<br>
npm t demos/quizzes-exercises/id_test.mjs
<br>

<br>
The t is an abbreviation for test. That is, the long version of this command is:
<br>
npm test demos/quizzes-exercises/id_test.mjs
<br>

<br>
Exercise: Your ﬁrst exercise
<br>
The following exercise gives you a ﬁrst taste of what exercises are like:
<br>
• exercises/quizzes-exercises/first_module_test.mjs
<br>

<br>
11.3.2 Asynchronous tests in AVA
<br>
Reading
<br>
You can postpone reading this section until you get to the chapters on asynchronous
<br>
programming.
<br>
Writing tests for asynchronous code requires extra work: The test receives its results later
<br>
and has to signal to AVA that it isn’t ﬁnished yet when it returns. The following subsections examine three ways of doing so.
<br>
11.3.2.1 Asynchronicity via callbacks
<br>
If we call test.cb() instead of test(), AVA switches to callback-based asynchronicity.
<br>
When we are done with our asynchronous work, we have to call t.end():
<br>

<br>
72
<br>

<br>
11 Getting started with quizzes and exercises
<br>
test.cb('divideCallback', t => {
<br>
divideCallback(8, 4, (error, result) => {
<br>
if (error) {
<br>
t.end(error);
<br>
} else {
<br>
assert.strictEqual(result, 2);
<br>
t.end();
<br>
}
<br>
});
<br>
});
<br>

<br>
11.3.2.2 Asynchronicity via Promises
<br>
If a test returns a Promise, AVA switches to Promise-based asynchronicity. A test is considered successful if the Promise is fulﬁlled and failed if the Promise is rejected.
<br>
test('dividePromise 1', t => {
<br>
return dividePromise(8, 4)
<br>
.then(result => {
<br>
assert.strictEqual(result, 2);
<br>
});
<br>
});
<br>

<br>
11.3.2.3 Async functions as test “bodies”
<br>
Async functions always return Promises. Therefore, an async function is a convenient
<br>
way of implementing an asynchronous test. The following code is equivalent to the previous example.
<br>
test('dividePromise 2', async t => {
<br>
const result = await dividePromise(8, 4);
<br>
assert.strictEqual(result, 2);
<br>
// No explicit return necessary!
<br>
});
<br>

<br>
You don’t need to explicitly return anything: The implicitly returned undefined is used
<br>
to fulﬁll the Promise returned by this async function. And if the test code throws an
<br>
exception, then the async function takes care of rejecting the returned Promise.
<br>

<br>
Part III
<br>

<br>
Variables and values
<br>

<br>
73
<br>

<br>
Chapter 12
<br>

<br>
Variables and assignment
<br>
Contents
<br>
12.1 let . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
76
<br>

<br>
12.2 const
<br>

<br>
76
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
12.2.1 const and immutability
<br>

<br>
. . . . . . . . . . . . . . . . . . . . .
<br>

<br>
76
<br>

<br>
12.2.2 const and loops . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
77
<br>

<br>
12.3 Deciding between const and let . . . . . . . . . . . . . . . . . . . .
<br>

<br>
77
<br>

<br>
12.4 The scope of a variable . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
77
<br>

<br>
12.4.1 Shadowing variables . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
78
<br>

<br>
12.5 (Advanced) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
79
<br>

<br>
12.6 Terminology: static vs. dynamic . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
79
<br>

<br>
12.6.1 Static phenomenon: scopes of variables . . . . . . . . . . . . .
<br>

<br>
79
<br>

<br>
12.6.2 Dynamic phenomenon: function calls . . . . . . . . . . . . . .
<br>

<br>
79
<br>

<br>
12.7 Global variables and the global object . . . . . . . . . . . . . . . . .
<br>

<br>
80
<br>

<br>
12.7.1 globalThis . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
80
<br>

<br>
12.8 Declarations: scope and activation . . . . . . . . . . . . . . . . . . .
<br>

<br>
82
<br>

<br>
12.8.1 const and let: temporal dead zone . . . . . . . . . . . . . . .
<br>

<br>
82
<br>

<br>
12.8.2 Function declarations and early activation . . . . . . . . . . .
<br>

<br>
84
<br>

<br>
12.8.3 Class declarations are not activated early . . . . . . . . . . . .
<br>

<br>
85
<br>

<br>
12.8.4 var: hoisting (partial early activation) . . . . . . . . . . . . . .
<br>

<br>
85
<br>

<br>
12.9 Closures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
86
<br>

<br>
12.9.1 Bound variables vs. free variables . . . . . . . . . . . . . . . .
<br>

<br>
86
<br>

<br>
12.9.2 What is a closure? . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
86
<br>

<br>
12.9.3 Example: A factory for incrementors . . . . . . . . . . . . . .
<br>

<br>
87
<br>

<br>
12.9.4 Use cases for closures . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
88
<br>

<br>
12.10Further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
88
<br>

<br>
These are JavaScript’s main ways of declaring variables:
<br>
• let declares mutable variables.
<br>
• const declares constants (immutable variables).
<br>
75
<br>

<br>
76
<br>

<br>
12 Variables and assignment
<br>

<br>
Before ES6, there was also var. But it has several quirks, so it’s best to avoid it in modern
<br>
JavaScript. You can read more about it in Speaking JavaScript.
<br>

<br>
12.1
<br>

<br>
let
<br>

<br>
Variables declared via let are mutable:
<br>
let i;
<br>
i = 0;
<br>
i = i + 1;
<br>
assert.equal(i, 1);
<br>

<br>
You can also declare and assign at the same time:
<br>
let i = 0;
<br>

<br>
12.2
<br>

<br>
const
<br>

<br>
Variables declared via const are immutable. You must always initialize immediately:
<br>
const i = 0; // must initialize
<br>
assert.throws(
<br>
() => { i = i + 1 },
<br>
{
<br>
name: 'TypeError',
<br>
message: 'Assignment to constant variable.',
<br>
}
<br>
);
<br>

<br>
12.2.1
<br>

<br>
const and immutability
<br>

<br>
In JavaScript, const only means that the binding (the association between variable name
<br>
and variable value) is immutable. The value itself may be mutable, like obj in the following example.
<br>
const obj = { prop: 0 };
<br>
// Allowed: changing properties of `obj`
<br>
obj.prop = obj.prop + 1;
<br>
assert.equal(obj.prop, 1);
<br>
// Not allowed: assigning to `obj`
<br>
assert.throws(
<br>
() => { obj = {} },
<br>
{
<br>
name: 'TypeError',
<br>
message: 'Assignment to constant variable.',
<br>
}
<br>
);
<br>

<br>
12.3 Deciding between const and let
<br>

<br>
12.2.2
<br>

<br>
77
<br>

<br>
const and loops
<br>

<br>
You can use const with for-of loops, where a fresh binding is created for each iteration:
<br>
const arr = ['hello', 'world'];
<br>
for (const elem of arr) {
<br>
console.log(elem);
<br>
}
<br>
// Output:
<br>
// 'hello'
<br>
// 'world'
<br>

<br>
In plain for loops, you must use let, however:
<br>
const arr = ['hello', 'world'];
<br>
for (let i=0; i<arr.length; i++) {
<br>
const elem = arr[i];
<br>
console.log(elem);
<br>
}
<br>

<br>
12.3 Deciding between const and let
<br>
I recommend the following rules to decide between const and let:
<br>
• const indicates an immutable binding and that a variable never changes its value.
<br>
Prefer it.
<br>
• let indicates that the value of a variable changes. Use it only when you can’t use
<br>
const.
<br>

<br>
Exercise: const
<br>
exercises/variables-assignment/const_exrc.mjs
<br>

<br>
12.4 The scope of a variable
<br>
The scope of a variable is the region of a program where it can be accessed. Consider the
<br>
following code.
<br>
{ // // Scope A. Accessible: x
<br>
const x = 0;
<br>
assert.equal(x, 0);
<br>
{ // Scope B. Accessible: x, y
<br>
const y = 1;
<br>
assert.equal(x, 0);
<br>
assert.equal(y, 1);
<br>
{ // Scope C. Accessible: x, y, z
<br>
const z = 2;
<br>
assert.equal(x, 0);
<br>
assert.equal(y, 1);
<br>

<br>
78
<br>

<br>
12 Variables and assignment
<br>
assert.equal(z, 2);
<br>
}
<br>
}
<br>
}
<br>
// Outside. Not accessible: x, y, z
<br>
assert.throws(
<br>
() => console.log(x),
<br>
{
<br>
name: 'ReferenceError',
<br>
message: 'x is not defined',
<br>
}
<br>
);
<br>

<br>
• Scope A is the (direct) scope of x.
<br>
• Scopes B and C are inner scopes of scope A.
<br>
• Scope A is an outer scope of scope B and scope C.
<br>
Each variable is accessible in its direct scope and all scopes nested within that scope.
<br>
The variables declared via const and let are called block-scoped because their scopes are
<br>
always the innermost surrounding blocks.
<br>

<br>
12.4.1 Shadowing variables
<br>
You can’t declare the same variable twice at the same level:
<br>
assert.throws(
<br>
() => {
<br>
eval('let x = 1; let x = 2;');
<br>
},
<br>
{
<br>
name: 'SyntaxError',
<br>
message: "Identifier 'x' has already been declared",
<br>
});
<br>

<br>
Why eval()?
<br>
eval() delays parsing (and therefore the SyntaxError), until the callback of assert.throws() is executed. If we didn’t use it, we’d already get an error when this
<br>

<br>
code is parsed and assert.throws() wouldn’t even be executed.
<br>
You can, however, nest a block and use the same variable name x that you used outside
<br>
the block:
<br>
const x = 1;
<br>
assert.equal(x, 1);
<br>
{
<br>
const x = 2;
<br>
assert.equal(x, 2);
<br>

<br>
12.5 (Advanced)
<br>

<br>
79
<br>

<br>
}
<br>
assert.equal(x, 1);
<br>

<br>
Inside the block, the inner x is the only accessible variable with that name. The inner x is
<br>
said to shadow the outer x. Once you leave the block, you can access the old value again.
<br>

<br>
Quiz: basic
<br>
See quiz app.
<br>

<br>
12.5 (Advanced)
<br>
All remaining sections are advanced.
<br>

<br>
12.6 Terminology: static vs. dynamic
<br>
These two adjectives describe phenomena in programming languages:
<br>
• Static means that something is related to source code and can be determined without executing code.
<br>
• Dynamic means at runtime.
<br>
Let’s look at examples for these two terms.
<br>

<br>
12.6.1 Static phenomenon: scopes of variables
<br>
Variable scopes are a static phenomenon. Consider the following code:
<br>
function f() {
<br>
const x = 3;
<br>
// ···
<br>
}
<br>
x is statically (or lexically) scoped. That is, its scope is ﬁxed and doesn’t change at runtime.
<br>

<br>
Variable scopes form a static tree (via static nesting).
<br>

<br>
12.6.2 Dynamic phenomenon: function calls
<br>
Function calls are a dynamic phenomenon. Consider the following code:
<br>
function g(x) {}
<br>
function h(y) {
<br>
if (Math.random()) g(y); // (A)
<br>
}
<br>

<br>
Whether or not the function call in line A happens, can only be decided at runtime.
<br>
Function calls form a dynamic tree (via dynamic calls).
<br>

<br>
80
<br>

<br>
12 Variables and assignment
<br>

<br>
12.7 Global variables and the global object
<br>
JavaScript’s variable scopes are nested. They form a tree:
<br>
• The outermost scope is the root of the tree.
<br>
• The scopes directly contained in that scope are the children of the root.
<br>
• And so on.
<br>
The root is also called the global scope. In web browsers, the only location where one is
<br>
directly in that scope is at the top level of a script. The variables of the global scope are
<br>
called global variables and accessible everywhere. There are two kinds of global variables:
<br>
• Global declarative variables are normal variables.
<br>
– They can only be created while at the top level of a script, via const, ‘let, and
<br>
class declarations.
<br>
• Global object variables are stored in properties of the so-called global object.
<br>
– They are created in the top level of a script, via var and function declarations.
<br>
– The global object can be accessed via the global variable globalThis. It can
<br>
be used to create, read, and delete global object variables.
<br>
– Other than that, global object variables work like normal variables.
<br>
The following HTML fragment demonstrates globalThis and the two kinds of global
<br>
variables.
<br>
<script>
<br>
const declarativeVariable = 'd';
<br>
var objectVariable = 'o';
<br>
</script>
<br>
<script>
<br>
// All scripts share the same top-level scope:
<br>
console.log(declarativeVariable); // 'd'
<br>
console.log(objectVariable); // 'o'
<br>
// Not all declarations create properties of the global object:
<br>
console.log(globalThis.declarativeVariable); // undefined
<br>
console.log(globalThis.objectVariable); // 'o'
<br>
</script>
<br>

<br>
Each ECMAScript module has its own scope. Therefore, variables that exist at the top
<br>
level of a module are not global. Fig. 12.1 illustrates how the various scopes are related.
<br>

<br>
12.7.1
<br>

<br>
globalThis
<br>
globalThis is new
<br>

<br>
globalThis is a new feature. Be sure that the JavaScript engines you are targeting
<br>

<br>
support it. If they don’t, switch to one of the alternatives mentioned below.
<br>
The global variable globalThis is the new standard way of accessing the global object. It
<br>
got its name from the fact that it has the same value as this in global scope.
<br>

<br>
81
<br>

<br>
12.7 Global variables and the global object
<br>

<br>
Global scope
<br>
Top level of scripts:
<br>
Object variables
<br>

<br>
Declarative variables
<br>

<br>
Module scope 1
<br>

<br>
var, function declarations
<br>
const, let, class declarations
<br>

<br>
Module scope 2
<br>

<br>
···
<br>

<br>
Figure 12.1: The global scope is JavaScript’s outermost scope. It has two kinds of variables: object variables (managed via the global object) and normal declarative variables. Each
<br>
ECMAScript module has its own scope which is contained in the global scope.
<br>

<br>
globalThis does not always directly point to the global object
<br>

<br>
For example, in browsers, there is an indirection. That indirection is normally not
<br>
noticable, but it is there and can be observed.
<br>
12.7.1.1 Alternatives to globalThis
<br>
Older ways of accessing the global object depend on the platform:
<br>
• Global variable window: is the classic way of referring to the global object. But it
<br>
doesn’t work in Node.js and in Web Workers.
<br>
• Global variable self: is available in Web Workers and browsers in general. But it
<br>
isn’t supported by Node.js.
<br>
• Global variable global: is only available in Node.js.
<br>
12.7.1.2 Use cases for globalThis
<br>
The global object is now considered a mistake that JavaScript can’t get rid of, due to
<br>
backward compatibility. It affects performance negatively and is generally confusing.
<br>
ECMAScript 6 introduced several features that make it easier to avoid the global object –
<br>
for example:
<br>
• const, let, and class declarations don’t create global object properties when used
<br>
in global scope.
<br>
• Each ECMAScript module has its own local scope.
<br>
It is usually better to access global object variables via variables and not via properties of
<br>
globalThis. The former has always worked the same on all JavaScript platforms.
<br>

<br>
82
<br>

<br>
12 Variables and assignment
<br>

<br>
Tutorials on the web occasionally access global variables globVar via window.globVar.
<br>
But the preﬁx “window.” is not necessary and I recommend to omit it:
<br>
window.encodeURIComponent(str); // no
<br>
encodeURIComponent(str); // yes
<br>

<br>
Therefore, there are relatively few use cases for globalThis – for example:
<br>
• Polyﬁlls that add new features to old JavaScript engines.
<br>
• Feature detection, to ﬁnd out what features a JavaScript engine supports.
<br>

<br>
12.8 Declarations: scope and activation
<br>
These are two key aspects of declarations:
<br>
• Scope: Where can a declared entity be seen? This is a static trait.
<br>
• Activation: When can I access an entity? This is a dynamic trait. Some entities
<br>
can be accessed as soon as we enter their scopes. For others, we have to wait until
<br>
execution reaches their declarations.
<br>
Tbl. 12.1 summarizes how various declarations handle these aspects.
<br>
Table 12.1: Aspects of declarations. “Duplicates” describes if a declaration can be used twice with the same same (per scope). “Global prop.”
<br>
describes if a declaration adds a property to the global object, when it is
<br>
executed in the global scope of a script. TDZ means temporal dead zone
<br>
(which is explained later). (*) Function declarations are normally blockscoped, but function-scoped in sloppy mode.
<br>

<br>
const
<br>
let
<br>
function
<br>
class
<br>
import
<br>
var
<br>

<br>
Scope
<br>

<br>
Activation
<br>

<br>
Duplicates
<br>

<br>
Global prop.
<br>

<br>
Block
<br>
Block
<br>
Block (*)
<br>
Block
<br>
Module
<br>
Function
<br>

<br>
decl. (TDZ)
<br>
decl. (TDZ)
<br>
start
<br>
decl. (TDZ)
<br>
same as export
<br>
start, partially
<br>

<br>
✘
<br>

<br>
✘
<br>

<br>
✘
<br>

<br>
✘
<br>

<br>
✔
<br>

<br>
✔
<br>

<br>
✘
<br>

<br>
✘
<br>

<br>
✘
<br>

<br>
✘
<br>

<br>
✔
<br>

<br>
✔
<br>

<br>
import is described in §27.5 “ECMAScript modules”. The following sections describe the
<br>

<br>
other constructs in more detail.
<br>

<br>
12.8.1
<br>

<br>
const and let: temporal dead zone
<br>

<br>
For JavaScript, TC39 needed to decide what happens if you access a constant in its direct
<br>
scope, before its declaration:
<br>
{
<br>
console.log(x); // What happens here?
<br>
const x;
<br>
}
<br>

<br>
12.8 Declarations: scope and activation
<br>

<br>
83
<br>

<br>
Some possible approaches are:
<br>
1. The name is resolved in the scope surrounding the current scope.
<br>
2. You get undefined.
<br>
3. There is an error.
<br>
Approach 1 was rejected because there is no precedent in the language for this approach.
<br>
It would therefore not be intuitive to JavaScript programmers.
<br>
Approach 2 was rejected because then x wouldn’t be a constant – it would have different
<br>
values before and after its declaration.
<br>
let uses the same approach 3 as const, so that both work similarly and it’s easy to switch
<br>

<br>
between them.
<br>
The time between entering the scope of a variable and executing its declaration is called
<br>
the temporal dead zone (TDZ) of that variable:
<br>
• During this time, the variable is considered to be uninitialized (as if that were a
<br>
special value it has).
<br>
• If you access an uninitialized variable, you get a ReferenceError.
<br>
• Once you reach a variable declaration, the variable is set to either the value of the
<br>
initializer (speciﬁed via the assignment symbol) or undefined – if there is no initializer.
<br>
The following code illustrates the temporal dead zone:
<br>
if (true) { // entering scope of `tmp`, TDZ starts
<br>
// `tmp` is uninitialized:
<br>
assert.throws(() => (tmp = 'abc'), ReferenceError);
<br>
assert.throws(() => console.log(tmp), ReferenceError);
<br>
let tmp; // TDZ ends
<br>
assert.equal(tmp, undefined);
<br>
}
<br>

<br>
The next example shows that the temporal dead zone is truly temporal (related to time):
<br>
if (true) { // entering scope of `myVar`, TDZ starts
<br>
const func = () => {
<br>
console.log(myVar); // executed later
<br>
};
<br>
// We are within the TDZ:
<br>
// Accessing `myVar` causes `ReferenceError`
<br>
let myVar = 3; // TDZ ends
<br>
func(); // OK, called outside TDZ
<br>
}
<br>

<br>
Even though func() is located before the declaration of myVar and uses that variable, we
<br>
can call func(). But we have to wait until the temporal dead zone of myVar is over.
<br>

<br>
84
<br>

<br>
12 Variables and assignment
<br>

<br>
12.8.2 Function declarations and early activation
<br>
More information on functions
<br>
In this section, we are using functions – before we had a chance to learn them properly. Hopefully, everything still makes sense. Whenever it doesn’t, please see §25
<br>
“Callable values”.
<br>
A function declaration is always executed when entering its scope, regardless of where it
<br>
is located within that scope. That enables you to call a function foo() before it is declared:
<br>
assert.equal(foo(), 123); // OK
<br>
function foo() { return 123; }
<br>

<br>
The early activation of foo() means that the previous code is equivalent to:
<br>
function foo() { return 123; }
<br>
assert.equal(foo(), 123);
<br>

<br>
If you declare a function via const or let, then it is not activated early. In the following
<br>
example, you can only use bar() after its declaration.
<br>
assert.throws(
<br>
() => bar(), // before declaration
<br>
ReferenceError);
<br>
const bar = () => { return 123; };
<br>
assert.equal(bar(), 123); // after declaration
<br>

<br>
12.8.2.1 Calling ahead without early activation
<br>
Even if a function g() is not activated early, it can be called by a preceding function f()
<br>
(in the same scope) if we adhere to the following rule: f() must be invoked after the
<br>
declaration of g().
<br>
const f = () => g();
<br>
const g = () => 123;
<br>
// We call f() after g() was declared:
<br>
assert.equal(f(), 123);
<br>

<br>
The functions of a module are usually invoked after its complete body is executed. Therefore, in modules, you rarely need to worry about the order of functions.
<br>
Lastly, note how early activation automatically keeps the aforementioned rule: when
<br>
entering a scope, all function declarations are executed ﬁrst, before any calls are made.
<br>
12.8.2.2 A pitfall of early activation
<br>
If you rely on early activation to call a function before its declaration, then you need to
<br>
be careful that it doesn’t access data that isn’t activated early.
<br>

<br>
12.8 Declarations: scope and activation
<br>

<br>
85
<br>

<br>
funcDecl();
<br>
const MY_STR = 'abc';
<br>
function funcDecl() {
<br>
assert.throws(
<br>
() => MY_STR,
<br>
ReferenceError);
<br>
}
<br>

<br>
The problem goes away if you make the call to funcDecl() after the declaration of MY_STR.
<br>
12.8.2.3 The pros and cons of early activation
<br>
We have seen that early activation has a pitfall and that you can get most of its beneﬁts
<br>
without using it. Therefore, it is better to avoid early activation. But I don’t feel strongly
<br>
about this and, as mentioned before, often use function declarations because I like their
<br>
syntax.
<br>

<br>
12.8.3 Class declarations are not activated early
<br>
Even though they are similar to function declarations in some ways, class declarations
<br>
are not activated early:
<br>
assert.throws(
<br>
() => new MyClass(),
<br>
ReferenceError);
<br>
class MyClass {}
<br>
assert.equal(new MyClass() instanceof MyClass, true);
<br>

<br>
Why is that? Consider the following class declaration:
<br>
class MyClass extends Object {}
<br>

<br>
The operand of extends is an expression. Therefore, you can do things like this:
<br>
const identity = x => x;
<br>
class MyClass extends identity(Object) {}
<br>

<br>
Evaluating such an expression must be done at the location where it is mentioned. Anything else would be confusing. That explains why class declarations are not activated
<br>
early.
<br>

<br>
12.8.4
<br>

<br>
var: hoisting (partial early activation)
<br>

<br>
var is an older way of declaring variables that predates const and let (which are pre-
<br>

<br>
ferred now). Consider the following var declaration.
<br>
var x = 123;
<br>

<br>
This declaration has two parts:
<br>

<br>
86
<br>

<br>
12 Variables and assignment
<br>

<br>
• Declaration var x: The scope of a var-declared variable is the innermost surrounding function and not the innermost surrounding block, as for most other declarations. Such a variable is already active at the beginning of its scope and initialized
<br>
with undefined.
<br>
• Assignment x = 123: The assignment is always executed in place.
<br>
The following code demonstrates the effects of var:
<br>
function f() {
<br>
// Partial early activation:
<br>
assert.equal(x, undefined);
<br>
if (true) {
<br>
var x = 123;
<br>
// The assignment is executed in place:
<br>
assert.equal(x, 123);
<br>
}
<br>
// Scope is function, not block:
<br>
assert.equal(x, 123);
<br>
}
<br>

<br>
12.9 Closures
<br>
Before we can explore closures, we need to learn about bound variables and free variables.
<br>

<br>
12.9.1 Bound variables vs. free variables
<br>
Per scope, there is a set of variables that are mentioned. Among these variables we distinguish:
<br>
• Bound variables are declared within the scope. They are parameters and local variables.
<br>
• Free variables are declared externally. They are also called non-local variables.
<br>
Consider the following code:
<br>
function func(x) {
<br>
const y = 123;
<br>
console.log(z);
<br>
}
<br>

<br>
In the body of func(), x and y are bound variables. z is a free variable.
<br>

<br>
12.9.2 What is a closure?
<br>
What is a closure then?
<br>
A closure is a function plus a connection to the variables that exist at its “birth
<br>
place”.
<br>
What is the point of keeping this connection? It provides the values for the free variables
<br>
of the function – for example:
<br>

<br>
12.9 Closures
<br>

<br>
87
<br>

<br>
function funcFactory(value) {
<br>
return () => {
<br>
return value;
<br>
};
<br>
}
<br>
const func = funcFactory('abc');
<br>
assert.equal(func(), 'abc'); // (A)
<br>
funcFactory returns a closure that is assigned to func. Because func has the connection
<br>
to the variables at its birth place, it can still access the free variable value when it is called
<br>
in line A (even though it “escaped” its scope).
<br>

<br>
All functions in JavaScript are closures
<br>
Static scoping is supported via closures in JavaScript. Therefore, every function is
<br>
a closure.
<br>

<br>
12.9.3 Example: A factory for incrementors
<br>
The following function returns incrementors (a name that I just made up). An incrementor
<br>
is a function that internally stores a number. When it is called, it updates that number by
<br>
adding the argument to it and returns the new value.
<br>
function createInc(startValue) {
<br>
return (step) => { // (A)
<br>
startValue += step;
<br>
return startValue;
<br>
};
<br>
}
<br>
const inc = createInc(5);
<br>
assert.equal(inc(2), 7);
<br>

<br>
We can see that the function created in line A keeps its internal number in the free variable
<br>
startValue. This time, we don’t just read from the birth scope, we use it to store data
<br>
that we change and that persists across function calls.
<br>
We can create more storage slots in the birth scope, via local variables:
<br>
function createInc(startValue) {
<br>
let index = -1;
<br>
return (step) => {
<br>
startValue += step;
<br>
index++;
<br>
return [index, startValue];
<br>
};
<br>
}
<br>
const inc = createInc(5);
<br>
assert.deepEqual(inc(2), [0, 7]);
<br>
assert.deepEqual(inc(2), [1, 9]);
<br>

<br>
88
<br>

<br>
12 Variables and assignment
<br>
assert.deepEqual(inc(2), [2, 11]);
<br>

<br>
12.9.4 Use cases for closures
<br>
What are closures good for?
<br>
• For starters, they are simply an implementation of static scoping. As such, they
<br>
provide context data for callbacks.
<br>
• They can also be used by functions to store state that persists across function calls.
<br>
createInc() is an example of that.
<br>
• And they can provide private data for objects (produced via literals or classes). The
<br>
details of how that works are explained in Exploring ES6.
<br>

<br>
Quiz: advanced
<br>
See quiz app.
<br>

<br>
12.10 Further reading
<br>
For more information on how variables are handled under the hood (as described in the
<br>
ECMAScript speciﬁcation), consult §26.4 “Closures and environments”.
<br>

<br>
Chapter 13
<br>

<br>
Values
<br>
Contents
<br>
13.1 What’s a type? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
89
<br>

<br>
13.2 JavaScript’s type hierarchy
<br>

<br>
90
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
13.3 The types of the language speciﬁcation
<br>

<br>
. . . . . . . . . . . . . . . .
<br>

<br>
90
<br>

<br>
13.4 Primitive values vs. objects . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
91
<br>

<br>
13.4.1 Primitive values (short: primitives) . . . . . . . . . . . . . . .
<br>

<br>
91
<br>

<br>
13.4.2 Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
92
<br>

<br>
13.5 The operators typeof and instanceof: what’s the type of a value?
<br>

<br>
.
<br>

<br>
93
<br>

<br>
13.5.1 typeof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
94
<br>

<br>
13.5.2 instanceof . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
94
<br>

<br>
13.6 Classes and constructor functions . . . . . . . . . . . . . . . . . . . .
<br>

<br>
95
<br>

<br>
13.6.1 Constructor functions associated with primitive types . . . . .
<br>

<br>
95
<br>

<br>
13.7 Converting between types . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
96
<br>

<br>
13.7.1 Explicit conversion between types . . . . . . . . . . . . . . . .
<br>

<br>
96
<br>

<br>
13.7.2 Coercion (automatic conversion between types) . . . . . . . .
<br>

<br>
97
<br>

<br>
In this chapter, we’ll examine what kinds of values JavaScript has.
<br>

<br>
Supporting tool: ===
<br>
In this chapter, we’ll occasionally use the strict equality operator. a === b evaluates
<br>
to true if a and b are equal. What exactly that means is explained in §14.4.2 “Strict
<br>
equality (=== and !==)”.
<br>

<br>
13.1 What’s a type?
<br>
For this chapter, I consider types to be sets of values – for example, the type boolean is
<br>
the set { false, true }.
<br>
89
<br>

<br>
90
<br>

<br>
13 Values
<br>

<br>
13.2 JavaScript’s type hierarchy
<br>
(any)
<br>

<br>
(primitive value)
<br>

<br>
(object)
<br>

<br>
undefined
<br>

<br>
boolean
<br>

<br>
null
<br>

<br>
number
<br>

<br>
Object
<br>

<br>
Array
<br>

<br>
Function
<br>

<br>
Map
<br>

<br>
RegExp
<br>

<br>
Set
<br>

<br>
Date
<br>

<br>
string
<br>
symbol
<br>

<br>
Figure 13.1: A partial hierarchy of JavaScript’s types. Missing are the classes for errors,
<br>
the classes associated with primitive types, and more. The diagram hints at the fact that
<br>
not all objects are instances of Object.
<br>
Fig. 13.1 shows JavaScript’s type hierarchy. What do we learn from that diagram?
<br>
• JavaScript distinguishes two kinds of values: primitive values and objects. We’ll
<br>
see soon what the difference is.
<br>
• The diagram differentiates objects and instances of class Object. Each instance
<br>
of Object is also an object, but not vice versa. However, virtually all objects that
<br>
you’ll encounter in practice are instances of Object – for example, objects created
<br>
via object literals. More details on this topic are explained in §29.4.3.4 “Objects that
<br>
aren’t instances of Object”.
<br>

<br>
13.3 The types of the language speciﬁcation
<br>
The ECMAScript speciﬁcation only knows a total of seven types. The names of those
<br>
types are (I’m using TypeScript’s names, not the spec’s names):
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
undefined with the only element undefined
<br>
null with the only element null
<br>
boolean with the elements false and true
<br>
number the type of all numbers (e.g., -123, 3.141)
<br>
string the type of all strings (e.g., 'abc')
<br>
symbol the type of all symbols (e.g., Symbol('My Symbol'))
<br>
object the type of all objects (different from Object, the type of all instances of
<br>

<br>
class Object and its subclasses)
<br>

<br>
13.4 Primitive values vs. objects
<br>

<br>
91
<br>

<br>
13.4 Primitive values vs. objects
<br>
The speciﬁcation makes an important distinction between values:
<br>
• Primitive values are the elements of the types undefined, null, boolean, number,
<br>
string, symbol.
<br>
• All other values are objects.
<br>
In contrast to Java (that inspired JavaScript here), primitive values are not second-class
<br>
citizens. The difference between them and objects is more subtle. In a nutshell:
<br>
• Primitive values: are atomic building blocks of data in JavaScript.
<br>
– They are passed by value: when primitive values are assigned to variables or
<br>
passed to functions, their contents are copied.
<br>
– They are compared by value: when comparing two primitive values, their contents are compared.
<br>
• Objects: are compound pieces of data.
<br>
– They are passed by identity (my term): when objects are assigned to variables
<br>
or passed to functions, their identities (think pointers) are copied.
<br>
– They are compared by identity (my term): when comparing two objects, their
<br>
identities are compared.
<br>
Other than that, primitive values and objects are quite similar: they both have properties
<br>
(key-value entries) and can be used in the same locations.
<br>
Next, we’ll look at primitive values and objects in more depth.
<br>

<br>
13.4.1 Primitive values (short: primitives)
<br>
13.4.1.1 Primitives are immutable
<br>
You can’t change, add, or remove properties of primitives:
<br>
let str = 'abc';
<br>
assert.equal(str.length, 3);
<br>
assert.throws(
<br>
() => { str.length = 1 },
<br>
/^TypeError: Cannot assign to read only property 'length'/
<br>
);
<br>

<br>
13.4.1.2 Primitives are passed by value
<br>
Primitives are passed by value: variables (including parameters) store the contents of the
<br>
primitives. When assigning a primitive value to a variable or passing it as an argument
<br>
to a function, its content is copied.
<br>
let x = 123;
<br>
let y = x;
<br>
assert.equal(y, 123);
<br>

<br>
92
<br>

<br>
13 Values
<br>

<br>
13.4.1.3 Primitives are compared by value
<br>
Primitives are compared by value: when comparing two primitive values, we compare their
<br>
contents.
<br>
assert.equal(123 === 123, true);
<br>
assert.equal('abc' === 'abc', true);
<br>

<br>
To see what’s so special about this way of comparing, read on and ﬁnd out how objects
<br>
are compared.
<br>

<br>
13.4.2 Objects
<br>
Objects are covered in detail in §28 “Single objects” and the following chapter. Here, we
<br>
mainly focus on how they differ from primitive values.
<br>
Let’s ﬁrst explore two common ways of creating objects:
<br>
• Object literal:
<br>
const obj = {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
};
<br>

<br>
The object literal starts and ends with curly braces {}. It creates an object with
<br>
two properties. The ﬁrst property has the key 'first' (a string) and the value
<br>
'Jane'. The second property has the key 'last' and the value 'Doe'. For more
<br>
information on object literals, consult §28.2.1 “Object literals: properties”.
<br>
• Array literal:
<br>
const arr = ['foo', 'bar'];
<br>

<br>
The Array literal starts and ends with square brackets []. It creates an Array with
<br>
two elements: 'foo' and 'bar'. For more information on Array literals, consult
<br>
§31.2.1 “Creating, reading, writing Arrays”.
<br>
13.4.2.1 Objects are mutable by default
<br>
By default, you can freely change, add, and remove the properties of objects:
<br>
const obj = {};
<br>
obj.foo = 'abc'; // add a property
<br>
assert.equal(obj.foo, 'abc');
<br>
obj.foo = 'def'; // change a property
<br>
assert.equal(obj.foo, 'def');
<br>

<br>
13.4.2.2 Objects are passed by identity
<br>
Objects are passed by identity (my term): variables (including parameters) store the identities of objects.
<br>

<br>
13.5 The operators typeof and instanceof: what’s the type of a value?
<br>

<br>
93
<br>

<br>
The identity of an object is like a pointer (or a transparent reference) to the object’s actual
<br>
data on the heap (think shared main memory of a JavaScript engine).
<br>
When assigning an object to a variable or passing it as an argument to a function, its
<br>
identity is copied. Each object literal creates a fresh object on the heap and returns its
<br>
identity.
<br>
const a = {}; // fresh empty object
<br>
// Pass the identity in `a` to `b`:
<br>
const b = a;
<br>
// Now `a` and `b` point to the same object
<br>
// (they “share” that object):
<br>
assert.equal(a === b, true);
<br>
// Changing `a` also changes `b`:
<br>
a.foo = 123;
<br>
assert.equal(b.foo, 123);
<br>

<br>
JavaScript uses garbage collection to automatically manage memory:
<br>
let obj = { prop: 'value' };
<br>
obj = {};
<br>

<br>
Now the old value { prop: 'value' } of obj is garbage (not used anymore). JavaScript
<br>
will automatically garbage-collect it (remove it from memory), at some point in time (possibly never if there is enough free memory).
<br>

<br>
Details: passing by identity
<br>
“Passing by identity” means that the identity of an object (a transparent reference)
<br>
is passed by value. This approach is also called “passing by sharing”.
<br>
13.4.2.3 Objects are compared by identity
<br>
Objects are compared by identity (my term): two variables are only equal if they contain the
<br>
same object identity. They are not equal if they refer to different objects with the same
<br>
content.
<br>
const obj = {}; // fresh empty object
<br>
assert.equal(obj === obj, true); // same identity
<br>
assert.equal({} === {}, false); // different identities, same content
<br>

<br>
13.5 The operators typeof and instanceof: what’s the type
<br>
of a value?
<br>
The two operators typeof and instanceof let you determine what type a given value x
<br>
has:
<br>

<br>
94
<br>

<br>
13 Values
<br>
if (typeof x === 'string') ···
<br>
if (x instanceof Array) ···
<br>

<br>
How do they differ?
<br>
• typeof distinguishes the 7 types of the speciﬁcation (minus one omission, plus one
<br>
addition).
<br>
• instanceof tests which class created a given value.
<br>

<br>
Rule of thumb: typeof is for primitive values; instanceof is for objects
<br>

<br>
13.5.1
<br>

<br>
typeof
<br>
Table 13.1: The results of the typeof operator.
<br>
x
<br>

<br>
typeof x
<br>

<br>
undefined
<br>

<br>
'undefined'
<br>

<br>
null
<br>

<br>
'object'
<br>

<br>
Boolean
<br>
Number
<br>
String
<br>
Symbol
<br>
Function
<br>
All other objects
<br>

<br>
'boolean'
<br>
'number'
<br>
'string'
<br>
'symbol'
<br>
'function'
<br>
'object'
<br>

<br>
Tbl. 13.1 lists all results of typeof. They roughly correspond to the 7 types of the language
<br>
speciﬁcation. Alas, there are two differences, and they are language quirks:
<br>
• typeof null returns 'object' and not 'null'. That’s a bug. Unfortunately, it
<br>
can’t be ﬁxed. TC39 tried to do that, but it broke too much code on the web.
<br>
• typeof of a function should be 'object' (functions are objects). Introducing a
<br>
separate category for functions is confusing.
<br>

<br>
Exercises: Two exercises on typeof
<br>
• exercises/values/typeof_exrc.mjs
<br>
• Bonus: exercises/values/is_object_test.mjs
<br>

<br>
13.5.2
<br>

<br>
instanceof
<br>

<br>
This operator answers the question: has a value x been created by a class C?
<br>
x instanceof C
<br>

<br>
For example:
<br>

<br>
13.6 Classes and constructor functions
<br>

<br>
95
<br>

<br>
> (function() {}) instanceof Function
<br>
true
<br>
> ({}) instanceof Object
<br>
true
<br>
> [] instanceof Array
<br>
true
<br>

<br>
Primitive values are not instances of anything:
<br>
> 123 instanceof Number
<br>
false
<br>
> '' instanceof String
<br>
false
<br>
> '' instanceof Object
<br>
false
<br>

<br>
Exercise: instanceof
<br>
exercises/values/instanceof_exrc.mjs
<br>

<br>
13.6 Classes and constructor functions
<br>
JavaScript’s original factories for objects are constructor functions: ordinary functions that
<br>
return “instances” of themselves if you invoke them via the new operator.
<br>
ES6 introduced classes, which are mainly better syntax for constructor functions.
<br>
In this book, I’m using the terms constructor function and class interchangeably.
<br>
Classes can be seen as partitioning the single type object of the speciﬁcation into subtypes – they give us more types than the limited 7 ones of the speciﬁcation. Each class is
<br>
the type of the objects that were created by it.
<br>

<br>
13.6.1 Constructor functions associated with primitive types
<br>
Each primitive type (except for the spec-internal types for undefined and null) has an
<br>
associated constructor function (think class):
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
The constructor function Boolean is associated with booleans.
<br>
The constructor function Number is associated with numbers.
<br>
The constructor function String is associated with strings.
<br>
The constructor function Symbol is associated with symbols.
<br>

<br>
Each of these functions plays several roles – for example, Number:
<br>
• You can use it as a function and convert values to numbers:
<br>
assert.equal(Number('123'), 123);
<br>

<br>
• Number.prototype provides the properties for numbers – for example, method
<br>
.toString():
<br>

<br>
96
<br>

<br>
13 Values
<br>
assert.equal((123).toString, Number.prototype.toString);
<br>

<br>
• Number is a namespace/container object for tool functions for numbers – for example:
<br>
assert.equal(Number.isInteger(123), true);
<br>

<br>
• Lastly, you can also use Number as a class and create number objects. These objects
<br>
are different from real numbers and should be avoided.
<br>
assert.notEqual(new Number(123), 123);
<br>
assert.equal(new Number(123).valueOf(), 123);
<br>

<br>
13.6.1.1 Wrapping primitive values
<br>
The constructor functions related to primitive types are also called wrapper types because
<br>
they provide the canonical way of converting primitive values to objects. In the process,
<br>
primitive values are “wrapped” in objects.
<br>
const prim = true;
<br>
assert.equal(typeof prim, 'boolean');
<br>
assert.equal(prim instanceof Boolean, false);
<br>
const wrapped = Object(prim);
<br>
assert.equal(typeof wrapped, 'object');
<br>
assert.equal(wrapped instanceof Boolean, true);
<br>
assert.equal(wrapped.valueOf(), prim); // unwrap
<br>

<br>
Wrapping rarely matters in practice, but it is used internally in the language speciﬁcation,
<br>
to give primitives properties.
<br>

<br>
13.7 Converting between types
<br>
There are two ways in which values are converted to other types in JavaScript:
<br>
• Explicit conversion: via functions such as String().
<br>
• Coercion (automatic conversion): happens when an operation receives operands/parameters that it can’t work with.
<br>

<br>
13.7.1 Explicit conversion between types
<br>
The function associated with a primitive type explicitly converts values to that type:
<br>
> Boolean(0)
<br>
false
<br>
> Number('123')
<br>
123
<br>
> String(123)
<br>
'123'
<br>

<br>
You can also use Object() to convert values to objects:
<br>

<br>
13.7 Converting between types
<br>

<br>
97
<br>

<br>
> typeof Object(123)
<br>
'object'
<br>

<br>
13.7.2 Coercion (automatic conversion between types)
<br>
For many operations, JavaScript automatically converts the operands/parameters if their
<br>
types don’t ﬁt. This kind of automatic conversion is called coercion.
<br>
For example, the multiplication operator coerces its operands to numbers:
<br>
> '7' * '3'
<br>
21
<br>

<br>
Many built-in functions coerce, too. For example, parseInt() coerces its parameter to
<br>
string (parsing stops at the ﬁrst character that is not a digit):
<br>
> parseInt(123.45)
<br>
123
<br>

<br>
Exercise: Converting values to primitives
<br>
exercises/values/conversion_exrc.mjs
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
98
<br>

<br>
13 Values
<br>

<br>
Chapter 14
<br>

<br>
Operators
<br>
Contents
<br>
14.1 Making sense of operators . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
99
<br>

<br>
14.1.1 Operators coerce their operands to appropriate types . . . . . 100
<br>
14.1.2 Most operators only work with primitive values . . . . . . . . 100
<br>
14.2 The plus operator (+) . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
<br>
14.3 Assignment operators . . . . . . . . . . . . . . . . . . . . . . . . . . 101
<br>
14.3.1 The plain assignment operator . . . . . . . . . . . . . . . . . . 101
<br>
14.3.2 Compound assignment operators . . . . . . . . . . . . . . . . 101
<br>
14.3.3 A list of all compound assignment operators . . . . . . . . . . 101
<br>
14.4 Equality: == vs. === . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
<br>
14.4.1 Loose equality (== and !=) . . . . . . . . . . . . . . . . . . . . 102
<br>
14.4.2 Strict equality (=== and !==) . . . . . . . . . . . . . . . . . . . 103
<br>
14.4.3 Recommendation: always use strict equality . . . . . . . . . . 103
<br>
14.4.4 Even stricter than ===: Object.is() . . . . . . . . . . . . . . . 104
<br>
14.5 Ordering operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
<br>
14.6 Various other operators . . . . . . . . . . . . . . . . . . . . . . . . . 105
<br>
14.6.1 Comma operator . . . . . . . . . . . . . . . . . . . . . . . . . 105
<br>
14.6.2 void operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
<br>

<br>
14.1 Making sense of operators
<br>
JavaScript’s operators may seem quirky. With the following two rules, they are easier to
<br>
understand:
<br>
• Operators coerce their operands to appropriate types
<br>
• Most operators only work with primitive values
<br>
99
<br>

<br>
100
<br>

<br>
14 Operators
<br>

<br>
14.1.1 Operators coerce their operands to appropriate types
<br>
If an operator gets operands that don’t have the proper types, it rarely throws an exception. Instead, it coerces (automatically converts) the operands so that it can work with
<br>
them. Let’s look at two examples.
<br>
First, the multiplication operator can only work with numbers. Therefore, it converts
<br>
strings to numbers before computing its result.
<br>
> '7' * '3'
<br>
21
<br>

<br>
Second, the square brackets operator ([ ]) for accessing the properties of an object can
<br>
only handle strings and symbols. All other values are coerced to string:
<br>
const obj = {};
<br>
obj['true'] = 123;
<br>
// Coerce true to the string 'true'
<br>
assert.equal(obj[true], 123);
<br>

<br>
14.1.2 Most operators only work with primitive values
<br>
As mentioned before, most operators only work with primitive values. If an operand is
<br>
an object, it is usually coerced to a primitive value – for example:
<br>
> [1,2,3] + [4,5,6]
<br>
'1,2,34,5,6'
<br>

<br>
Why? The plus operator ﬁrst coerces its operands to primitive values:
<br>
> String([1,2,3])
<br>
'1,2,3'
<br>
> String([4,5,6])
<br>
'4,5,6'
<br>

<br>
Next, it concatenates the two strings:
<br>
> '1,2,3' + '4,5,6'
<br>
'1,2,34,5,6'
<br>

<br>
14.2 The plus operator (+)
<br>
The plus operator works as follows in JavaScript:
<br>
• First, it converts both operands to primitive values. Then it switches to one of two
<br>
modes:
<br>
– String mode: If one of the two primitive values is a string, then it converts
<br>
the other one to a string, concatenates both strings, and returns the result.
<br>
– Number mode: Otherwise, It converts both operands to numbers, adds them,
<br>
and returns the result.
<br>
String mode lets us use + to assemble strings:
<br>

<br>
14.3 Assignment operators
<br>

<br>
101
<br>

<br>
> 'There are ' + 3 + ' items'
<br>
'There are 3 items'
<br>

<br>
Number mode means that if neither operand is a string (or an object that becomes a string)
<br>
then everything is coerced to numbers:
<br>
> 4 + true
<br>
5
<br>
Number(true) is 1.
<br>

<br>
14.3 Assignment operators
<br>
14.3.1 The plain assignment operator
<br>
The plain assignment operator is used to change storage locations:
<br>
x = value; // assign to a previously declared variable
<br>
obj.propKey = value; // assign to a property
<br>
arr[index] = value; // assign to an Array element
<br>

<br>
Initializers in variable declarations can also be viewed as a form of assignment:
<br>
const x = value;
<br>
let y = value;
<br>

<br>
14.3.2 Compound assignment operators
<br>
Given an operator op, the following two ways of assigning are equivalent:
<br>
myvar op= value
<br>
myvar = myvar op value
<br>

<br>
If, for example, op is +, then we get the operator += that works as follows.
<br>
let str = '';
<br>
str += '<b>';
<br>
str += 'Hello!';
<br>
str += '</b>';
<br>
assert.equal(str, '<b>Hello!</b>');
<br>

<br>
14.3.3 A list of all compound assignment operators
<br>
• Arithmetic operators:
<br>
+= -= *= /= %= **=
<br>
+= also works for string concatenation
<br>

<br>
• Bitwise operators:
<br>
<<= >>= >>>= &= ^= |=
<br>

<br>
102
<br>

<br>
14 Operators
<br>

<br>
14.4 Equality: == vs. ===
<br>
JavaScript has two kinds of equality operators: loose equality (==) and strict equality
<br>
(===). The recommendation is to always use the latter.
<br>

<br>
Other names for == and ===
<br>
• == is also called double equals. Its ofﬁcial name in the language speciﬁcation is
<br>
abstract equality comparison.
<br>
• === is also called triple equals.
<br>

<br>
14.4.1 Loose equality (== and !=)
<br>
Loose equality is one of JavaScript’s quirks. It often coerces operands. Some of those
<br>
coercions make sense:
<br>
> '123' == 123
<br>
true
<br>
> false == 0
<br>
true
<br>

<br>
Others less so:
<br>
> '' == 0
<br>
true
<br>

<br>
Objects are coerced to primitives if (and only if!) the other operand is primitive:
<br>
> [1, 2, 3] == '1,2,3'
<br>
true
<br>
> ['1', '2', '3'] == '1,2,3'
<br>
true
<br>

<br>
If both operands are objects, they are only equal if they are the same object:
<br>
> [1, 2, 3] == ['1', '2', '3']
<br>
false
<br>
> [1, 2, 3] == [1, 2, 3]
<br>
false
<br>
> const arr = [1, 2, 3];
<br>
> arr == arr
<br>
true
<br>

<br>
Lastly, == considers undefined and null to be equal:
<br>
> undefined == null
<br>
true
<br>

<br>
14.4 Equality: == vs. ===
<br>

<br>
103
<br>

<br>
14.4.2 Strict equality (=== and !==)
<br>
Strict equality never coerces. Two values are only equal if they have the same type. Let’s
<br>
revisit our previous interaction with the == operator and see what the === operator does:
<br>
> false === 0
<br>
false
<br>
> '123' === 123
<br>
false
<br>

<br>
An object is only equal to another value if that value is the same object:
<br>
> [1, 2, 3] === '1,2,3'
<br>
false
<br>
> ['1', '2', '3'] === '1,2,3'
<br>
false
<br>
> [1, 2, 3] === ['1', '2', '3']
<br>
false
<br>
> [1, 2, 3] === [1, 2, 3]
<br>
false
<br>
> const arr = [1, 2, 3];
<br>
> arr === arr
<br>
true
<br>

<br>
The === operator does not consider undefined and null to be equal:
<br>
> undefined === null
<br>
false
<br>

<br>
14.4.3 Recommendation: always use strict equality
<br>
I recommend to always use ===. It makes your code easier to understand and spares you
<br>
from having to think about the quirks of ==.
<br>
Let’s look at two use cases for == and what I recommend to do instead.
<br>
14.4.3.1 Use case for ==: comparing with a number or a string
<br>
== lets you check if a value x is a number or that number as a string – with a single
<br>

<br>
comparison:
<br>
if (x == 123) {
<br>
// x is either 123 or '123'
<br>
}
<br>

<br>
I prefer either of the following two alternatives:
<br>
if (x === 123 || x === '123') ···
<br>
if (Number(x) === 123) ···
<br>

<br>
You can also convert x to a number when you ﬁrst encounter it.
<br>

<br>
104
<br>

<br>
14 Operators
<br>

<br>
14.4.3.2 Use case for ==: comparing with undefined or null
<br>
Another use case for == is to check if a value x is either undefined or null:
<br>
if (x == null) {
<br>
// x is either null or undefined
<br>
}
<br>

<br>
The problem with this code is that you can’t be sure if someone meant to write it that way
<br>
or if they made a typo and meant === null.
<br>
I prefer either of the following two alternatives:
<br>
if (x === undefined || x === null) ···
<br>
if (!x) ···
<br>

<br>
A downside of the second alternative is that it accepts values other than undefined and
<br>
null, but it is a well-established pattern in JavaScript (to be explained in detail in §16.3
<br>
“Truthiness-based existence checks”).
<br>
The following three conditions are also roughly equivalent:
<br>
if (x != null) ···
<br>
if (x !== undefined && x !== null) ···
<br>
if (x) ···
<br>

<br>
14.4.4 Even stricter than ===: Object.is()
<br>
Method Object.is() compares two values:
<br>
> Object.is(123, 123)
<br>
true
<br>
> Object.is(123, '123')
<br>
false
<br>

<br>
It is even stricter than ===. For example, it considers NaN, the error value for computations
<br>
involving numbers, to be equal to itself:
<br>
> Object.is(NaN, NaN)
<br>
true
<br>
> NaN === NaN
<br>
false
<br>

<br>
That is occasionally useful. For example, you can use it to implement an improved version of the Array method .indexOf():
<br>
const myIndexOf = (arr, elem) => {
<br>
return arr.findIndex(x => Object.is(x, elem));
<br>
};
<br>
myIndexOf() ﬁnds NaN in an Array, while .indexOf() doesn’t:
<br>
> myIndexOf([0,NaN,2], NaN)
<br>
1
<br>
> [0,NaN,2].indexOf(NaN)
<br>
-1
<br>

<br>
105
<br>

<br>
14.6 Various other operators
<br>

<br>
The result -1 means that .indexOf() couldn’t ﬁnd its argument in the Array.
<br>

<br>
14.5 Ordering operators
<br>
Table 14.1: JavaScript’s ordering operators.
<br>
Operator
<br>

<br>
name
<br>

<br>
<
<br>

<br>
less than
<br>
Less than or equal
<br>
Greater than
<br>
Greater than or equal
<br>

<br>
<=
<br>
>
<br>
>=
<br>

<br>
JavaScript’s ordering operators (tbl. 14.1) work for both numbers and strings:
<br>
> 5 >= 2
<br>
true
<br>
> 'bar' < 'foo'
<br>
true
<br>
<= and >= are based on strict equality.
<br>

<br>
The ordering operators don’t work well for human languages
<br>
The ordering operators don’t work well for comparing text in a human language,
<br>
e.g., when capitalization or accents are involved. The details are explained in §20.5
<br>
“Comparing strings”.
<br>

<br>
14.6 Various other operators
<br>
Operators for booleans, strings, numbers, objects: are covered elsewhere in this book.
<br>
The next two subsections discuss two operators that are rarely used.
<br>

<br>
14.6.1 Comma operator
<br>
The comma operator has two operands, evaluates both of them and returns the second
<br>
one:
<br>
> 'a', 'b'
<br>
'b'
<br>

<br>
For more information on this operator, see Speaking JavaScript.
<br>

<br>
14.6.2
<br>

<br>
void operator
<br>

<br>
The void operator evaluates its operand and returns undefined:
<br>

<br>
106
<br>

<br>
14 Operators
<br>

<br>
> void (3 + 2)
<br>
undefined
<br>

<br>
For more information on this operator, see Speaking JavaScript.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Part IV
<br>

<br>
Primitive values
<br>

<br>
107
<br>

<br>
Chapter 15
<br>

<br>
The non-values undefined and
<br>
null
<br>
Contents
<br>
15.1 undefined vs. null . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
<br>
15.2 Occurrences of undefined and null . . . . . . . . . . . . . . . . . . . 110
<br>
15.2.1 Occurrences of undefined . . . . . . . . . . . . . . . . . . . . 110
<br>
15.2.2 Occurrences of null . . . . . . . . . . . . . . . . . . . . . . . . 110
<br>
15.3 Checking for undefined or null . . . . . . . . . . . . . . . . . . . . . 111
<br>
15.4 undefined and null don’t have properties . . . . . . . . . . . . . . . 111
<br>
15.5 The history of undefined and null . . . . . . . . . . . . . . . . . . . 112
<br>

<br>
Many programming languages have one “non-value” called null. It indicates that a variable does not currently point to an object – for example, when it hasn’t been initialized
<br>
yet.
<br>
In contrast, JavaScript has two of them: undefined and null.
<br>

<br>
15.1
<br>

<br>
undefined vs. null
<br>

<br>
Both values are very similar and often used interchangeably. How they differ is therefore
<br>
subtle. The language itself makes the following distinction:
<br>
• undefined means “not initialized” (e.g., a variable) or “not existing” (e.g., a property of an object).
<br>
• null means “the intentional absence of any object value” (a quote from the language speciﬁcation).
<br>
Programmers may make the following distinction:
<br>
• undefined is the non-value used by the language (when something is uninitialized,
<br>
etc.).
<br>
109
<br>

<br>
110
<br>

<br>
15 The non-values undefined and null
<br>

<br>
• null means “explicitly switched off”. That is, it helps implement a type that comprises both meaningful values and a meta-value that stands for “no meaningful
<br>
value”. Such a type is called option type or maybe type in functional programming.
<br>

<br>
15.2 Occurrences of undefined and null
<br>
The following subsections describe where undefined and null appear in the language.
<br>
We’ll encounter several mechanisms that are explained in more detail later in this book.
<br>

<br>
15.2.1 Occurrences of undefined
<br>
Uninitialized variable myVar:
<br>
let myVar;
<br>
assert.equal(myVar, undefined);
<br>

<br>
Parameter x is not provided:
<br>
function func(x) {
<br>
return x;
<br>
}
<br>
assert.equal(func(), undefined);
<br>

<br>
Property .unknownProp is missing:
<br>
const obj = {};
<br>
assert.equal(obj.unknownProp, undefined);
<br>

<br>
If you don’t explicitly specify the result of a function via a return statement, JavaScript
<br>
returns undefined for you:
<br>
function func() {}
<br>
assert.equal(func(), undefined);
<br>

<br>
15.2.2 Occurrences of null
<br>
The prototype of an object is either an object or, at the end of a chain of prototypes, null.
<br>
Object.prototype does not have a prototype:
<br>
> Object.getPrototypeOf(Object.prototype)
<br>
null
<br>

<br>
If you match a regular expression (such as /a/) against a string (such as 'x'), you either
<br>
get an object with matching data (if matching was successful) or null (if matching failed):
<br>
> /a/.exec('x')
<br>
null
<br>

<br>
The JSON data format does not support undefined, only null:
<br>
> JSON.stringify({a: undefined, b: null})
<br>
'{"b":null}'
<br>

<br>
15.3 Checking for undefined or null
<br>

<br>
111
<br>

<br>
15.3 Checking for undefined or null
<br>
Checking for either:
<br>
if (x === null) ···
<br>
if (x === undefined) ···
<br>

<br>
Does x have a value?
<br>
if (x !== undefined && x !== null) {
<br>
// ···
<br>
}
<br>
if (x) { // truthy?
<br>
// x is neither: undefined, null, false, 0, NaN, ''
<br>
}
<br>

<br>
Is x either undefined or null?
<br>
if (x === undefined || x === null) {
<br>
// ···
<br>
}
<br>
if (!x) { // falsy?
<br>
// x is: undefined, null, false, 0, NaN, ''
<br>
}
<br>

<br>
Truthy means “is true if coerced to boolean”. Falsy means “is false if coerced to boolean”.
<br>
Both concepts are explained properly in §16.2 “Falsy and truthy values”.
<br>

<br>
15.4
<br>

<br>
undefined and null don’t have properties
<br>

<br>
undefined and null are the two only JavaScript values where you get an exception if
<br>
you try to read a property. To explore this phenomenon, let’s use the following function,
<br>
which reads (“gets”) property .foo and returns the result.
<br>
function getFoo(x) {
<br>
return x.foo;
<br>
}
<br>

<br>
If we apply getFoo() to various values, we can see that it only fails for undefined and
<br>
null:
<br>
> getFoo(undefined)
<br>
TypeError: Cannot read property 'foo' of undefined
<br>
> getFoo(null)
<br>
TypeError: Cannot read property 'foo' of null
<br>
> getFoo(true)
<br>
undefined
<br>
> getFoo({})
<br>
undefined
<br>

<br>
112
<br>

<br>
15 The non-values undefined and null
<br>

<br>
15.5 The history of undefined and null
<br>
In Java (which inspired many aspects of JavaScript), initialization values depend on the
<br>
static type of a variable:
<br>
• Variables with object types are initialized with null.
<br>
• Each primitive type has its own initialization value. For example, int variables are
<br>
initialized with 0.
<br>
In JavaScript, each variable can hold both object values and primitive values. Therefore,
<br>
if null means “not an object”, JavaScript also needs an initialization value that means
<br>
“neither an object nor a primitive value”. That initialization value is undefined.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 16
<br>

<br>
Booleans
<br>
Contents
<br>
16.1 Converting to boolean . . . . . . . . . . . . . . . . . . . . . . . . . . 113
<br>
16.2 Falsy and truthy values . . . . . . . . . . . . . . . . . . . . . . . . . 114
<br>
16.2.1 Checking for truthiness or falsiness . . . . . . . . . . . . . . . 115
<br>
16.3 Truthiness-based existence checks . . . . . . . . . . . . . . . . . . . 115
<br>
16.3.1 Pitfall: truthiness-based existence checks are imprecise
<br>

<br>
. . . . 116
<br>

<br>
16.3.2 Use case: was a parameter provided? . . . . . . . . . . . . . . 116
<br>
16.3.3 Use case: does a property exist? . . . . . . . . . . . . . . . . . 116
<br>
16.4 Conditional operator (? :) . . . . . . . . . . . . . . . . . . . . . . . . 117
<br>
16.5 Binary logical operators: And (x && y), Or (x || y) . . . . . . . . . . 117
<br>
16.5.1 Logical And (x && y) . . . . . . . . . . . . . . . . . . . . . . . 118
<br>
16.5.2 Logical Or (||) . . . . . . . . . . . . . . . . . . . . . . . . . . 118
<br>
16.5.3 Default values via logical Or (||)
<br>

<br>
. . . . . . . . . . . . . . . . 119
<br>

<br>
16.6 Logical Not (!) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
<br>

<br>
The primitive type boolean comprises two values – false and true:
<br>
> typeof false
<br>
'boolean'
<br>
> typeof true
<br>
'boolean'
<br>

<br>
16.1 Converting to boolean
<br>
The meaning of “converting to [type]”
<br>
“Converting to [type]” is short for “Converting arbitrary values to values of type
<br>
[type]”.
<br>
These are three ways in which you can convert an arbitrary value x to a boolean.
<br>
113
<br>

<br>
114
<br>

<br>
16 Booleans
<br>

<br>
• Boolean(x)
<br>
Most descriptive; recommended.
<br>
• x ? true : false
<br>
Uses the conditional operator (explained later in this chapter).
<br>
• !!x
<br>
Uses the logical Not operator (!). This operator coerces its operand to boolean. It
<br>
is applied a second time to get a non-negated result.
<br>
Tbl. 16.1 describes how various values are converted to boolean.
<br>
Table 16.1: Converting values to booleans.
<br>
x
<br>

<br>
Boolean(x)
<br>

<br>
undefined
<br>

<br>
false
<br>

<br>
null
<br>

<br>
false
<br>

<br>
boolean value
<br>
number value
<br>

<br>
x (no change)
<br>
0 → false, NaN → false
<br>

<br>
other numbers → true
<br>
string value
<br>

<br>
'' → false
<br>

<br>
object value
<br>

<br>
other strings → true
<br>
always true
<br>

<br>
16.2 Falsy and truthy values
<br>
When checking the condition of an if statement, a while loop, or a do-while loop,
<br>
JavaScript works differently than you may expect. Take, for example, the following
<br>
condition:
<br>
if (value) {}
<br>

<br>
In many programming languages, this condition is equivalent to:
<br>
if (value === true) {}
<br>

<br>
However, in JavaScript, it is equivalent to:
<br>
if (Boolean(value) === true) {}
<br>

<br>
That is, JavaScript checks if value is true when converted to boolean. This kind of check
<br>
is so common that the following names were introduced:
<br>
• A value is called truthy if it is true when converted to boolean.
<br>
• A value is called falsy if it is false when converted to boolean.
<br>
Each value is either truthy or falsy. Consulting tbl. 16.1, we can make an exhaustive list
<br>
of falsy values:
<br>
• undefined, null
<br>
• false
<br>
• 0, NaN
<br>

<br>
16.3 Truthiness-based existence checks
<br>

<br>
115
<br>

<br>
• ''
<br>
All other values (including all objects) are truthy:
<br>
> Boolean('abc')
<br>
true
<br>
> Boolean([])
<br>
true
<br>
> Boolean({})
<br>
true
<br>

<br>
16.2.1 Checking for truthiness or falsiness
<br>
if (x) {
<br>
// x is truthy
<br>
}
<br>
if (!x) {
<br>
// x is falsy
<br>
}
<br>
if (x) {
<br>
// x is truthy
<br>
} else {
<br>
// x is falsy
<br>
}
<br>
const result = x ? 'truthy' : 'falsy';
<br>

<br>
The conditional operator that is used in the last line, is explained later in this chapter.
<br>

<br>
Exercise: Truthiness
<br>
exercises/booleans/truthiness_exrc.mjs
<br>

<br>
16.3 Truthiness-based existence checks
<br>
In JavaScript, if you read something that doesn’t exist (e.g., a missing parameter or a
<br>
missing property), you usually get undefined as a result. In these cases, an existence
<br>
check amounts to comparing a value with undefined. For example, the following code
<br>
checks if object obj has the property .prop:
<br>
if (obj.prop !== undefined) {
<br>
// obj has property .prop
<br>
}
<br>

<br>
Due to undefined being falsy, we can shorten this check to:
<br>
if (obj.prop) {
<br>
// obj has property .prop
<br>

<br>
116
<br>

<br>
16 Booleans
<br>
}
<br>

<br>
16.3.1 Pitfall: truthiness-based existence checks are imprecise
<br>
Truthiness-based existence checks have one pitfall: they are not very precise. Consider
<br>
this previous example:
<br>
if (obj.prop) {
<br>
// obj has property .prop
<br>
}
<br>

<br>
The body of the if statement is skipped if:
<br>
• obj.prop is missing (in which case, JavaScript returns undefined).
<br>
However, it is also skipped if:
<br>
• obj.prop is undefined.
<br>
• obj.prop is any other falsy value (null, 0, '', etc.).
<br>
In practice, this rarely causes problems, but you have to be aware of this pitfall.
<br>

<br>
16.3.2 Use case: was a parameter provided?
<br>
A truthiness check is often used to determine if the caller of a function provided a parameter:
<br>
function func(x) {
<br>
if (!x) {
<br>
throw new Error('Missing parameter x');
<br>
}
<br>
// ···
<br>
}
<br>

<br>
On the plus side, this pattern is established and short. It correctly throws errors for undefined and null.
<br>
On the minus side, there is the previously mentioned pitfall: the code also throws errors
<br>
for all other falsy values.
<br>
An alternative is to check for undefined:
<br>
if (x === undefined) {
<br>
throw new Error('Missing parameter x');
<br>
}
<br>

<br>
16.3.3 Use case: does a property exist?
<br>
Truthiness checks are also often used to determine if a property exists:
<br>
function readFile(fileDesc) {
<br>
if (!fileDesc.path) {
<br>
throw new Error('Missing property: .path');
<br>
}
<br>

<br>
16.4 Conditional operator (? :)
<br>

<br>
117
<br>

<br>
// ···
<br>
}
<br>
readFile({ path: 'foo.txt' }); // no error
<br>

<br>
This pattern is also established and has the usual caveat: it not only throws if the property
<br>
is missing, but also if it exists and has any of the falsy values.
<br>
If you truly want to check if the property exists, you have to use the in operator:
<br>
if (! ('path' in fileDesc)) {
<br>
throw new Error('Missing property: .path');
<br>
}
<br>

<br>
16.4 Conditional operator (? :)
<br>
The conditional operator is the expression version of the if statement. Its syntax is:
<br>
«condition» ? «thenExpression» : «elseExpression»
<br>

<br>
It is evaluated as follows:
<br>
• If condition is truthy, evaluate and return thenExpression.
<br>
• Otherwise, evaluate and return elseExpression.
<br>
The conditional operator is also called ternary operator because it has three operands.
<br>
Examples:
<br>
> true ? 'yes' : 'no'
<br>
'yes'
<br>
> false ? 'yes' : 'no'
<br>
'no'
<br>
> '' ? 'yes' : 'no'
<br>
'no'
<br>

<br>
The following code demonstrates that whichever of the two branches “then” and “else”
<br>
is chosen via the condition, only that branch is evaluated. The other branch isn’t.
<br>
const x = (true ? console.log('then') : console.log('else'));
<br>
// Output:
<br>
// 'then'
<br>

<br>
16.5 Binary logical operators: And (x && y), Or (x || y)
<br>
The operators && and || are value-preserving and short-circuiting. What does that mean?
<br>
Value-preservation means that operands are interpreted as booleans but returned
<br>
unchanged:
<br>
> 12 || 'hello'
<br>
12
<br>

<br>
118
<br>

<br>
16 Booleans
<br>
> 0 || 'hello'
<br>
'hello'
<br>

<br>
Short-circuiting means if the ﬁrst operand already determines the result, then the second
<br>
operand is not evaluated. The only other operator that delays evaluating its operands
<br>
is the conditional operator. Usually, all operands are evaluated before performing an
<br>
operation.
<br>

<br>
For example, logical And (&&) does not evaluate its second operand if the ﬁrst one is falsy:
<br>
const x = false && console.log('hello');
<br>
// No output
<br>

<br>
If the ﬁrst operand is truthy, console.log() is executed:
<br>
const x = true && console.log('hello');
<br>
// Output:
<br>
// 'hello'
<br>

<br>
16.5.1 Logical And (x && y)
<br>
The expression a && b (“a And b”) is evaluated as follows:
<br>
1. Evaluate a.
<br>
2. Is the result falsy? Return it.
<br>
3. Otherwise, evaluate b and return the result.
<br>
In other words, the following two expressions are roughly equivalent:
<br>
a && b
<br>
!a ? a : b
<br>

<br>
Examples:
<br>
> false && true
<br>
false
<br>
> false && 'abc'
<br>
false
<br>
> true && false
<br>
false
<br>
> true && 'abc'
<br>
'abc'
<br>
> '' && 'abc'
<br>
''
<br>

<br>
16.5.2 Logical Or (||)
<br>
The expression a || b (“a Or b”) is evaluated as follows:
<br>
1. Evaluate a.
<br>
2. Is the result truthy? Return it.
<br>

<br>
16.6 Logical Not (!)
<br>

<br>
119
<br>

<br>
3. Otherwise, evaluate b and return the result.
<br>
In other words, the following two expressions are roughly equivalent:
<br>
a || b
<br>
a ? a : b
<br>

<br>
Examples:
<br>
> true || false
<br>
true
<br>
> true || 'abc'
<br>
true
<br>
> false || true
<br>
true
<br>
> false || 'abc'
<br>
'abc'
<br>
> 'abc' || 'def'
<br>
'abc'
<br>

<br>
16.5.3 Default values via logical Or (||)
<br>
Sometimes you receive a value and only want to use it if it isn’t either null or undefined.
<br>
Otherwise, you’d like to use a default value, as a fallback. You can do that via the ||
<br>
operator:
<br>
const valueToUse = valueReceived || defaultValue;
<br>

<br>
The following code shows a real-world example:
<br>
function countMatches(regex, str) {
<br>
const matchResult = str.match(regex); // null or Array
<br>
return (matchResult || []).length;
<br>
}
<br>

<br>
If there are one or more matches for regex inside str then .match() returns an Array. If
<br>
there are no matches, it unfortunately returns null (and not the empty Array). We ﬁx
<br>
that via the || operator.
<br>

<br>
Exercise: Default values via the Or operator (||)
<br>
exercises/booleans/default_via_or_exrc.mjs
<br>

<br>
16.6 Logical Not (!)
<br>
The expression !x (“Not x”) is evaluated as follows:
<br>
1. Evaluate x.
<br>
2. Is it truthy? Return false.
<br>

<br>
120
<br>

<br>
16 Booleans
<br>

<br>
3. Otherwise, return true.
<br>
Examples:
<br>
> !false
<br>
true
<br>
> !true
<br>
false
<br>
> !0
<br>
true
<br>
> !123
<br>
false
<br>
> !''
<br>
true
<br>
> !'abc'
<br>
false
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 17
<br>

<br>
Numbers
<br>
Contents
<br>
17.1 JavaScript only has ﬂoating point numbers . . . . . . . . . . . . . . 122
<br>
17.2 Number literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
<br>
17.2.1 Integer literals . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
<br>
17.2.2 Floating point literals . . . . . . . . . . . . . . . . . . . . . . . 123
<br>
17.2.3 Syntactic pitfall: properties of integer literals . . . . . . . . . . 123
<br>
17.3 Arithmetic operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
<br>
17.3.1 Binary arithmetic operators
<br>

<br>
. . . . . . . . . . . . . . . . . . . 123
<br>

<br>
17.3.2 Unary plus (+) and negation (-) . . . . . . . . . . . . . . . . . 124
<br>
17.3.3 Incrementing (++) and decrementing (--) . . . . . . . . . . . . 124
<br>
17.4 Converting to number . . . . . . . . . . . . . . . . . . . . . . . . . . 125
<br>
17.5 Error values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
<br>
17.6 Error value: NaN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
<br>
17.6.1 Checking for NaN . . . . . . . . . . . . . . . . . . . . . . . . . 127
<br>
17.6.2 Finding NaN in Arrays . . . . . . . . . . . . . . . . . . . . . . . 127
<br>
17.7 Error value: Infinity . . . . . . . . . . . . . . . . . . . . . . . . . . 128
<br>
17.7.1 Infinity as a default value
<br>

<br>
. . . . . . . . . . . . . . . . . . . 128
<br>

<br>
17.7.2 Checking for Infinity . . . . . . . . . . . . . . . . . . . . . . 128
<br>
17.8 The precision of numbers: careful with decimal fractions . . . . . . 129
<br>
17.9 (Advanced) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
<br>
17.10Background: ﬂoating point precision . . . . . . . . . . . . . . . . . . 129
<br>
17.10.1 A simpliﬁed representation of ﬂoating point numbers . . . . . 130
<br>
17.11Integers in JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . 131
<br>
17.11.1 Converting to integer . . . . . . . . . . . . . . . . . . . . . . . 131
<br>
17.11.2 Ranges of integers in JavaScript . . . . . . . . . . . . . . . . . 132
<br>
17.11.3 Safe integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
<br>
17.12Bitwise operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
<br>
17.12.1 Internally, bitwise operators work with 32-bit integers . . . . . 133
<br>
17.12.2 Binary bitwise operators . . . . . . . . . . . . . . . . . . . . . 134
<br>

<br>
121
<br>

<br>
122
<br>

<br>
17 Numbers
<br>
17.12.3 Bitwise Not . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
17.12.4 Bitwise shift operators . . . . . . . . . . . . . . . . . . . . .
<br>
17.12.5 b32(): displaying unsigned 32-bit integers in binary notation
<br>
17.13Quick reference: numbers . . . . . . . . . . . . . . . . . . . . . . .
<br>
17.13.1 Global functions for numbers . . . . . . . . . . . . . . . . .
<br>
17.13.2 Static properties of Number . . . . . . . . . . . . . . . . . . .
<br>
17.13.3 Static methods of Number . . . . . . . . . . . . . . . . . . . .
<br>
17.13.4 Methods of Number.prototype . . . . . . . . . . . . . . . . .
<br>
17.13.5 Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
135
<br>
135
<br>
135
<br>
136
<br>
136
<br>
136
<br>
137
<br>
138
<br>
140
<br>

<br>
This chapter covers JavaScript’s single type for numbers, number.
<br>

<br>
17.1 JavaScript only has ﬂoating point numbers
<br>
You can express both integers and ﬂoating point numbers in JavaScript:
<br>
98
<br>
123.45
<br>

<br>
However, there is only a single type for all numbers: they are all doubles, 64-bit ﬂoating
<br>
point numbers implemented according to the IEEE Standard for Floating-Point Arithmetic (IEEE 754).
<br>
Integers are simply ﬂoating point numbers without a decimal fraction:
<br>
> 98 === 98.0
<br>
true
<br>

<br>
Note that, under the hood, most JavaScript engines are often able to use real integers,
<br>
with all associated performance and storage size beneﬁts.
<br>

<br>
17.2 Number literals
<br>
Let’s examine literals for numbers.
<br>

<br>
17.2.1 Integer literals
<br>
Several integer literals let you express integers with various bases:
<br>
// Binary (base 2)
<br>
assert.equal(0b11, 3);
<br>
// Octal (base 8)
<br>
assert.equal(0o10, 8);
<br>
// Decimal (base 10):
<br>
assert.equal(35, 35);
<br>
// Hexadecimal (base 16)
<br>
assert.equal(0xE7, 231);
<br>

<br>
123
<br>

<br>
17.3 Arithmetic operators
<br>

<br>
17.2.2 Floating point literals
<br>
Floating point numbers can only be expressed in base 10.
<br>
Fractions:
<br>
> 35.0
<br>
35
<br>

<br>
Exponent: eN means ×10N
<br>
> 3e2
<br>
300
<br>
> 3e-2
<br>
0.03
<br>
> 0.3e2
<br>
30
<br>

<br>
17.2.3 Syntactic pitfall: properties of integer literals
<br>
Accessing a property of an integer literal entails a pitfall: If the integer literal is immediately followed by a dot, then that dot is interpreted as a decimal dot:
<br>
7.toString(); // syntax error
<br>

<br>
There are four ways to work around this pitfall:
<br>
7.0.toString()
<br>
(7).toString()
<br>
7..toString()
<br>
7 .toString()
<br>

<br>
// space before dot
<br>

<br>
17.3 Arithmetic operators
<br>
17.3.1 Binary arithmetic operators
<br>
Tbl. 17.1 lists JavaScript’s binary arithmetic operators.
<br>
Table 17.1: Binary arithmetic operators.
<br>
Operator
<br>

<br>
Name
<br>

<br>
n + m
<br>

<br>
n % m
<br>

<br>
Addition
<br>
Subtraction
<br>
Multiplication
<br>
Division
<br>
Remainder
<br>

<br>
ES1
<br>
ES1
<br>
ES1
<br>
ES1
<br>
ES1
<br>

<br>
n ** m
<br>

<br>
Exponentiation
<br>

<br>
ES2016
<br>

<br>
n - m
<br>
n * m
<br>
n / m
<br>

<br>
Example
<br>
3 + 4→7
<br>
9 - 1→8
<br>
3 * 2.25 → 6.75
<br>
5.625 / 5 → 1.125
<br>
8 % 5→3
<br>
-8 % 5 → -3
<br>
4 ** 2 → 16
<br>

<br>
124
<br>
17.3.1.1
<br>

<br>
17 Numbers
<br>
% is a remainder operator
<br>

<br>
% is a remainder operator, not a modulo operator. Its result has the sign of the ﬁrst
<br>

<br>
operand:
<br>
> 5 % 3
<br>
2
<br>
> -5 % 3
<br>
-2
<br>

<br>
For more information on the difference between remainder and modulo, see the blog post
<br>
“Remainder operator vs. modulo operator (with JavaScript code)” on 2ality.
<br>

<br>
17.3.2 Unary plus (+) and negation (-)
<br>
Tbl. 17.2 summarizes the two operators unary plus (+) and negation (-).
<br>
Table 17.2: The operators unary plus (+) and negation (-).
<br>
Operator
<br>

<br>
Name
<br>

<br>
+n
<br>

<br>
Unary plus
<br>
Unary negation
<br>

<br>
-n
<br>

<br>
Example
<br>
ES1
<br>
ES1
<br>

<br>
+(-7) → -7
<br>
-(-7) → 7
<br>

<br>
Both operators coerce their operands to numbers:
<br>
> +'5'
<br>
5
<br>
> +'-12'
<br>
-12
<br>
> -'9'
<br>
-9
<br>

<br>
Thus, unary plus lets us convert arbitrary values to numbers.
<br>

<br>
17.3.3 Incrementing (++) and decrementing (--)
<br>
The incrementation operator ++ exists in a preﬁx version and a sufﬁx version. In both
<br>
versions, it destructively adds one to its operand. Therefore, its operand must be a storage
<br>
location that can be changed.
<br>
The decrementation operator -- works the same, but subtracts one from its operand. The
<br>
next two examples explain the difference between the preﬁx and the sufﬁx version.
<br>
Tbl. 17.3 summarizes the incrementation and decrementation operators.
<br>
Table 17.3: Incrementation operators and decrementation operators.
<br>
Operator
<br>

<br>
Name
<br>

<br>
v++
<br>

<br>
Increment
<br>
Increment
<br>

<br>
++v
<br>

<br>
Example
<br>
ES1
<br>
ES1
<br>

<br>
let v=0; [v++, v] → [0, 1]
<br>
let v=0; [++v, v] → [1, 1]
<br>

<br>
125
<br>

<br>
17.4 Converting to number
<br>

<br>
Operator
<br>

<br>
Name
<br>

<br>
v--
<br>

<br>
Decrement
<br>
Decrement
<br>

<br>
--v
<br>

<br>
Example
<br>
ES1
<br>
ES1
<br>

<br>
let v=1; [v--, v] → [1, 0]
<br>
let v=1; [--v, v] → [0, 0]
<br>

<br>
Next, we’ll look at examples of these operators in use.
<br>
Preﬁx ++ and preﬁx -- change their operands and then return them.
<br>
let foo = 3;
<br>
assert.equal(++foo, 4);
<br>
assert.equal(foo, 4);
<br>
let bar = 3;
<br>
assert.equal(--bar, 2);
<br>
assert.equal(bar, 2);
<br>

<br>
Sufﬁx ++ and sufﬁx -- return their operands and then change them.
<br>
let foo = 3;
<br>
assert.equal(foo++, 3);
<br>
assert.equal(foo, 4);
<br>
let bar = 3;
<br>
assert.equal(bar--, 3);
<br>
assert.equal(bar, 2);
<br>

<br>
17.3.3.1 Operands: not just variables
<br>
You can also apply these operators to property values:
<br>
const obj = { a: 1 };
<br>
++obj.a;
<br>
assert.equal(obj.a, 2);
<br>

<br>
And to Array elements:
<br>
const arr = [ 4 ];
<br>
arr[0]++;
<br>
assert.deepEqual(arr, [5]);
<br>

<br>
Exercise: Number operators
<br>
exercises/numbers-math/is_odd_test.mjs
<br>

<br>
17.4 Converting to number
<br>
These are three ways of converting values to numbers:
<br>
• Number(value)
<br>

<br>
126
<br>

<br>
17 Numbers
<br>

<br>
• +value
<br>
• parseFloat(value) (avoid; different than the other two!)
<br>
Recommendation: use the descriptive Number(). Tbl. 17.4 summarizes how it works.
<br>
Table 17.4: Converting values to numbers.
<br>
x
<br>

<br>
Number(x)
<br>

<br>
undefined
<br>

<br>
NaN
<br>

<br>
null
<br>

<br>
0
<br>

<br>
boolean
<br>
number
<br>
string
<br>

<br>
false → 0, true → 1
<br>

<br>
object
<br>

<br>
x (no change)
<br>
'' → 0
<br>

<br>
other → parsed number, ignoring leading/trailing whitespace
<br>
conﬁgurable (e.g. via .valueOf())
<br>

<br>
Examples:
<br>
assert.equal(Number(123.45), 123.45);
<br>
assert.equal(Number(''), 0);
<br>
assert.equal(Number('\n 123.45 \t'), 123.45);
<br>
assert.equal(Number('xyz'), NaN);
<br>

<br>
How objects are converted to numbers can be conﬁgured – for example, by overriding
<br>
.valueOf():
<br>
> Number({ valueOf() { return 123 } })
<br>
123
<br>

<br>
Exercise: Converting to number
<br>
exercises/numbers-math/parse_number_test.mjs
<br>

<br>
17.5 Error values
<br>
Two number values are returned when errors happen:
<br>
• NaN
<br>
• Infinity
<br>

<br>
17.6 Error value: NaN
<br>
NaN is an abbreviation of “not a number”. Ironically, JavaScript considers it to be a num-
<br>

<br>
ber:
<br>
> typeof NaN
<br>
'number'
<br>

<br>
17.6 Error value: NaN
<br>

<br>
When is NaN returned?
<br>
NaN is returned if a number can’t be parsed:
<br>
> Number('$$$')
<br>
NaN
<br>
> Number(undefined)
<br>
NaN
<br>
NaN is returned if an operation can’t be performed:
<br>
> Math.log(-1)
<br>
NaN
<br>
> Math.sqrt(-1)
<br>
NaN
<br>
NaN is returned if an operand or argument is NaN (to propagate errors):
<br>
> NaN - 3
<br>
NaN
<br>
> 7 ** NaN
<br>
NaN
<br>

<br>
17.6.1 Checking for NaN
<br>
NaN is the only JavaScript value that is not strictly equal to itself:
<br>
const n = NaN;
<br>
assert.equal(n === n, false);
<br>

<br>
These are several ways of checking if a value x is NaN:
<br>
const x = NaN;
<br>
assert.equal(Number.isNaN(x), true); // preferred
<br>
assert.equal(Object.is(x, NaN), true);
<br>
assert.equal(x !== x, true);
<br>

<br>
In the last line, we use the comparison quirk to detect NaN.
<br>

<br>
17.6.2 Finding NaN in Arrays
<br>
Some Array methods can’t ﬁnd NaN:
<br>
> [NaN].indexOf(NaN)
<br>
-1
<br>

<br>
Others can:
<br>
> [NaN].includes(NaN)
<br>
true
<br>
> [NaN].findIndex(x => Number.isNaN(x))
<br>
0
<br>
> [NaN].find(x => Number.isNaN(x))
<br>
NaN
<br>

<br>
127
<br>

<br>
128
<br>

<br>
17 Numbers
<br>

<br>
Alas, there is no simple rule of thumb. You have to check for each method how it handles
<br>
NaN.
<br>

<br>
17.7 Error value: Infinity
<br>
When is the error value Infinity returned?
<br>
Inﬁnity is returned if a number is too large:
<br>
> Math.pow(2, 1023)
<br>
8.98846567431158e+307
<br>
> Math.pow(2, 1024)
<br>
Infinity
<br>

<br>
Inﬁnity is returned if there is a division by zero:
<br>
> 5 / 0
<br>
Infinity
<br>
> -5 / 0
<br>
-Infinity
<br>

<br>
17.7.1
<br>

<br>
Infinity as a default value
<br>

<br>
Infinity is larger than all other numbers (except NaN), making it a good default value:
<br>
function findMinimum(numbers) {
<br>
let min = Infinity;
<br>
for (const n of numbers) {
<br>
if (n < min) min = n;
<br>
}
<br>
return min;
<br>
}
<br>
assert.equal(findMinimum([5, -1, 2]), -1);
<br>
assert.equal(findMinimum([]), Infinity);
<br>

<br>
17.7.2 Checking for Infinity
<br>
These are two common ways of checking if a value x is Infinity:
<br>
const x = Infinity;
<br>
assert.equal(x === Infinity, true);
<br>
assert.equal(Number.isFinite(x), false);
<br>

<br>
Exercise: Comparing numbers
<br>
exercises/numbers-math/find_max_test.mjs
<br>

<br>
129
<br>

<br>
17.10 Background: ﬂoating point precision
<br>

<br>
17.8 The precision of numbers: careful with decimal fractions
<br>
Internally, JavaScript ﬂoating point numbers are represented with base 2 (according to
<br>
the IEEE 754 standard). That means that decimal fractions (base 10) can’t always be represented precisely:
<br>
> 0.1 + 0.2
<br>
0.30000000000000004
<br>
> 1.3 * 3
<br>
3.9000000000000004
<br>
> 1.4 * 100000000000000
<br>
139999999999999.98
<br>

<br>
You therefore need to take rounding errors into consideration when performing arithmetic in JavaScript.
<br>
Read on for an explanation of this phenomenon.
<br>

<br>
Quiz: basic
<br>
See quiz app.
<br>

<br>
17.9 (Advanced)
<br>
All remaining sections of this chapter are advanced.
<br>

<br>
17.10 Background: ﬂoating point precision
<br>
In JavaScript, computations with numbers don’t always produce correct results – for example:
<br>
> 0.1 + 0.2
<br>
0.30000000000000004
<br>

<br>
To understand why, we need to explore how JavaScript represents ﬂoating point numbers
<br>
internally. It uses three integers to do so, which take up a total of 64 bits of storage (double
<br>
precision):
<br>
Component
<br>

<br>
Size
<br>

<br>
Integer range
<br>

<br>
Sign
<br>
Fraction
<br>
Exponent
<br>

<br>
1 bit
<br>
52 bits
<br>
11 bits
<br>

<br>
[0, 1]
<br>
[0, 252 −1]
<br>
[−1023, 1024]
<br>

<br>
The ﬂoating point number represented by these integers is computed as follows:
<br>
(–1)sign × 0b1.fraction × 2exponent
<br>

<br>
130
<br>

<br>
17 Numbers
<br>

<br>
This representation can’t encode a zero because its second component (involving the fraction) always has a leading 1. Therefore, a zero is encoded via the special exponent −1023
<br>
and a fraction 0.
<br>

<br>
17.10.1 A simpliﬁed representation of ﬂoating point numbers
<br>
To make further discussions easier, we simplify the previous representation:
<br>
• Instead of base 2 (binary), we use base 10 (decimal) because that’s what most people are more familiar with.
<br>
• The fraction is a natural number that is interpreted as a fraction (digits after a point).
<br>
We switch to a mantissa, an integer that is interpreted as itself. As a consequence,
<br>
the exponent is used differently, but its fundamental role doesn’t change.
<br>
• As the mantissa is an integer (with its own sign), we don’t need a separate sign,
<br>
anymore.
<br>
The new representation works like this:
<br>
mantissa × 10exponent
<br>
Let’s try out this representation for a few ﬂoating point numbers.
<br>
• For the integer −123, we mainly need the mantissa:
<br>
> -123 * (10 ** 0)
<br>
-123
<br>

<br>
• For the number 1.5, we imagine there being a point after the mantissa. We use a
<br>
negative exponent to move that point one digit to the left:
<br>
> 15 * (10 ** -1)
<br>
1.5
<br>

<br>
• For the number 0.25, we move the point two digits to the left:
<br>
> 25 * (10 ** -2)
<br>
0.25
<br>

<br>
Representations with negative exponents can also be written as fractions with positive
<br>
exponents in the denominators:
<br>
> 15 * (10 ** -1) === 15 / (10 ** 1)
<br>
true
<br>
> 25 * (10 ** -2) === 25 / (10 ** 2)
<br>
true
<br>

<br>
These fractions help with understanding why there are numbers that our encoding cannot represent:
<br>
• 1/10 can be represented. It already has the required format: a power of 10 in the
<br>
denominator.
<br>
• 1/2 can be represented as 5/10. We turned the 2 in the denominator into a power
<br>
of 10 by multiplying the numerator and denominator by 5.
<br>

<br>
17.11 Integers in JavaScript
<br>

<br>
131
<br>

<br>
• 1/4 can be represented as 25/100. We turned the 4 in the denominator into a power
<br>
of 10 by multiplying the numerator and denominator by 25.
<br>
• 1/3 cannot be represented. There is no way to turn the denominator into a power
<br>
of 10. (The prime factors of 10 are 2 and 5. Therefore, any denominator that only
<br>
has these prime factors can be converted to a power of 10, by multiplying both the
<br>
numerator and denominator by enough twos and ﬁves. If a denominator has a
<br>
different prime factor, then there’s nothing we can do.)
<br>
To conclude our excursion, we switch back to base 2:
<br>
• 0.5 = 1/2 can be represented with base 2 because the denominator is already a
<br>
power of 2.
<br>
• 0.25 = 1/4 can be represented with base 2 because the denominator is already a
<br>
power of 2.
<br>
• 0.1 = 1/10 cannot be represented because the denominator cannot be converted
<br>
to a power of 2.
<br>
• 0.2 = 2/10 cannot be represented because the denominator cannot be converted
<br>
to a power of 2.
<br>
Now we can see why 0.1 + 0.2 doesn’t produce a correct result: internally, neither of
<br>
the two operands can be represented precisely.
<br>
The only way to compute precisely with decimal fractions is by internally switching to
<br>
base 10. For many programming languages, base 2 is the default and base 10 an option.
<br>
For example, Java has the class BigDecimal and Python has the module decimal. There
<br>
are tentative plans to add something similar to JavaScript: the ECMAScript proposal
<br>
“Decimal” is currently at stage 0.
<br>

<br>
17.11 Integers in JavaScript
<br>
JavaScript doesn’t have a special type for integers. Instead, they are simply normal (ﬂoating point) numbers without a decimal fraction:
<br>
> 1 === 1.0
<br>
true
<br>
> Number.isInteger(1.0)
<br>
true
<br>

<br>
In this section, we’ll look at a few tools for working with these pseudo-integers.
<br>

<br>
17.11.1 Converting to integer
<br>
The recommended way of converting numbers to integers is to use one of the rounding
<br>
methods of the Math object:
<br>
• Math.floor(n): returns the largest integer i ≤ n
<br>
> Math.floor(2.1)
<br>
2
<br>
> Math.floor(2.9)
<br>
2
<br>

<br>
132
<br>

<br>
17 Numbers
<br>

<br>
• Math.ceil(n): returns the smallest integer i ≥ n
<br>
> Math.ceil(2.1)
<br>
3
<br>
> Math.ceil(2.9)
<br>
3
<br>

<br>
• Math.round(n): returns the integer that is “closest” to n with __.5 being rounded
<br>
up – for example:
<br>
> Math.round(2.4)
<br>
2
<br>
> Math.round(2.5)
<br>
3
<br>

<br>
• Math.trunc(n): removes any decimal fraction (after the point) that n has, therefore
<br>
turning it into an integer.
<br>
> Math.trunc(2.1)
<br>
2
<br>
> Math.trunc(2.9)
<br>
2
<br>

<br>
For more information on rounding, consult §18.3 “Rounding”.
<br>

<br>
17.11.2 Ranges of integers in JavaScript
<br>
These are important ranges of integers in JavaScript:
<br>
• Safe integers: can be represented “safely” by JavaScript (more on what that means
<br>
in the next subsection)
<br>
– Precision: 53 bits plus sign
<br>
– Range: (−253 , 253 )
<br>
• Array indices
<br>
– Precision: 32 bits, unsigned
<br>
– Range: [0, 232 −1) (excluding the maximum length)
<br>
– Typed Arrays have a larger range of 53 bits (safe and unsigned)
<br>
• Bitwise operators (bitwise Or, etc.)
<br>
– Precision: 32 bits
<br>
– Range of unsigned right shift (>>>): unsigned, [0, 232 )
<br>
– Range of all other bitwise operators: signed, [−231 , 231 )
<br>

<br>
17.11.3 Safe integers
<br>
This is the range of integers that are safe in JavaScript (53 bits plus a sign):
<br>
[–253 –1, 253 –1]
<br>
An integer is safe if it is represented by exactly one JavaScript number. Given that
<br>
JavaScript numbers are encoded as a fraction multiplied by 2 to the power of an
<br>
exponent, higher integers can also be represented, but then there are gaps between them.
<br>
For example (18014398509481984 is 254 ):
<br>

<br>
17.12 Bitwise operators
<br>

<br>
133
<br>

<br>
> 18014398509481984
<br>
18014398509481984
<br>
> 18014398509481985
<br>
18014398509481984
<br>
> 18014398509481986
<br>
18014398509481984
<br>
> 18014398509481987
<br>
18014398509481988
<br>

<br>
The following properties of Number help determine if an integer is safe:
<br>
assert.equal(Number.MAX_SAFE_INTEGER, (2 ** 53) - 1);
<br>
assert.equal(Number.MIN_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER);
<br>
assert.equal(Number.isSafeInteger(5), true);
<br>
assert.equal(Number.isSafeInteger('5'), false);
<br>
assert.equal(Number.isSafeInteger(5.1), false);
<br>
assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER), true);
<br>
assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1), false);
<br>

<br>
Exercise: Detecting safe integers
<br>
exercises/numbers-math/is_safe_integer_test.mjs
<br>

<br>
17.11.3.1 Safe computations
<br>
Let’s look at computations involving unsafe integers.
<br>
The following result is incorrect and unsafe, even though both of its operands are safe:
<br>
> 9007199254740990 + 3
<br>
9007199254740992
<br>

<br>
The following result is safe, but incorrect. The ﬁrst operand is unsafe; the second operand
<br>
is safe:
<br>
> 9007199254740995 - 10
<br>
9007199254740986
<br>

<br>
Therefore, the result of an expression a op b is correct if and only if:
<br>
isSafeInteger(a) && isSafeInteger(b) && isSafeInteger(a op b)
<br>

<br>
That is, both operands and the result must be safe.
<br>

<br>
17.12 Bitwise operators
<br>
17.12.1 Internally, bitwise operators work with 32-bit integers
<br>
Internally, JavaScript’s bitwise operators work with 32-bit integers. They produce their
<br>
results in the following steps:
<br>

<br>
134
<br>

<br>
17 Numbers
<br>

<br>
• Input (JavaScript numbers): The 1–2 operands are ﬁrst converted to JavaScript
<br>
numbers (64-bit ﬂoating point numbers) and then to 32-bit integers.
<br>
• Computation (32-bit integers): The actual operation processes 32-bit integers and
<br>
produces a 32-bit integer.
<br>
• Output (JavaScript number): Before returning the result, it is converted back to a
<br>
JavaScript number.
<br>
17.12.1.1 The types of operands and results
<br>
For each bitwise operator, this book mentions the types of its operands and its result.
<br>
Each type is always one of the following two:
<br>
Type
<br>

<br>
Description
<br>

<br>
Size
<br>

<br>
Range
<br>

<br>
Int32
<br>
Uint32
<br>

<br>
signed 32-bit integer
<br>
unsigned 32-bit integer
<br>

<br>
32 bits incl. sign
<br>
32 bits
<br>

<br>
[−231 , 231 )
<br>
[0, 232 )
<br>

<br>
Considering the previously mentioned steps, I recommend to pretend that bitwise operators internally work with unsigned 32-bit integers (step “computation”) and that Int32
<br>
and Uint32 only affect how JavaScript numbers are converted to and from integers (steps
<br>
“input” and “output”).
<br>
17.12.1.2 Displaying JavaScript numbers as unsigned 32-bit integers
<br>
While exploring the bitwise operators, it occasionally helps to display JavaScript numbers
<br>
as unsigned 32-bit integers in binary notation. That’s what b32() does (whose implementation is shown later):
<br>
assert.equal(
<br>
b32(-1),
<br>
'11111111111111111111111111111111');
<br>
assert.equal(
<br>
b32(1),
<br>
'00000000000000000000000000000001');
<br>
assert.equal(
<br>
b32(2 ** 31),
<br>
'10000000000000000000000000000000');
<br>

<br>
17.12.2 Binary bitwise operators
<br>
Table 17.7: Binary bitwise operators.
<br>
Operation
<br>

<br>
Name
<br>

<br>
Type signature
<br>

<br>
num1 & num2
<br>

<br>
Bitwise And
<br>
Bitwise Or
<br>
Bitwise Xor
<br>

<br>
Int32 × Int32 → Int32
<br>
Int32 × Int32 → Int32
<br>
Int32 × Int32 → Int32
<br>

<br>
num1 ¦ num2
<br>
num1 ^ num2
<br>

<br>
ES1
<br>
ES1
<br>
ES1
<br>

<br>
135
<br>

<br>
17.12 Bitwise operators
<br>

<br>
The binary bitwise operators (tbl. 17.7) combine the bits of their operands to produce
<br>
their results:
<br>
> (0b1010 & 0b0011).toString(2).padStart(4, '0')
<br>
'0010'
<br>
> (0b1010 | 0b0011).toString(2).padStart(4, '0')
<br>
'1011'
<br>
> (0b1010 ^ 0b0011).toString(2).padStart(4, '0')
<br>
'1001'
<br>

<br>
17.12.3 Bitwise Not
<br>
Table 17.8: The bitwise Not operator.
<br>
Operation
<br>

<br>
Name
<br>

<br>
Type signature
<br>

<br>
~num
<br>

<br>
Bitwise Not, ones’ complement
<br>

<br>
Int32 → Int32
<br>

<br>
ES1
<br>

<br>
The bitwise Not operator (tbl. 17.8) inverts each binary digit of its operand:
<br>
> b32(~0b100)
<br>
'11111111111111111111111111111011'
<br>

<br>
17.12.4 Bitwise shift operators
<br>
Table 17.9: Bitwise shift operators.
<br>
Operation
<br>

<br>
Name
<br>

<br>
Type signature
<br>

<br>
num << count
<br>

<br>
Left shift
<br>
Signed right shift
<br>
Unsigned right shift
<br>

<br>
Int32 × Uint32 → Int32
<br>
Int32 × Uint32 → Int32
<br>
Uint32 × Uint32 → Uint32
<br>

<br>
num >> count
<br>
num >>> count
<br>

<br>
ES1
<br>
ES1
<br>
ES1
<br>

<br>
The shift operators (tbl. 17.9) move binary digits to the left or to the right:
<br>
> (0b10 << 1).toString(2)
<br>
'100'
<br>
>> preserves highest bit, >>> doesn’t:
<br>
> b32(0b10000000000000000000000000000010 >> 1)
<br>
'11000000000000000000000000000001'
<br>
> b32(0b10000000000000000000000000000010 >>> 1)
<br>
'01000000000000000000000000000001'
<br>

<br>
17.12.5 b32(): displaying unsigned 32-bit integers in binary notation
<br>
We have now used b32() a few times. The following code is an implementation of it:
<br>

<br>
136
<br>

<br>
17 Numbers
<br>

<br>
/**
<br>
* Return a string representing n as a 32-bit unsigned integer,
<br>
* in binary notation.
<br>
*/
<br>
function b32(n) {
<br>
// >>> ensures highest bit isn’t interpreted as a sign
<br>
return (n >>> 0).toString(2).padStart(32, '0');
<br>
}
<br>
assert.equal(
<br>
b32(6),
<br>
'00000000000000000000000000000110');
<br>
n >>> 0 means that we are shifting n zero bits to the right. Therefore, in principle, the
<br>
>>> operator does nothing, but it still coerces n to an unsigned 32-bit integer:
<br>
> 12 >>> 0
<br>
12
<br>
> -12 >>> 0
<br>
4294967284
<br>
> (2**32 + 1) >>> 0
<br>
1
<br>

<br>
17.13 Quick reference: numbers
<br>
17.13.1 Global functions for numbers
<br>
JavaScript has the following four global functions for numbers:
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
isFinite()
<br>
isNaN()
<br>
parseFloat()
<br>
parseInt()
<br>

<br>
However, it is better to use the corresponding methods of Number (Number.isFinite(),
<br>
etc.), which have fewer pitfalls. They were introduced with ES6 and are discussed below.
<br>

<br>
17.13.2 Static properties of Number
<br>
• .EPSILON: number [ES6]
<br>
The difference between 1 and the next representable ﬂoating point number. In
<br>
general, a machine epsilon provides an upper bound for rounding errors in ﬂoating
<br>
point arithmetic.
<br>
– Approximately: 2.2204460492503130808472633361816 × 10-16
<br>
• .MAX_SAFE_INTEGER: number [ES6]
<br>
The largest integer that JavaScript can represent unambiguously (253 −1).
<br>
• .MAX_VALUE: number [ES1]
<br>
The largest positive ﬁnite JavaScript number.
<br>

<br>
17.13 Quick reference: numbers
<br>

<br>
137
<br>

<br>
– Approximately: 1.7976931348623157 × 10308
<br>
• .MIN_SAFE_INTEGER: number [ES6]
<br>
The smallest integer that JavaScript can represent unambiguously (−253 +1).
<br>
• .MIN_VALUE: number [ES1]
<br>
The smallest positive JavaScript number. Approximately 5 × 10−324 .
<br>
• .NaN: number [ES1]
<br>
The same as the global variable NaN.
<br>
• .NEGATIVE_INFINITY: number [ES1]
<br>
The same as -Number.POSITIVE_INFINITY.
<br>
• .POSITIVE_INFINITY: number [ES1]
<br>
The same as the global variable Infinity.
<br>

<br>
17.13.3 Static methods of Number
<br>
• .isFinite(num: number): boolean [ES6]
<br>
Returns true if num is an actual number (neither Infinity nor -Infinity nor NaN).
<br>
> Number.isFinite(Infinity)
<br>
false
<br>
> Number.isFinite(-Infinity)
<br>
false
<br>
> Number.isFinite(NaN)
<br>
false
<br>
> Number.isFinite(123)
<br>
true
<br>

<br>
• .isInteger(num: number): boolean [ES6]
<br>
Returns true if num is a number and does not have a decimal fraction.
<br>
> Number.isInteger(-17)
<br>
true
<br>
> Number.isInteger(33)
<br>
true
<br>
> Number.isInteger(33.1)
<br>
false
<br>
> Number.isInteger('33')
<br>
false
<br>
> Number.isInteger(NaN)
<br>
false
<br>
> Number.isInteger(Infinity)
<br>
false
<br>

<br>
• .isNaN(num: number): boolean [ES6]
<br>
Returns true if num is the value NaN:
<br>

<br>
138
<br>

<br>
17 Numbers
<br>
> Number.isNaN(NaN)
<br>
true
<br>
> Number.isNaN(123)
<br>
false
<br>
> Number.isNaN('abc')
<br>
false
<br>

<br>
• .isSafeInteger(num: number): boolean [ES6]
<br>
Returns true if num is a number and unambiguously represents an integer.
<br>
• .parseFloat(str: string): number [ES6]
<br>
Coerces its parameter to string and parses it as a ﬂoating point number. For converting strings to numbers, Number() (which ignores leading and trailing whitespace) is usually a better choice than Number.parseFloat() (which ignores leading
<br>
whitespace and illegal trailing characters and can hide problems).
<br>
> Number.parseFloat(' 123.4#')
<br>
123.4
<br>
> Number(' 123.4#')
<br>
NaN
<br>

<br>
• .parseInt(str: string, radix=10): number [ES6]
<br>
Coerces its parameter to string and parses it as an integer, ignoring leading whitespace and illegal trailing characters:
<br>
> Number.parseInt('
<br>

<br>
123#')
<br>

<br>
123
<br>

<br>
The parameter radix speciﬁes the base of the number to be parsed:
<br>
> Number.parseInt('101', 2)
<br>
5
<br>
> Number.parseInt('FF', 16)
<br>
255
<br>

<br>
Do not use this method to convert numbers to integers: coercing to string is inefﬁcient. And stopping before the ﬁrst non-digit is not a good algorithm for removing
<br>
the fraction of a number. Here is an example where it goes wrong:
<br>
> Number.parseInt(1e21, 10) // wrong
<br>
1
<br>

<br>
It is better to use one of the rounding functions of Math to convert a number to an
<br>
integer:
<br>
> Math.trunc(1e21) // correct
<br>
1e+21
<br>

<br>
17.13.4 Methods of Number.prototype
<br>
(Number.prototype is where the methods of numbers are stored.)
<br>

<br>
139
<br>

<br>
17.13 Quick reference: numbers
<br>

<br>
• .toExponential(fractionDigits?: number): string [ES3]
<br>
Returns a string that represents the number via exponential notation. With fractionDigits, you can specify, how many digits should be shown of the number that
<br>
is multiplied with the exponent (the default is to show as many digits as necessary).
<br>
Example: number too small to get a positive exponent via .toString().
<br>
> 1234..toString()
<br>
'1234'
<br>
> 1234..toExponential() // 3 fraction digits
<br>
'1.234e+3'
<br>
> 1234..toExponential(5)
<br>
'1.23400e+3'
<br>
> 1234..toExponential(1)
<br>
'1.2e+3'
<br>

<br>
Example: fraction not small enough to get a negative exponent via .toString().
<br>
> 0.003.toString()
<br>
'0.003'
<br>
> 0.003.toExponential()
<br>
'3e-3'
<br>

<br>
• .toFixed(fractionDigits=0): string [ES3]
<br>
Returns an exponent-free representation of the number, rounded to fractionDigits digits.
<br>
> 0.00000012.toString() // with exponent
<br>
'1.2e-7'
<br>
> 0.00000012.toFixed(10) // no exponent
<br>
'0.0000001200'
<br>
> 0.00000012.toFixed()
<br>
'0'
<br>

<br>
If the number is 1021 or greater, even .toFixed() uses an exponent:
<br>
> (10 ** 21).toFixed()
<br>
'1e+21'
<br>

<br>
• .toPrecision(precision?: number): string [ES3]
<br>
Works like .toString(), but precision speciﬁes how many digits should be
<br>
shown. If precision is missing, .toString() is used.
<br>
> 1234..toPrecision(3)
<br>
'1.23e+3'
<br>
> 1234..toPrecision(4)
<br>
'1234'
<br>

<br>
// requires exponential notation
<br>

<br>
140
<br>

<br>
17 Numbers
<br>
> 1234..toPrecision(5)
<br>
'1234.0'
<br>
> 1.234.toPrecision(3)
<br>
'1.23'
<br>

<br>
• .toString(radix=10): string [ES1]
<br>
Returns a string representation of the number.
<br>
By default, you get a base 10 numeral as a result:
<br>
> 123.456.toString()
<br>
'123.456'
<br>

<br>
If you want the numeral to have a different base, you can specify it via radix:
<br>
> 4..toString(2) // binary (base 2)
<br>
'100'
<br>
> 4.5.toString(2)
<br>
'100.1'
<br>
> 255..toString(16) // hexadecimal (base 16)
<br>
'ff'
<br>
> 255.66796875.toString(16)
<br>
'ff.ab'
<br>
> 1234567890..toString(36)
<br>
'kf12oi'
<br>
parseInt() provides the inverse operation: it converts a string that contains an
<br>

<br>
integer (no fraction!) numeral with a given base, to a number.
<br>
> parseInt('kf12oi', 36)
<br>
1234567890
<br>

<br>
17.13.5 Sources
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Wikipedia
<br>
TypeScript’s built-in typings
<br>
MDN web docs for JavaScript
<br>
ECMAScript language speciﬁcation
<br>

<br>
Quiz: advanced
<br>
See quiz app.
<br>

<br>
Chapter 18
<br>

<br>
Math
<br>
Contents
<br>
18.1 Data properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
<br>
18.2 Exponents, roots, logarithms
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . 142
<br>

<br>
18.3 Rounding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
<br>
18.4 Trigonometric Functions . . . . . . . . . . . . . . . . . . . . . . . . . 144
<br>
18.5 Various other functions . . . . . . . . . . . . . . . . . . . . . . . . . 146
<br>
18.6 Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
<br>
Math is an object with data properties and methods for processing numbers. You can see
<br>

<br>
it as a poor man’s module: It was created long before JavaScript had modules.
<br>

<br>
18.1 Data properties
<br>
• Math.E: number [ES1]
<br>
Euler’s number, base of the natural logarithms, approximately 2.7182818284590452354.
<br>
• Math.LN10: number [ES1]
<br>
The natural logarithm of 10, approximately 2.302585092994046.
<br>
• Math.LN2: number [ES1]
<br>
The natural logarithm of 2, approximately 0.6931471805599453.
<br>
• Math.LOG10E: number [ES1]
<br>
The logarithm of e to base 10, approximately 0.4342944819032518.
<br>
• Math.LOG2E: number [ES1]
<br>
The logarithm of e to base 2, approximately 1.4426950408889634.
<br>
• Math.PI: number [ES1]
<br>
141
<br>

<br>
142
<br>

<br>
18 Math
<br>

<br>
The mathematical constant π, ratio of a circle’s circumference to its diameter, approximately 3.1415926535897932.
<br>
• Math.SQRT1_2: number [ES1]
<br>
The square root of 1/2, approximately 0.7071067811865476.
<br>
• Math.SQRT2: number [ES1]
<br>
The square root of 2, approximately 1.4142135623730951.
<br>

<br>
18.2 Exponents, roots, logarithms
<br>
• Math.cbrt(x: number): number [ES6]
<br>
Returns the cube root of x.
<br>
> Math.cbrt(8)
<br>
2
<br>

<br>
• Math.exp(x: number): number [ES1]
<br>
Returns ex (e being Euler’s number). The inverse of Math.log().
<br>
> Math.exp(0)
<br>
1
<br>
> Math.exp(1) === Math.E
<br>
true
<br>

<br>
• Math.expm1(x: number): number [ES6]
<br>
Returns Math.exp(x)-1. The inverse of Math.log1p(). Very small numbers (fractions close to 0) are represented with a higher precision. Therefore, this function
<br>
returns more precise values whenever .exp() returns values close to 1.
<br>
• Math.log(x: number): number [ES1]
<br>
Returns the natural logarithm of x (to base e, Euler’s number). The inverse of
<br>
Math.exp().
<br>
> Math.log(1)
<br>
0
<br>
> Math.log(Math.E)
<br>
1
<br>
> Math.log(Math.E ** 2)
<br>
2
<br>

<br>
• Math.log1p(x: number): number [ES6]
<br>
Returns Math.log(1 + x). The inverse of Math.expm1(). Very small numbers
<br>
(fractions close to 0) are represented with a higher precision. Therefore, you can
<br>
provide this function with a more precise argument whenever the argument for
<br>
.log() is close to 1.
<br>
• Math.log10(x: number): number [ES6]
<br>

<br>
18.3 Rounding
<br>

<br>
143
<br>

<br>
Returns the logarithm of x to base 10. The inverse of 10 ** x.
<br>
> Math.log10(1)
<br>
0
<br>
> Math.log10(10)
<br>
1
<br>
> Math.log10(100)
<br>
2
<br>

<br>
• Math.log2(x: number): number [ES6]
<br>
Returns the logarithm of x to base 2. The inverse of 2 ** x.
<br>
> Math.log2(1)
<br>
0
<br>
> Math.log2(2)
<br>
1
<br>
> Math.log2(4)
<br>
2
<br>

<br>
• Math.pow(x: number, y: number): number [ES1]
<br>
Returns xy , x to the power of y. The same as x ** y.
<br>
> Math.pow(2, 3)
<br>
8
<br>
> Math.pow(25, 0.5)
<br>
5
<br>

<br>
• Math.sqrt(x: number): number [ES1]
<br>
Returns the square root of x. The inverse of x ** 2.
<br>
> Math.sqrt(9)
<br>
3
<br>

<br>
18.3 Rounding
<br>
Rounding means converting an arbitrary number to an integer (a number without a decimal fraction). The following functions implement different approaches to rounding.
<br>
• Math.ceil(x: number): number [ES1]
<br>
Returns the smallest (closest to −∞) integer i with x ≤ i.
<br>
> Math.ceil(2.1)
<br>
3
<br>
> Math.ceil(2.9)
<br>
3
<br>

<br>
• Math.floor(x: number): number [ES1]
<br>
Returns the largest (closest to +∞) integer i with i ≤ x.
<br>

<br>
144
<br>

<br>
18 Math
<br>
> Math.floor(2.1)
<br>
2
<br>
> Math.floor(2.9)
<br>
2
<br>

<br>
• Math.round(x: number): number [ES1]
<br>
Returns the integer that is closest to x. If the decimal fraction of x is .5 then
<br>
.round() rounds up (to the integer closer to positive inﬁnity):
<br>
> Math.round(2.4)
<br>
2
<br>
> Math.round(2.5)
<br>
3
<br>

<br>
• Math.trunc(x: number): number [ES6]
<br>
Removes the decimal fraction of x and returns the resulting integer.
<br>
> Math.trunc(2.1)
<br>
2
<br>
> Math.trunc(2.9)
<br>
2
<br>

<br>
Tbl. 18.1 shows the results of the rounding functions for a few representative inputs.
<br>
Table 18.1: Rounding functions of Math. Note how things change with
<br>
negative numbers because “larger” always means “closer to positive inﬁnity”.
<br>
-2.9
<br>

<br>
-2.5
<br>

<br>
-2.1
<br>

<br>
2.1
<br>

<br>
2.5
<br>

<br>
2.9
<br>

<br>
Math.floor
<br>

<br>
-3
<br>

<br>
-3
<br>

<br>
-3
<br>

<br>
2
<br>

<br>
2
<br>

<br>
2
<br>

<br>
Math.ceil
<br>

<br>
-2
<br>

<br>
-2
<br>

<br>
-2
<br>

<br>
3
<br>

<br>
3
<br>

<br>
3
<br>

<br>
Math.round
<br>

<br>
-3
<br>

<br>
-2
<br>

<br>
-2
<br>

<br>
2
<br>

<br>
3
<br>

<br>
3
<br>

<br>
Math.trunc
<br>

<br>
-2
<br>

<br>
-2
<br>

<br>
-2
<br>

<br>
2
<br>

<br>
2
<br>

<br>
2
<br>

<br>
18.4 Trigonometric Functions
<br>
All angles are speciﬁed in radians. Use the following two functions to convert between
<br>
degrees and radians.
<br>
function degreesToRadians(degrees) {
<br>
return degrees / 180 * Math.PI;
<br>
}
<br>
assert.equal(degreesToRadians(90), Math.PI/2);
<br>
function radiansToDegrees(radians) {
<br>
return radians / Math.PI * 180;
<br>
}
<br>
assert.equal(radiansToDegrees(Math.PI), 180);
<br>

<br>
18.4 Trigonometric Functions
<br>

<br>
145
<br>

<br>
• Math.acos(x: number): number [ES1]
<br>
Returns the arc cosine (inverse cosine) of x.
<br>
> Math.acos(0)
<br>
1.5707963267948966
<br>
> Math.acos(1)
<br>
0
<br>

<br>
• Math.acosh(x: number): number [ES6]
<br>
Returns the inverse hyperbolic cosine of x.
<br>
• Math.asin(x: number): number [ES1]
<br>
Returns the arc sine (inverse sine) of x.
<br>
> Math.asin(0)
<br>
0
<br>
> Math.asin(1)
<br>
1.5707963267948966
<br>

<br>
• Math.asinh(x: number): number [ES6]
<br>
Returns the inverse hyperbolic sine of x.
<br>
• Math.atan(x: number): number [ES1]
<br>
Returns the arc tangent (inverse tangent) of x.
<br>
• Math.atanh(x: number): number [ES6]
<br>
Returns the inverse hyperbolic tangent of x.
<br>
• Math.atan2(y: number, x: number): number [ES1]
<br>
Returns the arc tangent of the quotient y/x.
<br>
• Math.cos(x: number): number [ES1]
<br>
Returns the cosine of x.
<br>
> Math.cos(0)
<br>
1
<br>
> Math.cos(Math.PI)
<br>
-1
<br>

<br>
• Math.cosh(x: number): number [ES6]
<br>
Returns the hyperbolic cosine of x.
<br>
• Math.hypot(...values: number[]): number [ES6]
<br>
Returns the square root of the sum of the squares of values (Pythagoras’ theorem):
<br>
> Math.hypot(3, 4)
<br>
5
<br>

<br>
146
<br>

<br>
18 Math
<br>

<br>
• Math.sin(x: number): number [ES1]
<br>
Returns the sine of x.
<br>
> Math.sin(0)
<br>
0
<br>
> Math.sin(Math.PI / 2)
<br>
1
<br>

<br>
• Math.sinh(x: number): number [ES6]
<br>
Returns the hyperbolic sine of x.
<br>
• Math.tan(x: number): number [ES1]
<br>
Returns the tangent of x.
<br>
> Math.tan(0)
<br>
0
<br>
> Math.tan(1)
<br>
1.5574077246549023
<br>

<br>
• Math.tanh(x: number): number; [ES6]
<br>
Returns the hyperbolic tangent of x.
<br>

<br>
18.5 Various other functions
<br>
• Math.abs(x: number): number [ES1]
<br>
Returns the absolute value of x.
<br>
> Math.abs(3)
<br>
3
<br>
> Math.abs(-3)
<br>
3
<br>
> Math.abs(0)
<br>
0
<br>

<br>
• Math.clz32(x: number): number [ES6]
<br>
Counts the leading zero bits in the 32-bit integer x. Used in DSP algorithms.
<br>
> Math.clz32(0b01000000000000000000000000000000)
<br>
1
<br>
> Math.clz32(0b00100000000000000000000000000000)
<br>
2
<br>
> Math.clz32(2)
<br>
30
<br>
> Math.clz32(1)
<br>
31
<br>

<br>
• Math.max(...values: number[]): number [ES1]
<br>
Converts values to numbers and returns the largest one.
<br>

<br>
147
<br>

<br>
18.6 Sources
<br>
> Math.max(3, -5, 24)
<br>
24
<br>

<br>
• Math.min(...values: number[]): number [ES1]
<br>
Converts values to numbers and returns the smallest one.
<br>
> Math.min(3, -5, 24)
<br>
-5
<br>

<br>
• Math.random(): number [ES1]
<br>
Returns a pseudo-random number n where 0 ≤ n < 1.
<br>
Computing a random integer i where 0 ≤ i < max:
<br>
function getRandomInteger(max) {
<br>
return Math.floor(Math.random() * max);
<br>
}
<br>

<br>
• Math.sign(x: number): number [ES6]
<br>
Returns the sign of a number:
<br>
> Math.sign(-8)
<br>
-1
<br>
> Math.sign(0)
<br>
0
<br>
> Math.sign(3)
<br>
1
<br>

<br>
18.6 Sources
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Wikipedia
<br>
TypeScript’s built-in typings
<br>
MDN web docs for JavaScript
<br>
ECMAScript language speciﬁcation
<br>

<br>
148
<br>

<br>
18 Math
<br>

<br>
Chapter 19
<br>

<br>
Unicode – a brief introduction
<br>
(advanced)
<br>
Contents
<br>
19.1 Code points vs. code units . . . . . . . . . . . . . . . . . . . . . . . . 149
<br>
19.1.1 Code points . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
<br>
19.1.2 Encoding Unicode code points: UTF-32, UTF-16, UTF-8 . . . . 150
<br>
19.2 Encodings used in web development: UTF-16 and UTF-8 . . . . . . 152
<br>
19.2.1 Source code internally: UTF-16 . . . . . . . . . . . . . . . . . . 152
<br>
19.2.2 Strings: UTF-16 . . . . . . . . . . . . . . . . . . . . . . . . . . 152
<br>
19.2.3 Source code in ﬁles: UTF-8 . . . . . . . . . . . . . . . . . . . . 152
<br>
19.3 Grapheme clusters – the real characters . . . . . . . . . . . . . . . . 152
<br>

<br>
Unicode is a standard for representing and managing text in most of the world’s writing
<br>
systems. Virtually all modern software that works with text, supports Unicode. The
<br>
standard is maintained by the Unicode Consortium. A new version of the standard is
<br>
published every year (with new emojis, etc.). Unicode version 1.0.0 was published in
<br>
October 1991.
<br>

<br>
19.1 Code points vs. code units
<br>
Two concepts are crucial for understanding Unicode:
<br>
• Code points are numbers that represent Unicode characters.
<br>
• Code units are numbers that encode code points, to store or transmit Unicode text.
<br>
One or more code units encode a single code point. Each code unit has the same
<br>
size, which depends on the encoding format that is used. The most popular format,
<br>
UTF-8, has 8-bit code units.
<br>
149
<br>

<br>
150
<br>

<br>
19 Unicode – a brief introduction (advanced)
<br>

<br>
19.1.1 Code points
<br>
The ﬁrst version of Unicode had 16-bit code points. Since then, the number of characters
<br>
has grown considerably and the size of code points was extended to 21 bits. These 21 bits
<br>
are partitioned in 17 planes, with 16 bits each:
<br>
• Plane 0: Basic Multilingual Plane (BMP), 0x0000–0xFFFF
<br>
– Contains characters for almost all modern languages (Latin characters, Asian
<br>
characters, etc.) and many symbols.
<br>
• Plane 1: Supplementary Multilingual Plane (SMP), 0x10000–0x1FFFF
<br>
– Supports historic writing systems (e.g., Egyptian hieroglyphs and cuneiform)
<br>
and additional modern writing systems.
<br>
– Supports emojis and many other symbols.
<br>
• Plane 2: Supplementary Ideographic Plane (SIP), 0x20000–0x2FFFF
<br>
– Contains additional CJK (Chinese, Japanese, Korean) ideographs.
<br>
• Plane 3–13: Unassigned
<br>
• Plane 14: Supplementary Special-Purpose Plane (SSP), 0xE0000–0xEFFFF
<br>
– Contains non-graphical characters such as tag characters and glyph variation
<br>
selectors.
<br>
• Plane 15–16: Supplementary Private Use Area (S PUA A/B), 0x0F0000–0x10FFFF
<br>
– Available for character assignment by parties outside the ISO and the Unicode Consortium. Not standardized.
<br>
Planes 1-16 are called supplementary planes or astral planes.
<br>
Let’s check the code points of a few characters:
<br>
> 'A'.codePointAt(0).toString(16)
<br>
'41'
<br>
> 'ü'.codePointAt(0).toString(16)
<br>
'fc'
<br>
> 'π'.codePointAt(0).toString(16)
<br>
'3c0'
<br>
> '☺'.codePointAt(0).toString(16)
<br>
'1f642'
<br>

<br>
The hexadecimal numbers of the code points tell us that the ﬁrst three characters reside
<br>
in plane 0 (within 16 bits), while the emoji resides in plane 1.
<br>

<br>
19.1.2 Encoding Unicode code points: UTF-32, UTF-16, UTF-8
<br>
The main ways of encoding code points are three Unicode Transformation Formats (UTFs):
<br>
UTF-32, UTF-16, UTF-8. The number at the end of each format indicates the size (in bits)
<br>
of its code units.
<br>
19.1.2.1 UTF-32 (Unicode Transformation Format 32)
<br>
UTF-32 uses 32 bits to store code units, resulting in one code unit per code point. This
<br>
format is the only one with ﬁxed-length encoding; all others use a varying number of code
<br>
units to encode a single code point.
<br>

<br>
19.1 Code points vs. code units
<br>

<br>
151
<br>

<br>
19.1.2.2 UTF-16 (Unicode Transformation Format 16)
<br>
UTF-16 uses 16-bit code units. It encodes code points as follows:
<br>
• The BMP (ﬁrst 16 bits of Unicode) is stored in single code units.
<br>
• Astral planes: The BMP comprises 0x10_000 code points. Given that Unicode has
<br>
a total of 0x110_000 code points, we still need to encode the remaining 0x100_000
<br>
code points (20 bits). The BMP has two ranges of unassigned code points that
<br>
provide the necessary storage:
<br>
– Most signiﬁcant 10 bits (leading surrogate): 0xD800-0xDBFF
<br>
– Least signiﬁcant 10 bits (trailing surrogate): 0xDC00-0xDFFF
<br>
In other words, the two hexadecimal digits at the end contribute 8 bits. But we can only
<br>
use those 8 bits if a BMP starts with one of the following 2-digit pairs:
<br>
• D8, D9, DA, DB
<br>
• DC, DD, DE, DF
<br>
Per surrogate, we have a choice between 4 pairs, which is where the remaining 2 bits
<br>
come from.
<br>
As a consequence, each UTF-16 code unit is always either a leading surrogate, a trailing
<br>
surrogate, or encodes a BMP code point.
<br>
These are two examples of UTF-16-encoded code points:
<br>
• Code point 0x03C0 (π) is in the BMP and can therefore be represented by a single
<br>
UTF-16 code unit: 0x03C0.
<br>
• Code point 0x1F642 (☺) is in an astral plane and represented by two code units:
<br>
0xD83D and 0xDE42.
<br>
19.1.2.3 UTF-8 (Unicode Transformation Format 8)
<br>
UTF-8 has 8-bit code units. It uses 1–4 code units to encode a code point:
<br>
Code points
<br>

<br>
Code units
<br>

<br>
0000–007F
<br>
0080–07FF
<br>
0800–FFFF
<br>
10000–1FFFFF
<br>

<br>
0bbbbbbb (7 bits)
<br>
110bbbbb, 10bbbbbb (5+6 bits)
<br>
1110bbbb, 10bbbbbb, 10bbbbbb (4+6+6 bits)
<br>
11110bbb, 10bbbbbb, 10bbbbbb, 10bbbbbb (3+6+6+6 bits)
<br>

<br>
Notes:
<br>
• The bit preﬁx of each code unit tells us:
<br>
– Is it ﬁrst in a series of code units? If yes, how many code units will follow?
<br>
– Is it second or later in a series of code units?
<br>
• The character mappings in the 0000–007F range are the same as ASCII, which leads
<br>
to a degree of backward compatibility with older software.
<br>
Three examples:
<br>

<br>
152
<br>

<br>
19 Unicode – a brief introduction (advanced)
<br>

<br>
Character
<br>

<br>
Code point
<br>

<br>
Code units
<br>

<br>
A
<br>
π
<br>

<br>
0x0041
<br>
0x03C0
<br>
0x1F642
<br>

<br>
01000001
<br>
11001111, 10000000
<br>
11110000, 10011111, 10011001, 10000010
<br>

<br>
☺
<br>

<br>
19.2 Encodings used in web development: UTF-16 and
<br>
UTF-8
<br>
The Unicode encoding formats that are used in web development are: UTF-16 and UTF-8.
<br>

<br>
19.2.1 Source code internally: UTF-16
<br>
The ECMAScript speciﬁcation internally represents source code as UTF-16.
<br>

<br>
19.2.2 Strings: UTF-16
<br>
The characters in JavaScript strings are based on UTF-16 code units:
<br>
> const smiley = '☺';
<br>
> smiley.length
<br>
2
<br>
> smiley === '\uD83D\uDE42' // code units
<br>
true
<br>

<br>
For more information on Unicode and strings, consult §20.6 “Atoms of text: Unicode
<br>
characters, JavaScript characters, grapheme clusters”.
<br>

<br>
19.2.3 Source code in ﬁles: UTF-8
<br>
HTML and JavaScript are almost always encoded as UTF-8 these days.
<br>
For example, this is how HTML ﬁles usually start now:
<br>
<!doctype html>
<br>
<html>
<br>
<head>
<br>
<meta charset="UTF-8">
<br>
···
<br>

<br>
For HTML modules loaded in web browsers, the standard encoding is also UTF-8.
<br>

<br>
19.3 Grapheme clusters – the real characters
<br>
The concept of a character becomes remarkably complex once you consider many of the
<br>
world’s writing systems.
<br>
On one hand, there are Unicode characters, as represented by code points.
<br>

<br>
19.3 Grapheme clusters – the real characters
<br>

<br>
153
<br>

<br>
On the other hand, there are grapheme clusters. A grapheme cluster corresponds most
<br>
closely to a symbol displayed on screen or paper. It is deﬁned as “a horizontally segmentable unit of text”. Therefore, ofﬁcial Unicode documents also call it a user-perceived
<br>
character. One or more code point characters are needed to encode a grapheme cluster.
<br>
For example, the Devanagari kshi is encoded by 4 code points. We use spreading (...) to
<br>
split a string into an Array with code point characters (for details, consult §20.6.1 “Working with code points”):
<br>

<br>
Flag emojis are also grapheme clusters and composed of two code point characters – for
<br>
example, the ﬂag of Japan:
<br>

<br>
More information on grapheme clusters
<br>
For more information, consult “Let’s Stop Ascribing Meaning to Code Points” by
<br>
Manish Goregaokar.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
154
<br>

<br>
19 Unicode – a brief introduction (advanced)
<br>

<br>
Chapter 20
<br>

<br>
Strings
<br>
Contents
<br>
20.1 Plain string literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
<br>
20.1.1 Escaping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
<br>
20.2 Accessing characters and code points . . . . . . . . . . . . . . . . . . 156
<br>
20.2.1 Accessing JavaScript characters . . . . . . . . . . . . . . . . . 156
<br>
20.2.2 Accessing Unicode code point characters via for-of and
<br>
spreading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
<br>
20.3 String concatenation via + . . . . . . . . . . . . . . . . . . . . . . . . 157
<br>
20.4 Converting to string . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
<br>
20.4.1 Stringifying objects . . . . . . . . . . . . . . . . . . . . . . . . 158
<br>
20.4.2 Customizing the stringiﬁcation of objects . . . . . . . . . . . . 159
<br>
20.4.3 An alternate way of stringifying values . . . . . . . . . . . . . 159
<br>
20.5 Comparing strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
<br>
20.6 Atoms of text: Unicode characters, JavaScript characters, grapheme
<br>
clusters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
<br>
20.6.1 Working with code points . . . . . . . . . . . . . . . . . . . . 160
<br>
20.6.2 Working with code units (char codes) . . . . . . . . . . . . . . 161
<br>
20.6.3 Caveat: grapheme clusters . . . . . . . . . . . . . . . . . . . . 162
<br>
20.7 Quick reference: Strings . . . . . . . . . . . . . . . . . . . . . . . . . 162
<br>
20.7.1 Converting to string
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . 162
<br>

<br>
20.7.2 Numeric values of characters . . . . . . . . . . . . . . . . . . . 162
<br>
20.7.3 String operators . . . . . . . . . . . . . . . . . . . . . . . . . . 162
<br>
20.7.4 String.prototype: ﬁnding and matching . . . . . . . . . . . . 163
<br>
20.7.5 String.prototype: extracting . . . . . . . . . . . . . . . . . . 165
<br>
20.7.6 String.prototype: combining . . . . . . . . . . . . . . . . . . 166
<br>
20.7.7 String.prototype: transforming . . . . . . . . . . . . . . . . 166
<br>
20.7.8 Sources
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
<br>

<br>
Strings are primitive values in JavaScript and immutable. That is, string-related operations always produce new strings and never change existing strings.
<br>
155
<br>

<br>
156
<br>

<br>
20 Strings
<br>

<br>
20.1 Plain string literals
<br>
Plain string literals are delimited by either single quotes or double quotes:
<br>
const str1 = 'abc';
<br>
const str2 = "abc";
<br>
assert.equal(str1, str2);
<br>

<br>
Single quotes are used more often because it makes it easier to mention HTML, where
<br>
double quotes are preferred.
<br>
The next chapter covers template literals, which give you:
<br>
• String interpolation
<br>
• Multiple lines
<br>
• Raw string literals (backslash has no special meaning)
<br>

<br>
20.1.1 Escaping
<br>
The backslash lets you create special characters:
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Unix line break: '\n'
<br>
Windows line break: '\r\n'
<br>
Tab: '\t'
<br>
Backslash: '\\'
<br>

<br>
The backslash also lets you use the delimiter of a string literal inside that literal:
<br>
assert.equal(
<br>
'She said: "Let\'s go!"',
<br>
"She said: \"Let's go!\"");
<br>

<br>
20.2 Accessing characters and code points
<br>
20.2.1 Accessing JavaScript characters
<br>
JavaScript has no extra data type for characters – characters are always represented as
<br>
strings.
<br>
const str = 'abc';
<br>
// Reading a character at a given index
<br>
assert.equal(str[1], 'b');
<br>
// Counting the characters in a string:
<br>
assert.equal(str.length, 3);
<br>

<br>
20.2.2 Accessing Unicode code point characters via for-of and spreading
<br>
Iterating over strings via for-of or spreading (...) visits Unicode code point characters.
<br>
Each code point character is encoded by 1–2 JavaScript characters. For more information,
<br>

<br>
20.3 String concatenation via +
<br>

<br>
157
<br>

<br>
see §20.6 “Atoms of text: Unicode characters, JavaScript characters, grapheme clusters”.
<br>
This is how you iterate over the code point characters of a string via for-of:
<br>
for (const ch of 'x☺y') {
<br>
console.log(ch);
<br>
}
<br>
// Output:
<br>
// 'x'
<br>
// '☺'
<br>
// 'y'
<br>

<br>
And this is how you convert a string into an Array of code point characters via spreading:
<br>
assert.deepEqual([...'x☺y'], ['x', '☺', 'y']);
<br>

<br>
20.3 String concatenation via +
<br>
If at least one operand is a string, the plus operator (+) converts any non-strings to strings
<br>
and concatenates the result:
<br>
assert.equal(3 + ' times ' + 4, '3 times 4');
<br>

<br>
The assignment operator += is useful if you want to assemble a string, piece by piece:
<br>
let str = ''; // must be `let`!
<br>
str += 'Say it';
<br>
str += ' one more';
<br>
str += ' time';
<br>
assert.equal(str, 'Say it one more time');
<br>

<br>
Concatenating via + is efﬁcient
<br>
Using + to assemble strings is quite efﬁcient because most JavaScript engines internally optimize it.
<br>

<br>
Exercise: Concatenating strings
<br>
exercises/strings/concat_string_array_test.mjs
<br>

<br>
20.4 Converting to string
<br>
These are three ways of converting a value x to a string:
<br>
• String(x)
<br>
• ''+x
<br>
• x.toString() (does not work for undefined and null)
<br>

<br>
158
<br>

<br>
20 Strings
<br>

<br>
Recommendation: use the descriptive and safe String().
<br>
Examples:
<br>
assert.equal(String(undefined), 'undefined');
<br>
assert.equal(String(null), 'null');
<br>
assert.equal(String(false), 'false');
<br>
assert.equal(String(true), 'true');
<br>
assert.equal(String(123.45), '123.45');
<br>

<br>
Pitfall for booleans: If you convert a boolean to a string via String(), you generally can’t
<br>
convert it back via Boolean():
<br>
> String(false)
<br>
'false'
<br>
> Boolean('false')
<br>
true
<br>

<br>
The only string for which Boolean() returns false, is the empty string.
<br>

<br>
20.4.1 Stringifying objects
<br>
Plain objects have a default string representation that is not very useful:
<br>
> String({a: 1})
<br>
'[object Object]'
<br>

<br>
Arrays have a better string representation, but it still hides much information:
<br>
> String(['a', 'b'])
<br>
'a,b'
<br>
> String(['a', ['b']])
<br>
'a,b'
<br>
> String([1, 2])
<br>
'1,2'
<br>
> String(['1', '2'])
<br>
'1,2'
<br>
> String([true])
<br>
'true'
<br>
> String(['true'])
<br>
'true'
<br>
> String(true)
<br>
'true'
<br>

<br>
Stringifying functions, returns their source code:
<br>
> String(function f() {return 4})
<br>
'function f() {return 4}'
<br>

<br>
20.5 Comparing strings
<br>

<br>
159
<br>

<br>
20.4.2 Customizing the stringiﬁcation of objects
<br>
You can override the built-in way of stringifying objects by implementing the method
<br>
toString():
<br>
const obj = {
<br>
toString() {
<br>
return 'hello';
<br>
}
<br>
};
<br>
assert.equal(String(obj), 'hello');
<br>

<br>
20.4.3 An alternate way of stringifying values
<br>
The JSON data format is a text representation of JavaScript values. Therefore, JSON.
<br>
stringify() can also be used to convert values to strings:
<br>
> JSON.stringify({a: 1})
<br>
'{"a":1}'
<br>
> JSON.stringify(['a', ['b']])
<br>
'["a",["b"]]'
<br>

<br>
The caveat is that JSON only supports null, booleans, numbers, strings, Arrays, and
<br>
objects (which it always treats as if they were created by object literals).
<br>
Tip: The third parameter lets you switch on multiline output and specify how much to
<br>
indent – for example:
<br>
console.log(JSON.stringify({first: 'Jane', last: 'Doe'}, null, 2));
<br>

<br>
This statement produces the following output:
<br>
{
<br>
"first": "Jane",
<br>
"last": "Doe"
<br>
}
<br>

<br>
20.5 Comparing strings
<br>
Strings can be compared via the following operators:
<br>
< <= > >=
<br>

<br>
There is one important caveat to consider: These operators compare based on the numeric
<br>
values of JavaScript characters. That means that the order that JavaScript uses for strings
<br>
is different from the one used in dictionaries and phone books:
<br>
> 'A' < 'B' // ok
<br>
true
<br>
> 'a' < 'B' // not ok
<br>
false
<br>

<br>
160
<br>

<br>
20 Strings
<br>

<br>
> 'ä' < 'b' // not ok
<br>
false
<br>

<br>
Properly comparing text is beyond the scope of this book. It is supported via the ECMAScript Internationalization API (Intl).
<br>

<br>
20.6 Atoms of text: Unicode characters, JavaScript characters, grapheme clusters
<br>
Quick recap of §19 “Unicode – a brief introduction”:
<br>
• Unicode characters are represented by code points – numbers which have a range
<br>
of 21 bits.
<br>
• In JavaScript strings, Unicode is implemented via code units based on the encoding
<br>
format UTF-16. Each code unit is a 16-bit number. One to two of code units are
<br>
needed to encode a single code point.
<br>
– Therefore, each JavaScript character is represented by a code unit. In the
<br>
JavaScript standard library, code units are also called char codes. Which is
<br>
what they are: numbers for JavaScript characters.
<br>
• Grapheme clusters (user-perceived characters) are written symbols, as displayed on
<br>
screen or paper. One or more Unicode characters are needed to encode a single
<br>
grapheme cluster.
<br>
The following code demonstrates that a single Unicode character comprises one or two
<br>
JavaScript characters. We count the latter via .length:
<br>
// 3 Unicode characters, 3 JavaScript characters:
<br>
assert.equal('abc'.length, 3);
<br>
// 1 Unicode character, 2 JavaScript characters:
<br>
assert.equal('☺'.length, 2);
<br>

<br>
The following table summarizes the concepts we have just explored:
<br>
Entity
<br>

<br>
Numeric representation
<br>

<br>
Size
<br>

<br>
Encoded via
<br>

<br>
Grapheme cluster
<br>
Unicode character
<br>
JavaScript character
<br>

<br>
Code point
<br>
UTF-16 code unit
<br>

<br>
21 bits
<br>
16 bits
<br>

<br>
1+ code points
<br>
1–2 code units
<br>
–
<br>

<br>
20.6.1 Working with code points
<br>
Let’s explore JavaScript’s tools for working with code points.
<br>
A code point escape lets you specify a code point hexadecimally. It produces one or two
<br>
JavaScript characters.
<br>
> '\u{1F642}'
<br>
'☺'
<br>
String.fromCodePoint() converts a single code point to 1–2 JavaScript characters:
<br>

<br>
20.6 Atoms of text: Unicode characters, JavaScript characters, grapheme clusters
<br>

<br>
161
<br>

<br>
> String.fromCodePoint(0x1F642)
<br>
'☺'
<br>
.codePointAt() converts 1–2 JavaScript characters to a single code point:
<br>
> '☺'.codePointAt(0).toString(16)
<br>
'1f642'
<br>

<br>
You can iterate over a string, which visits Unicode characters (not JavaScript characters).
<br>
Iteration is described later in this book. One way of iterating is via a for-of loop:
<br>
const str = '☺a';
<br>
assert.equal(str.length, 3);
<br>
for (const codePointChar of str) {
<br>
console.log(codePointChar);
<br>
}
<br>
// Output:
<br>
// '☺'
<br>
// 'a'
<br>

<br>
Spreading (...) into Array literals is also based on iteration and visits Unicode characters:
<br>
> [...'☺a']
<br>
[ '☺', 'a' ]
<br>

<br>
That makes it a good tool for counting Unicode characters:
<br>
> [...'☺a'].length
<br>
2
<br>
> '☺a'.length
<br>
3
<br>

<br>
20.6.2 Working with code units (char codes)
<br>
Indices and lengths of strings are based on JavaScript characters (as represented by UTF16 code units).
<br>
To specify a code unit hexadecimally, you can use a code unit escape:
<br>
> '\uD83D\uDE42'
<br>
'☺'
<br>

<br>
And you can use String.fromCharCode(). Char code is the standard library’s name for
<br>
code unit:
<br>
> String.fromCharCode(0xD83D) + String.fromCharCode(0xDE42)
<br>
'☺'
<br>

<br>
To get the char code of a character, use .charCodeAt():
<br>
> '☺'.charCodeAt(0).toString(16)
<br>
'd83d'
<br>

<br>
162
<br>

<br>
20 Strings
<br>

<br>
20.6.3 Caveat: grapheme clusters
<br>
When working with text that may be written in any human language, it’s best to split at
<br>
the boundaries of grapheme clusters, not at the boundaries of Unicode characters.
<br>
TC39 is working on Intl.Segmenter, a proposal for the ECMAScript Internationalization API to support Unicode segmentation (along grapheme cluster boundaries, word
<br>
boundaries, sentence boundaries, etc.).
<br>
Until that proposal becomes a standard, you can use one of several libraries that are
<br>
available (do a web search for “JavaScript grapheme”).
<br>

<br>
20.7 Quick reference: Strings
<br>
Strings are immutable; none of the string methods ever modify their strings.
<br>

<br>
20.7.1 Converting to string
<br>
Tbl. 20.2 describes how various values are converted to strings.
<br>
Table 20.2: Converting values to strings.
<br>
x
<br>

<br>
String(x)
<br>

<br>
undefined
<br>

<br>
'undefined'
<br>

<br>
null
<br>

<br>
'null'
<br>

<br>
Boolean value
<br>
Number value
<br>
String value
<br>
An object
<br>

<br>
false → 'false', true → 'true'
<br>
Example: 123 → '123'
<br>
x (input, unchanged)
<br>
Conﬁgurable via, e.g., toString()
<br>

<br>
20.7.2 Numeric values of characters
<br>
• Char code: represents a JavaScript character numerically. JavaScript’s name for
<br>
Unicode code unit.
<br>
– Size: 16 bits, unsigned
<br>
– Convert number to character: String.fromCharCode() [ES1]
<br>
– Convert character to number: string method .charCodeAt() [ES1]
<br>
• Code point: represents a Unicode character numerically.
<br>
– Size: 21 bits, unsigned (17 planes, 16 bits each)
<br>
– Convert number to character: String.fromCodePoint() [ES6]
<br>
– Convert character to number: string method .codePointAt() [ES6]
<br>

<br>
20.7.3 String operators
<br>
// Access characters via []
<br>
const str = 'abc';
<br>
assert.equal(str[1], 'b');
<br>

<br>
20.7 Quick reference: Strings
<br>

<br>
163
<br>

<br>
// Concatenate strings via +
<br>
assert.equal('a' + 'b' + 'c', 'abc');
<br>
assert.equal('take ' + 3 + ' oranges', 'take 3 oranges');
<br>

<br>
20.7.4
<br>

<br>
String.prototype: ﬁnding and matching
<br>

<br>
(String.prototype is where the methods of strings are stored.)
<br>
• .endsWith(searchString: string, endPos=this.length): boolean [ES6]
<br>
Returns true if the string would end with searchString if its length were endPos.
<br>
Returns false otherwise.
<br>
> 'foo.txt'.endsWith('.txt')
<br>
true
<br>
> 'abcde'.endsWith('cd', 4)
<br>
true
<br>

<br>
• .includes(searchString: string, startPos=0): boolean [ES6]
<br>
Returns true if the string contains the searchString and false otherwise. The
<br>
search starts at startPos.
<br>
> 'abc'.includes('b')
<br>
true
<br>
> 'abc'.includes('b', 2)
<br>
false
<br>

<br>
• .indexOf(searchString: string, minIndex=0): number [ES1]
<br>
Returns the lowest index at which searchString appears within the string or -1,
<br>
otherwise. Any returned index will beminIndex‘ or higher.
<br>
> 'abab'.indexOf('a')
<br>
0
<br>
> 'abab'.indexOf('a', 1)
<br>
2
<br>
> 'abab'.indexOf('c')
<br>
-1
<br>

<br>
• .lastIndexOf(searchString: string, maxIndex=Infinity): number [ES1]
<br>
Returns the highest index at which searchString appears within the string or -1,
<br>
otherwise. Any returned index will bemaxIndex‘ or lower.
<br>
> 'abab'.lastIndexOf('ab', 2)
<br>
2
<br>
> 'abab'.lastIndexOf('ab', 1)
<br>
0
<br>
> 'abab'.lastIndexOf('ab')
<br>
2
<br>

<br>
• [1 of 2] .match(regExp: string | RegExp): RegExpMatchArray | null [ES3]
<br>

<br>
164
<br>

<br>
20 Strings
<br>

<br>
If regExp is a regular expression with ﬂag /g not set, then .match() returns the
<br>
ﬁrst match for regExp within the string. Or null if there is no match. If regExp is a
<br>
string, it is used to create a regular expression (think parameter of new RegExp())
<br>
before performing the previously mentioned steps.
<br>
The result has the following type:
<br>
interface RegExpMatchArray extends Array<string> {
<br>
index: number;
<br>
input: string;
<br>
groups: undefined | {
<br>
[key: string]: string
<br>
};
<br>
}
<br>

<br>
Numbered capture groups become Array indices (which is why this type extends
<br>
Array). Named capture groups (ES2018) become properties of .groups. In this
<br>
mode, .match() works like RegExp.prototype.exec().
<br>
Examples:
<br>
> 'ababb'.match(/a(b+)/)
<br>
{ 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: undefined }
<br>
> 'ababb'.match(/a(?<foo>b+)/)
<br>
{ 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: { foo: 'b' } }
<br>
> 'abab'.match(/x/)
<br>
null
<br>

<br>
• [2 of 2] .match(regExp: RegExp): string[] | null [ES3]
<br>
If ﬂag /g of regExp is set, .match() returns either an Array with all matches or null
<br>
if there was no match.
<br>
> 'ababb'.match(/a(b+)/g)
<br>
[ 'ab', 'abb' ]
<br>
> 'ababb'.match(/a(?<foo>b+)/g)
<br>
[ 'ab', 'abb' ]
<br>
> 'abab'.match(/x/g)
<br>
null
<br>

<br>
• .search(regExp: string | RegExp): number [ES3]
<br>
Returns the index at which regExp occurs within the string. If regExp is a string, it
<br>
is used to create a regular expression (think parameter of new RegExp()).
<br>
> 'a2b'.search(/[0-9]/)
<br>
1
<br>
> 'a2b'.search('[0-9]')
<br>
1
<br>

<br>
• .startsWith(searchString: string, startPos=0): boolean [ES6]
<br>
Returns true if searchString occurs in the string at index startPos. Returns
<br>
false otherwise.
<br>

<br>
20.7 Quick reference: Strings
<br>

<br>
165
<br>

<br>
> '.gitignore'.startsWith('.')
<br>
true
<br>
> 'abcde'.startsWith('bc', 1)
<br>
true
<br>

<br>
20.7.5
<br>

<br>
String.prototype: extracting
<br>

<br>
• .slice(start=0, end=this.length): string [ES3]
<br>
Returns the substring of the string that starts at (including) index start and ends
<br>
at (excluding) index end. If an index is negative, it is added to .length before it is
<br>
used (-1 becomes this.length-1, etc.).
<br>
> 'abc'.slice(1, 3)
<br>
'bc'
<br>
> 'abc'.slice(1)
<br>
'bc'
<br>
> 'abc'.slice(-2)
<br>
'bc'
<br>

<br>
• .split(separator: string | RegExp, limit?: number): string[] [ES3]
<br>
Splits the string into an Array of substrings – the strings that occur between the
<br>
separators. The separator can be a string:
<br>
> 'a | b | c'.split('|')
<br>
[ 'a ', ' b ', ' c' ]
<br>

<br>
It can also be a regular expression:
<br>
> 'a : b : c'.split(/ *: */)
<br>
[ 'a', 'b', 'c' ]
<br>
> 'a : b : c'.split(/( *):( *)/)
<br>
[ 'a', ' ', ' ', 'b', ' ', ' ', 'c' ]
<br>

<br>
The last invocation demonstrates that captures made by groups in the regular expression become elements of the returned Array.
<br>
Warning: .split('') splits a string into JavaScript characters. That doesn’t
<br>
work well when dealing with astral Unicode characters (which are encoded as
<br>
two JavaScript characters). For example, emojis are astral:
<br>
> '☺X☺'.split('')
<br>
[ '\uD83D', '\uDE42', 'X', '\uD83D', '\uDE42' ]
<br>

<br>
Instead, it is better to use spreading:
<br>
> [...'☺X☺']
<br>
[ '☺', 'X', '☺' ]
<br>

<br>
• .substring(start: number, end=this.length): string [ES1]
<br>
Use .slice() instead of this method. .substring() wasn’t implemented consistently in older engines and doesn’t support negative indices.
<br>

<br>
166
<br>

<br>
20 Strings
<br>

<br>
20.7.6
<br>

<br>
String.prototype: combining
<br>

<br>
• .concat(...strings: string[]): string [ES3]
<br>
Returns the concatenation of the string and strings. 'a'.concat('b') is equivalent to 'a'+'b'. The latter is much more popular.
<br>
> 'ab'.concat('cd', 'ef', 'gh')
<br>
'abcdefgh'
<br>

<br>
• .padEnd(len: number, fillString=' '): string [ES2017]
<br>
Appends (fragments of) fillString to the string until it has the desired length len.
<br>
If it already has or exceeds len, then it is returned without any changes.
<br>
> '#'.padEnd(2)
<br>
'# '
<br>
> 'abc'.padEnd(2)
<br>
'abc'
<br>
> '#'.padEnd(5, 'abc')
<br>
'#abca'
<br>

<br>
• .padStart(len: number, fillString=' '): string [ES2017]
<br>
Prepends (fragments of) fillString to the string until it has the desired length
<br>
len. If it already has or exceeds len, then it is returned without any changes.
<br>
> '#'.padStart(2)
<br>
' #'
<br>
> 'abc'.padStart(2)
<br>
'abc'
<br>
> '#'.padStart(5, 'abc')
<br>
'abca#'
<br>

<br>
• .repeat(count=0): string [ES6]
<br>
Returns the string, concatenated count times.
<br>
> '*'.repeat()
<br>
''
<br>
> '*'.repeat(3)
<br>
'***'
<br>

<br>
20.7.7
<br>

<br>
String.prototype: transforming
<br>

<br>
• .normalize(form: 'NFC'|'NFD'|'NFKC'|'NFKD' = 'NFC'): string [ES6]
<br>
Normalizes the string according to the Unicode Normalization Forms.
<br>
• [1 of 2] .replace(searchValue: string | RegExp, replaceValue: string):
<br>
string [ES3]
<br>

<br>
Replace matches of searchValue with replaceValue. If searchValue is a string,
<br>
only the ﬁrst verbatim occurrence is replaced. If searchValue is a regular expression without ﬂag /g, only the ﬁrst match is replaced. If searchValue is a regular
<br>
expression with /g then all matches are replaced.
<br>

<br>
20.7 Quick reference: Strings
<br>

<br>
167
<br>

<br>
> 'x.x.'.replace('.', '#')
<br>
'x#x.'
<br>
> 'x.x.'.replace(/./, '#')
<br>
'#.x.'
<br>
> 'x.x.'.replace(/./g, '#')
<br>
'####'
<br>

<br>
Special characters in replaceValue are:
<br>
– $$: becomes $
<br>
– $n: becomes the capture of numbered group n (alas, $0 stands for the string
<br>
'$0', it does not refer to the complete match)
<br>
– $&: becomes the complete match
<br>
– $`: becomes everything before the match
<br>
– $': becomes everything after the match
<br>
Examples:
<br>
> 'a 2020-04 b'.replace(/([0-9]{4})-([0-9]{2})/, '|$2|')
<br>
'a |04| b'
<br>
> 'a 2020-04 b'.replace(/([0-9]{4})-([0-9]{2})/, '|$&|')
<br>
'a |2020-04| b'
<br>
> 'a 2020-04 b'.replace(/([0-9]{4})-([0-9]{2})/, '|$`|')
<br>
'a |a | b'
<br>

<br>
Named capture groups (ES2018) are supported, too:
<br>
– $<name> becomes the capture of named group name
<br>
Example:
<br>
assert.equal(
<br>
'a 2020-04 b'.replace(
<br>
/(?<year>[0-9]{4})-(?<month>[0-9]{2})/, '|$<month>|'),
<br>
'a |04| b');
<br>

<br>
• [2 of 2] .replace(searchValue: string | RegExp, replacer: (...args: any[])
<br>
=> string): string [ES3]
<br>

<br>
If the second parameter is a function, occurrences are replaced with the strings it
<br>
returns. Its parameters args are:
<br>
–
<br>
–
<br>
–
<br>
–
<br>
–
<br>
–
<br>

<br>
matched: string. The complete match
<br>
g1: string|undefined. The capture of numbered group 1
<br>
g2: string|undefined. The capture of numbered group 2
<br>

<br>
(Etc.)
<br>
offset: number. Where was the match found in the input string?
<br>
input: string. The whole input string
<br>

<br>
const regexp = /([0-9]{4})-([0-9]{2})/;
<br>
const replacer = (all, year, month) => '|' + all + '|';
<br>
assert.equal(
<br>
'a 2020-04 b'.replace(regexp, replacer),
<br>
'a |2020-04| b');
<br>

<br>
168
<br>

<br>
20 Strings
<br>

<br>
Named capture groups (ES2018) are supported, too. If there are any, an argument
<br>
is added at the end with an object whose properties contain the captures:
<br>
const regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})/;
<br>
const replacer = (...args) => {
<br>
const groups=args.pop();
<br>
return '|' + groups.month + '|';
<br>
};
<br>
assert.equal(
<br>
'a 2020-04 b'.replace(regexp, replacer),
<br>
'a |04| b');
<br>

<br>
• .toUpperCase(): string [ES1]
<br>
Returns a copy of the string in which all lowercase alphabetic characters are converted to uppercase. How well that works for various alphabets, depends on the
<br>
JavaScript engine.
<br>
> '-a2b-'.toUpperCase()
<br>
'-A2B-'
<br>
> 'αβγ'.toUpperCase()
<br>
'ΑΒΓ'
<br>

<br>
• .toLowerCase(): string [ES1]
<br>
Returns a copy of the string in which all uppercase alphabetic characters are converted to lowercase. How well that works for various alphabets, depends on the
<br>
JavaScript engine.
<br>
> '-A2B-'.toLowerCase()
<br>
'-a2b-'
<br>
> 'ΑΒΓ'.toLowerCase()
<br>
'αβγ'
<br>

<br>
• .trim(): string [ES5]
<br>
Returns a copy of the string in which all leading and trailing whitespace (spaces,
<br>
tabs, line terminators, etc.) is gone.
<br>
> '\r\n#\t
<br>

<br>
'.trim()
<br>

<br>
'#'
<br>
> '
<br>

<br>
abc
<br>

<br>
'.trim()
<br>

<br>
'abc'
<br>

<br>
• .trimEnd(): string [ES2019]
<br>
Similar to .trim() but only the end of the string is trimmed:
<br>
> '
<br>
'
<br>

<br>
abc
<br>

<br>
'.trimEnd()
<br>

<br>
abc'
<br>

<br>
• .trimStart(): string [ES2019]
<br>
Similar to .trim() but only the beginning of the string is trimmed:
<br>

<br>
20.7 Quick reference: Strings
<br>
> '
<br>

<br>
abc
<br>

<br>
'abc
<br>

<br>
'.trimStart()
<br>

<br>
'
<br>

<br>
20.7.8 Sources
<br>
• TypeScript’s built-in typings
<br>
• MDN web docs for JavaScript
<br>
• ECMAScript language speciﬁcation
<br>

<br>
Exercise: Using string methods
<br>
exercises/strings/remove_extension_test.mjs
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
169
<br>

<br>
170
<br>

<br>
20 Strings
<br>

<br>
Chapter 21
<br>

<br>
Using template literals and
<br>
tagged templates
<br>
Contents
<br>
21.1 Disambiguation: “template” . . . . . . . . . . . . . . . . . . . . . . 171
<br>
21.2 Template literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
<br>
21.3 Tagged templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
<br>
21.3.1 Cooked vs. raw template strings (advanced) . . . . . . . . . . 173
<br>
21.3.2 Tag function library: lit-html . . . . . . . . . . . . . . . . . . . 174
<br>
21.3.3 Tag function library: re-template-tag
<br>
21.3.4 Tag function library: graphql-tag
<br>

<br>
. . . . . . . . . . . . . . 174
<br>

<br>
. . . . . . . . . . . . . . . . 175
<br>

<br>
21.4 Raw string literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
<br>
21.5 (Advanced) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
<br>
21.6 Multiline template literals and indentation . . . . . . . . . . . . . . 176
<br>
21.6.1 Fix: template tag for dedenting
<br>

<br>
. . . . . . . . . . . . . . . . . 176
<br>

<br>
21.6.2 Fix: .trim() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
<br>
21.7 Simple templating via template literals . . . . . . . . . . . . . . . . 177
<br>
21.7.1 A more complex example . . . . . . . . . . . . . . . . . . . . . 177
<br>
21.7.2 Simple HTML-escaping
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . 179
<br>

<br>
Before we dig into the two features template literal and tagged template, let’s ﬁrst examine
<br>
the multiple meanings of the term template.
<br>

<br>
21.1 Disambiguation: “template”
<br>
The following three things are signiﬁcantly different despite all having template in their
<br>
names and despite all of them looking similar:
<br>
• A text template is a function from data to text. It is frequently used in web development and often deﬁned via text ﬁles. For example, the following text deﬁnes a
<br>
template for the library Handlebars:
<br>
171
<br>

<br>
172
<br>

<br>
21 Using template literals and tagged templates
<br>
<div class="entry">
<br>
<h1>{{title}}</h1>
<br>
<div class="body">
<br>
{{body}}
<br>
</div>
<br>
</div>
<br>

<br>
This template has two blanks to be ﬁlled in: title and body. It is used like this:
<br>
// First step: retrieve the template text, e.g. from a text file.
<br>
const tmplFunc = Handlebars.compile(TEMPLATE_TEXT); // compile string
<br>
const data = {title: 'My page', body: 'Welcome to my page!'};
<br>
const html = tmplFunc(data);
<br>

<br>
• A template literal is similar to a string literal, but has additional features – for example, interpolation. It is delimited by backticks:
<br>
const num = 5;
<br>
assert.equal(`Count: ${num}!`, 'Count: 5!');
<br>

<br>
• Syntactically, a tagged template is a template literal that follows a function (or rather,
<br>
an expression that evaluates to a function). That leads to the function being called.
<br>
Its arguments are derived from the contents of the template literal.
<br>
const getArgs = (...args) => args;
<br>
assert.deepEqual(
<br>
getArgs`Count: ${5}!`,
<br>
[['Count: ', '!'], 5] );
<br>

<br>
Note that getArgs() receives both the text of the literal and the data interpolated
<br>
via ${}.
<br>

<br>
21.2 Template literals
<br>
A template literal has two new features compared to a normal string literal.
<br>
First, it supports string interpolation: if you put a dynamically computed value inside a
<br>
${}, it is converted to a string and inserted into the string returned by the literal.
<br>
const MAX = 100;
<br>
function doSomeWork(x) {
<br>
if (x > MAX) {
<br>
throw new Error(`At most ${MAX} allowed: ${x}!`);
<br>
}
<br>
// ···
<br>
}
<br>
assert.throws(
<br>
() => doSomeWork(101),
<br>
{message: 'At most 100 allowed: 101!'});
<br>

<br>
Second, template literals can span multiple lines:
<br>

<br>
21.3 Tagged templates
<br>

<br>
173
<br>

<br>
const str = `this is
<br>
a text with
<br>
multiple lines`;
<br>

<br>
Template literals always produce strings.
<br>

<br>
21.3 Tagged templates
<br>
The expression in line A is a tagged template. It is equivalent to invoking tagFunc() with
<br>
the arguments listed in the Array in line B.
<br>
function tagFunc(...args) {
<br>
return args;
<br>
}
<br>
const setting = 'dark mode';
<br>
const value = true;
<br>
assert.deepEqual(
<br>
tagFunc`Setting ${setting} is ${value}!`, // (A)
<br>
[['Setting ', ' is ', '!'], 'dark mode', true] // (B)
<br>
);
<br>

<br>
The function tagFunc before the ﬁrst backtick is called a tag function. Its arguments are:
<br>
• Template strings (ﬁrst argument): an Array with the text fragments surrounding the
<br>
interpolations ${}.
<br>
– In the example: ['Setting ', ' is ', '!']
<br>
• Substitutions (remaining arguments): the interpolated values.
<br>
– In the example: 'dark mode' and true
<br>
The static (ﬁxed) parts of the literal (the template strings) are kept separate from the dynamic parts (the substitutions).
<br>
A tag function can return arbitrary values.
<br>

<br>
21.3.1 Cooked vs. raw template strings (advanced)
<br>
So far, we have only seen the cooked interpretation of template strings. But tag functions
<br>
actually get two interpretations:
<br>
• A cooked interpretation where backslashes have special meaning. For example, \t
<br>
produces a tab character. This interpretation of the template strings is stored as an
<br>
Array in the ﬁrst argument.
<br>
• A raw interpretation where backslashes do not have special meaning. For example,
<br>
\t produces two characters – a backslash and a t. This interpretation of the template strings is stored in property .raw of the ﬁrst argument (an Array).
<br>
The following tag function cookedRaw uses both interpretations:
<br>
function cookedRaw(templateStrings, ...substitutions) {
<br>
return {
<br>

<br>
174
<br>

<br>
21 Using template literals and tagged templates
<br>
cooked: [...templateStrings], // copy just the Array elements
<br>
raw: templateStrings.raw,
<br>
substitutions,
<br>
};
<br>

<br>
}
<br>
assert.deepEqual(
<br>
cookedRaw`\tab${'subst'}\newline\\`,
<br>
{
<br>
cooked: ['\tab', '\newline\\'],
<br>
raw:
<br>

<br>
['\\tab', '\\newline\\\\'],
<br>

<br>
substitutions: ['subst'],
<br>
});
<br>

<br>
The raw interpretation enables raw string literals via String.raw (described later) and
<br>
similar applications.
<br>
Tagged templates are great for supporting small embedded languages (so-called domainspeciﬁc languages). We’ll continue with a few examples.
<br>

<br>
21.3.2 Tag function library: lit-html
<br>
lit-html is a templating library that is based on tagged templates and used by the frontend
<br>
framework Polymer:
<br>
import {html, render} from 'lit-html';
<br>
const template = (items) => html`
<br>
<ul>
<br>
${
<br>
repeat(items,
<br>
(item) => item.id,
<br>
(item, index) => html`<li>${index}. ${item.name}</li>`
<br>
)
<br>
}
<br>
</ul>
<br>
`;
<br>
repeat() is a custom function for looping. Its 2nd parameter produces unique keys for
<br>

<br>
the values returned by the 3rd parameter. Note the nested tagged template used by that
<br>
parameter.
<br>

<br>
21.3.3 Tag function library: re-template-tag
<br>
re-template-tag is a simple library for composing regular expressions. Templates tagged
<br>
with re produce regular expressions. The main beneﬁt is that you can interpolate regular
<br>
expressions and plain text via ${} (line A):
<br>
const RE_YEAR = re`(?<year>[0-9]{4})`;
<br>
const RE_MONTH = re`(?<month>[0-9]{2})`;
<br>
const RE_DAY = re`(?<day>[0-9]{2})`;
<br>
const RE_DATE = re`/${RE_YEAR}-${RE_MONTH}-${RE_DAY}/u`; // (A)
<br>

<br>
21.4 Raw string literals
<br>

<br>
175
<br>

<br>
const match = RE_DATE.exec('2017-01-27');
<br>
assert.equal(match.groups.year, '2017');
<br>

<br>
21.3.4 Tag function library: graphql-tag
<br>
The library graphql-tag lets you create GraphQL queries via tagged templates:
<br>
import gql from 'graphql-tag';
<br>
const query = gql`
<br>
{
<br>
user(id: 5) {
<br>
firstName
<br>
lastName
<br>
}
<br>
}
<br>
`;
<br>

<br>
Additionally, there are plugins for pre-compiling such queries in Babel, TypeScript, etc.
<br>

<br>
21.4 Raw string literals
<br>
Raw string literals are implemented via the tag function String.raw. They are string
<br>
literals where backslashes don’t do anything special (such as escaping characters, etc.):
<br>
assert.equal(String.raw`\back`, '\\back');
<br>

<br>
This helps whenever data contains backslashes – for example, strings with regular expressions:
<br>
const regex1 = /^\./;
<br>
const regex2 = new RegExp('^\\.');
<br>
const regex3 = new RegExp(String.raw`^\.`);
<br>

<br>
All three regular expressions are equivalent. With a normal string literal, you have to
<br>
write the backslash twice, to escape it for that literal. With a raw string literal, you don’t
<br>
have to do that.
<br>
Raw string literals are also useful for specifying Windows ﬁlename paths:
<br>
const WIN_PATH = String.raw`C:\foo\bar`;
<br>
assert.equal(WIN_PATH, 'C:\\foo\\bar');
<br>

<br>
21.5 (Advanced)
<br>
All remaining sections are advanced
<br>

<br>
176
<br>

<br>
21 Using template literals and tagged templates
<br>

<br>
21.6 Multiline template literals and indentation
<br>
If you put multiline text in template literals, two goals are in conﬂict: On one hand, the
<br>
template literal should be indented to ﬁt inside the source code. On the other hand, the
<br>
lines of its content should start in the leftmost column.
<br>
For example:
<br>
function div(text) {
<br>
return `
<br>
<div>
<br>
${text}
<br>
</div>
<br>
`;
<br>
}
<br>
console.log('Output:');
<br>
console.log(
<br>
div('Hello!')
<br>
// Replace spaces with mid-dots:
<br>
.replace(/ /g, '·')
<br>
// Replace \n with #\n:
<br>
.replace(/\n/g, '#\n')
<br>
);
<br>

<br>
Due to the indentation, the template literal ﬁts well into the source code. Alas, the output
<br>
is also indented. And we don’t want the return at the beginning and the return plus two
<br>
spaces at the end.
<br>
Output:
<br>
#
<br>
····<div>#
<br>
······Hello!#
<br>
····</div>#
<br>
··
<br>

<br>
There are two ways to ﬁx this: via a tagged template or by trimming the result of the
<br>
template literal.
<br>

<br>
21.6.1 Fix: template tag for dedenting
<br>
The ﬁrst ﬁx is to use a custom template tag that removes the unwanted whitespace. It uses
<br>
the ﬁrst line after the initial line break to determine in which column the text starts and
<br>
shortens the indentation everywhere. It also removes the line break at the very beginning
<br>
and the indentation at the very end. One such template tag is dedent by Desmond Brand:
<br>
import dedent from 'dedent';
<br>
function divDedented(text) {
<br>
return dedent`
<br>
<div>
<br>
${text}
<br>
</div>
<br>

<br>
21.7 Simple templating via template literals
<br>

<br>
177
<br>

<br>
`.replace(/\n/g, '#\n');
<br>
}
<br>
console.log('Output:');
<br>
console.log(divDedented('Hello!'));
<br>

<br>
This time, the output is not indented:
<br>
Output:
<br>
<div>#
<br>
Hello!#
<br>
</div>
<br>

<br>
21.6.2 Fix: .trim()
<br>
The second ﬁx is quicker, but also dirtier:
<br>
function divDedented(text) {
<br>
return `
<br>
<div>
<br>
${text}
<br>
</div>
<br>
`.trim().replace(/\n/g, '#\n');
<br>
}
<br>
console.log('Output:');
<br>
console.log(divDedented('Hello!'));
<br>

<br>
The string method .trim() removes the superﬂuous whitespace at the beginning and at
<br>
the end, but the content itself must start in the leftmost column. The advantage of this
<br>
solution is that you don’t need a custom tag function. The downside is that it looks ugly.
<br>
The output is the same as with dedent:
<br>
Output:
<br>
<div>#
<br>
Hello!#
<br>
</div>
<br>

<br>
21.7 Simple templating via template literals
<br>
While template literals look like text templates, it is not immediately obvious how to use
<br>
them for (text) templating: A text template gets its data from an object, while a template
<br>
literal gets its data from variables. The solution is to use a template literal in the body of
<br>
a function whose parameter receives the templating data – for example:
<br>
const tmpl = (data) => `Hello ${data.name}!`;
<br>
assert.equal(tmpl({name: 'Jane'}), 'Hello Jane!');
<br>

<br>
21.7.1 A more complex example
<br>
As a more complex example, we’d like to take an Array of addresses and produce an
<br>
HTML table. This is the Array:
<br>

<br>
178
<br>

<br>
21 Using template literals and tagged templates
<br>

<br>
const addresses = [
<br>
{ first: '<Jane>', last: 'Bond' },
<br>
{ first: 'Lars', last: '<Croft>' },
<br>
];
<br>

<br>
The function tmpl() that produces the HTML table looks as follows:
<br>
1
<br>

<br>
const tmpl = (addrs) => `
<br>

<br>
2
<br>

<br>
<table>
<br>

<br>
3
<br>
4
<br>

<br>
${addrs.map(
<br>
(addr) => `
<br>
<tr>
<br>

<br>
5
<br>

<br>
<td>${escapeHtml(addr.first)}</td>
<br>

<br>
6
<br>

<br>
<td>${escapeHtml(addr.last)}</td>
<br>

<br>
7
<br>

<br>
</tr>
<br>

<br>
8
<br>

<br>
`.trim()
<br>

<br>
9
<br>
10
<br>

<br>
).join('')}
<br>

<br>
11
<br>

<br>
</table>
<br>

<br>
12
<br>

<br>
`.trim();
<br>

<br>
This code contains two templating functions:
<br>
• The ﬁrst one (line 1) takes addrs, an Array with addresses, and returns a string
<br>
with a table.
<br>
• The second one (line 4) takes addr, an object containing an address, and returns a
<br>
string with a table row. Note the .trim() at the end, which removes unnecessary
<br>
whitespace.
<br>
The ﬁrst templating function produces its result by wrapping a table element around an
<br>
Array that it joins into a string (line 10). That Array is produced by mapping the second
<br>
templating function to each element of addrs (line 3). It therefore contains strings with
<br>
table rows.
<br>
The helper function escapeHtml() is used to escape special HTML characters (line 6 and
<br>
line 7). Its implementation is shown in the next subsection.
<br>
Let us call tmpl() with the addresses and log the result:
<br>
console.log(tmpl(addresses));
<br>

<br>
The output is:
<br>
<table>
<br>
<tr>
<br>
<td>&lt;Jane&gt;</td>
<br>
<td>Bond</td>
<br>
</tr><tr>
<br>
<td>Lars</td>
<br>
<td>&lt;Croft&gt;</td>
<br>
</tr>
<br>
</table>
<br>

<br>
21.7 Simple templating via template literals
<br>

<br>
179
<br>

<br>
21.7.2 Simple HTML-escaping
<br>
The following function escapes plain text so that it is displayed verbatim in HTML:
<br>
function escapeHtml(str) {
<br>
return str
<br>
.replace(/&/g, '&amp;') // first!
<br>
.replace(/>/g, '&gt;')
<br>
.replace(/</g, '&lt;')
<br>
.replace(/"/g, '&quot;')
<br>
.replace(/'/g, '&#39;')
<br>
.replace(/`/g, '&#96;')
<br>
;
<br>
}
<br>
assert.equal(
<br>
escapeHtml('Rock & Roll'), 'Rock &amp; Roll');
<br>
assert.equal(
<br>
escapeHtml('<blank>'), '&lt;blank&gt;');
<br>

<br>
Exercise: HTML templating
<br>
Exercise with bonus challenge:
<br>
test.mjs
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
exercises/template-literals/templating_
<br>

<br>
180
<br>

<br>
21 Using template literals and tagged templates
<br>

<br>
Chapter 22
<br>

<br>
Symbols
<br>
Contents
<br>
22.1 Use cases for symbols . . . . . . . . . . . . . . . . . . . . . . . . . . 182
<br>
22.1.1 Symbols: values for constants . . . . . . . . . . . . . . . . . . 182
<br>
22.1.2 Symbols: unique property keys . . . . . . . . . . . . . . . . . 183
<br>
22.2 Publicly known symbols
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . 184
<br>

<br>
22.3 Converting symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
<br>

<br>
Symbols are primitive values that are created via the factory function Symbol():
<br>
const mySymbol = Symbol('mySymbol');
<br>

<br>
The parameter is optional and provides a description, which is mainly useful for debugging.
<br>
On one hand, symbols are like objects in that each value created by Symbol() is unique
<br>
and not compared by value:
<br>
> Symbol() === Symbol()
<br>
false
<br>

<br>
On the other hand, they also behave like primitive values. They have to be categorized
<br>
via typeof:
<br>
const sym = Symbol();
<br>
assert.equal(typeof sym, 'symbol');
<br>

<br>
And they can be property keys in objects:
<br>
const obj = {
<br>
[sym]: 123,
<br>
};
<br>

<br>
181
<br>

<br>
182
<br>

<br>
22 Symbols
<br>

<br>
22.1 Use cases for symbols
<br>
The main use cases for symbols, are:
<br>
• Values for constants
<br>
• Unique property keys
<br>

<br>
22.1.1 Symbols: values for constants
<br>
Let’s assume you want to create constants representing the colors red, orange, yellow,
<br>
green, blue, and violet. One simple way of doing so would be to use strings:
<br>
const COLOR_BLUE = 'Blue';
<br>

<br>
On the plus side, logging that constant produces helpful output. On the minus side, there
<br>
is a risk of mistaking an unrelated value for a color because two strings with the same
<br>
content are considered equal:
<br>
const MOOD_BLUE = 'Blue';
<br>
assert.equal(COLOR_BLUE, MOOD_BLUE);
<br>

<br>
We can ﬁx that problem via symbols:
<br>
const COLOR_BLUE = Symbol('Blue');
<br>
const MOOD_BLUE = Symbol('Blue');
<br>
assert.notEqual(COLOR_BLUE, MOOD_BLUE);
<br>

<br>
Let’s use symbol-valued constants to implement a function:
<br>
const COLOR_RED
<br>

<br>
= Symbol('Red');
<br>

<br>
const COLOR_ORANGE = Symbol('Orange');
<br>
const COLOR_YELLOW = Symbol('Yellow');
<br>
const COLOR_GREEN
<br>

<br>
= Symbol('Green');
<br>

<br>
const COLOR_BLUE
<br>

<br>
= Symbol('Blue');
<br>

<br>
const COLOR_VIOLET = Symbol('Violet');
<br>
function getComplement(color) {
<br>
switch (color) {
<br>
case COLOR_RED:
<br>
return COLOR_GREEN;
<br>
case COLOR_ORANGE:
<br>
return COLOR_BLUE;
<br>
case COLOR_YELLOW:
<br>
return COLOR_VIOLET;
<br>
case COLOR_GREEN:
<br>
return COLOR_RED;
<br>
case COLOR_BLUE:
<br>
return COLOR_ORANGE;
<br>
case COLOR_VIOLET:
<br>
return COLOR_YELLOW;
<br>
default:
<br>

<br>
22.1 Use cases for symbols
<br>

<br>
183
<br>

<br>
throw new Exception('Unknown color: '+color);
<br>
}
<br>
}
<br>
assert.equal(getComplement(COLOR_YELLOW), COLOR_VIOLET);
<br>

<br>
22.1.2 Symbols: unique property keys
<br>
The keys of properties (ﬁelds) in objects are used at two levels:
<br>
• The program operates at a base level. The keys at that level reﬂect the problem that
<br>
the program solves.
<br>
• Libraries and ECMAScript operate at a meta-level. The keys at that level are used
<br>
by services operating on base-level data and code. One such key is 'toString'.
<br>
The following code demonstrates the difference:
<br>
const pt = {
<br>
x: 7,
<br>
y: 4,
<br>
toString() {
<br>
return `(${this.x}, ${this.y})`;
<br>
},
<br>
};
<br>
assert.equal(String(pt), '(7, 4)');
<br>

<br>
Properties .x and .y exist at the base level. They hold the coordinates of the point
<br>
represented by pt and are used to solve a problem – computing with points. Method
<br>
.toString() exists at a meta-level. It is used by JavaScript to convert this object to a
<br>
string.
<br>
Meta-level properties must never interfere with base-level properties. That is, their keys
<br>
must never overlap. That is difﬁcult when both language and libraries contribute to
<br>
the meta-level. For example, it is now impossible to give new meta-level methods simple names, such as toString because they might clash with existing base-level names.
<br>
Python’s solution to this problem is to preﬁx and sufﬁx special names with two underscores: __init__, __iter__, __hash__, etc. However, even with this solution, libraries
<br>
can’t have their own meta-level properties because those might be in conﬂict with future
<br>
language properties.
<br>
Symbols, used as property keys, help us here: Each symbol is unique and a symbol key
<br>
never clashes with any other string or symbol key.
<br>
22.1.2.1 Example: a library with a meta-level method
<br>
As an example, let’s assume we are writing a library that treats objects differently if they
<br>
implement a special method. This is what deﬁning a property key for such a method and
<br>
implementing it for an object would look like:
<br>
const specialMethod = Symbol('specialMethod');
<br>
const obj = {
<br>
_id: 'kf12oi',
<br>

<br>
184
<br>

<br>
22 Symbols
<br>
[specialMethod]() { // (A)
<br>
return this._id;
<br>
}
<br>

<br>
};
<br>
assert.equal(obj[specialMethod](), 'kf12oi');
<br>

<br>
The square brackets in line A enable us to specify that the method must have the key
<br>
specialMethod. More details are explained in §28.5.2 “Computed property keys”.
<br>

<br>
22.2 Publicly known symbols
<br>
Symbols that play special roles within ECMAScript are called publicly known symbols. Examples include:
<br>
• Symbol.iterator: makes an object iterable. It’s the key of a method that returns an
<br>
iterator. For more information on this topic, see §30 “Synchronous iteration”.
<br>
• Symbol.hasInstance: customizes how instanceof works. If an object implements
<br>
a method with that key, it can be used at the right-hand side of that operator. For
<br>
example:
<br>
const PrimitiveNull = {
<br>
[Symbol.hasInstance](x) {
<br>
return x === null;
<br>
}
<br>
};
<br>
assert.equal(null instanceof PrimitiveNull, true);
<br>

<br>
• Symbol.toStringTag: inﬂuences the default .toString() method.
<br>
> String({})
<br>
'[object Object]'
<br>
> String({ [Symbol.toStringTag]: 'is no money' })
<br>
'[object is no money]'
<br>

<br>
Note: It’s usually better to override .toString().
<br>

<br>
Exercises: Publicly known symbols
<br>
• Symbol.toStringTag: exercises/symbols/to_string_tag_test.mjs
<br>
• Symbol.hasInstance: exercises/symbols/has_instance_test.mjs
<br>

<br>
22.3 Converting symbols
<br>
What happens if we convert a symbol sym to another primitive type? Tbl. 22.1 has the
<br>
answers.
<br>

<br>
185
<br>

<br>
22.3 Converting symbols
<br>

<br>
Table 22.1: The results of converting symbols to other primitive types.
<br>
Convert to
<br>

<br>
Explicit conversion
<br>

<br>
Coercion (implicit conv.)
<br>

<br>
boolean
<br>
number
<br>
string
<br>

<br>
Boolean(sym) → OK
<br>

<br>
!sym → OK
<br>

<br>
Number(sym) → TypeError
<br>

<br>
sym*2 → TypeError
<br>

<br>
String(sym) → OK
<br>

<br>
''+sym → TypeError
<br>

<br>
sym.toString() → OK
<br>

<br>
`${sym}` → TypeError
<br>

<br>
One key pitfall with symbols is how often exceptions are thrown when converting them
<br>
to something else. What is the thinking behind that? First, conversion to number never
<br>
makes sense and should be warned about. Second, converting a symbol to a string is
<br>
indeed useful for diagnostic output. But it also makes sense to warn about accidentally
<br>
turning a symbol into a string (which is a different kind of property key):
<br>
const obj = {};
<br>
const sym = Symbol();
<br>
assert.throws(
<br>
() => { obj['__'+sym+'__'] = true },
<br>
{ message: 'Cannot convert a Symbol value to a string' });
<br>

<br>
The downside is that the exceptions make working with symbols more complicated. You
<br>
have to explicitly convert symbols when assembling strings via the plus operator:
<br>
> const mySymbol = Symbol('mySymbol');
<br>
> 'Symbol I used: ' + mySymbol
<br>
TypeError: Cannot convert a Symbol value to a string
<br>
> 'Symbol I used: ' + String(mySymbol)
<br>
'Symbol I used: Symbol(mySymbol)'
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
186
<br>

<br>
22 Symbols
<br>

<br>
Part V
<br>

<br>
Control ﬂow and data ﬂow
<br>

<br>
187
<br>

<br>
Chapter 23
<br>

<br>
Control ﬂow statements
<br>
Contents
<br>
23.1 Conditions of control ﬂow statements . . . . . . . . . . . . . . . . . 190
<br>
23.2 Controlling loops: break and continue . . . . . . . . . . . . . . . . . 190
<br>
23.2.1 break
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
<br>

<br>
23.2.2 break plus label: leaving any labeled statement
<br>

<br>
. . . . . . . . 191
<br>

<br>
23.2.3 continue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
<br>
23.3 if statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
<br>
23.3.1 The syntax of if statements . . . . . . . . . . . . . . . . . . . 192
<br>
23.4 switch statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
<br>
23.4.1 A ﬁrst example of a switch statement . . . . . . . . . . . . . . 193
<br>
23.4.2 Don’t forget to return or break! . . . . . . . . . . . . . . . . . 194
<br>
23.4.3 Empty case clauses . . . . . . . . . . . . . . . . . . . . . . . . 194
<br>
23.4.4 Checking for illegal values via a default clause . . . . . . . . 195
<br>
23.5 while loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
<br>
23.5.1 Examples of while loops . . . . . . . . . . . . . . . . . . . . . 196
<br>
23.6 do-while loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
<br>
23.7 for loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
<br>
23.7.1 Examples of for loops . . . . . . . . . . . . . . . . . . . . . . 197
<br>
23.8 for-of loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
<br>
23.8.1 const: for-of vs. for . . . . . . . . . . . . . . . . . . . . . . . 198
<br>
23.8.2 Iterating over iterables . . . . . . . . . . . . . . . . . . . . . . 198
<br>
23.8.3 Iterating over [index, element] pairs of Arrays . . . . . . . . . 198
<br>
23.9 for-await-of loops
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . 199
<br>

<br>
23.10 for-in loops (avoid) . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
<br>

<br>
This chapter covers the following control ﬂow statements:
<br>
• if statement (ES1)
<br>
• switch statement (ES3)
<br>
• while loop (ES1)
<br>
189
<br>

<br>
190
<br>

<br>
23 Control ﬂow statements
<br>

<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
do-while loop (ES3)
<br>
for loop (ES1)
<br>
for-of loop (ES6)
<br>
for-await-of loop (ES2018)
<br>
for-in loop (ES1)
<br>

<br>
Before we get to the actual control ﬂow statements, let’s take a look at two operators for
<br>
controlling loops.
<br>

<br>
23.1 Conditions of control ﬂow statements
<br>
if, while, and do-while have conditions that are, in principle, boolean. However, a
<br>

<br>
condition only has to be truthy (true if coerced to boolean) in order to be accepted. In
<br>
other words, the following two control ﬂow statements are equivalent:
<br>
if (value) {}
<br>
if (Boolean(value) === true) {}
<br>

<br>
This is a list of all falsy values:
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
undefined, null
<br>
false
<br>
0, NaN
<br>
''
<br>

<br>
All other values are truthy. For more information, see §16.2 “Falsy and truthy values”.
<br>

<br>
23.2 Controlling loops: break and continue
<br>
The two operators break and continue can be used to control loops and other statements
<br>
while you are inside them.
<br>

<br>
23.2.1
<br>

<br>
break
<br>

<br>
There are two versions of break: one with an operand and one without an operand. The
<br>
latter version works inside the following statements: while, do-while, for, for-of, forawait-of, for-in and switch. It immediately leaves the current statement:
<br>
for (const x of ['a', 'b', 'c']) {
<br>
console.log(x);
<br>
if (x === 'b') break;
<br>
console.log('---')
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// '---'
<br>
// 'b'
<br>

<br>
23.2 Controlling loops: break and continue
<br>

<br>
23.2.2
<br>

<br>
191
<br>

<br>
break plus label: leaving any labeled statement
<br>

<br>
break with an operand works everywhere. Its operand is a label. Labels can be put in
<br>

<br>
front of any statement, including blocks. break foo leaves the statement whose label is
<br>
foo:
<br>
foo: { // label
<br>
if (condition) break foo; // labeled break
<br>
// ···
<br>
}
<br>

<br>
In the following example, we use break with a label to leave a loop differently when we
<br>
succeeded (line A). Then we skip what comes directly after the loop, which is where we
<br>
end up if we failed.
<br>
function findSuffix(stringArray, suffix) {
<br>
let result;
<br>
search_block: {
<br>
for (const str of stringArray) {
<br>
if (str.endsWith(suffix)) {
<br>
// Success:
<br>
result = str;
<br>
break search_block; // (A)
<br>
}
<br>
} // for
<br>
// Failure:
<br>
result = '(Untitled)';
<br>
} // search_block
<br>
return { suffix, result };
<br>
// Same as: {suffix: suffix, result: result}
<br>
}
<br>
assert.deepEqual(
<br>
findSuffix(['foo.txt', 'bar.html'], '.html'),
<br>
{ suffix: '.html', result: 'bar.html' }
<br>
);
<br>
assert.deepEqual(
<br>
findSuffix(['foo.txt', 'bar.html'], '.mjs'),
<br>
{ suffix: '.mjs', result: '(Untitled)' }
<br>
);
<br>

<br>
23.2.3
<br>

<br>
continue
<br>

<br>
continue only works inside while, do-while, for, for-of, for-await-of, and for-in.
<br>
It immediately leaves the current loop iteration and continues with the next one – for
<br>
example:
<br>
const lines = [
<br>
'Normal line',
<br>
'# Comment',
<br>

<br>
192
<br>

<br>
23 Control ﬂow statements
<br>
'Another normal line',
<br>

<br>
];
<br>
for (const line of lines) {
<br>
if (line.startsWith('#')) continue;
<br>
console.log(line);
<br>
}
<br>
// Output:
<br>
// 'Normal line'
<br>
// 'Another normal line'
<br>

<br>
23.3
<br>

<br>
if statements
<br>

<br>
These are two simple if statements: one with just a “then” branch and one with both a
<br>
“then” branch and an “else” branch:
<br>
if (cond) {
<br>
// then branch
<br>
}
<br>
if (cond) {
<br>
// then branch
<br>
} else {
<br>
// else branch
<br>
}
<br>

<br>
Instead of the block, else can also be followed by another if statement:
<br>
if (cond1) {
<br>
// ···
<br>
} else if (cond2) {
<br>
// ···
<br>
}
<br>
if (cond1) {
<br>
// ···
<br>
} else if (cond2) {
<br>
// ···
<br>
} else {
<br>
// ···
<br>
}
<br>

<br>
You can continue this chain with more else ifs.
<br>

<br>
23.3.1 The syntax of if statements
<br>
The general syntax of if statements is:
<br>
if (cond) «then_statement»
<br>
else «else_statement»
<br>

<br>
23.4 switch statements
<br>

<br>
193
<br>

<br>
So far, the then_statement has always been a block, but we can use any statement. That
<br>
statement must be terminated with a semicolon:
<br>
if (true) console.log('Yes'); else console.log('No');
<br>

<br>
That means that else if is not its own construct; it’s simply an if statement whose
<br>
else_statement is another if statement.
<br>

<br>
23.4
<br>

<br>
switch statements
<br>

<br>
A switch statement looks as follows:
<br>
switch («switch_expression») {
<br>
«switch_body»
<br>
}
<br>

<br>
The body of switch consists of zero or more case clauses:
<br>
case «case_expression»:
<br>
«statements»
<br>

<br>
And, optionally, a default clause:
<br>
default:
<br>
«statements»
<br>

<br>
A switch is executed as follows:
<br>
• It evaluates the switch expression.
<br>
• It jumps to the ﬁrst case clause whose expression has the same result as the switch
<br>
expression.
<br>
• Otherwise, if there is no such clause, it jumps to the default clause.
<br>
• Otherwise, if there is no default clause, it does nothing.
<br>

<br>
23.4.1 A ﬁrst example of a switch statement
<br>
Let’s look at an example: The following function converts a number from 1–7 to the name
<br>
of a weekday.
<br>
function dayOfTheWeek(num) {
<br>
switch (num) {
<br>
case 1:
<br>
return 'Monday';
<br>
case 2:
<br>
return 'Tuesday';
<br>
case 3:
<br>
return 'Wednesday';
<br>
case 4:
<br>
return 'Thursday';
<br>
case 5:
<br>
return 'Friday';
<br>
case 6:
<br>

<br>
194
<br>

<br>
23 Control ﬂow statements
<br>
return 'Saturday';
<br>
case 7:
<br>
return 'Sunday';
<br>
}
<br>

<br>
}
<br>
assert.equal(dayOfTheWeek(5), 'Friday');
<br>

<br>
23.4.2 Don’t forget to return or break!
<br>
At the end of a case clause, execution continues with the next case clause, unless you
<br>
return or break – for example:
<br>
function englishToFrench(english) {
<br>
let french;
<br>
switch (english) {
<br>
case 'hello':
<br>
french = 'bonjour';
<br>
case 'goodbye':
<br>
french = 'au revoir';
<br>
}
<br>
return french;
<br>
}
<br>
// The result should be 'bonjour'!
<br>
assert.equal(englishToFrench('hello'), 'au revoir');
<br>

<br>
That is, our implementation of dayOfTheWeek() only worked because we used return.
<br>
We can ﬁx englishToFrench() by using break:
<br>
function englishToFrench(english) {
<br>
let french;
<br>
switch (english) {
<br>
case 'hello':
<br>
french = 'bonjour';
<br>
break;
<br>
case 'goodbye':
<br>
french = 'au revoir';
<br>
break;
<br>
}
<br>
return french;
<br>
}
<br>
assert.equal(englishToFrench('hello'), 'bonjour'); // ok
<br>

<br>
23.4.3 Empty case clauses
<br>
The statements of a case clause can be omitted, which effectively gives us multiple case
<br>
expressions per case clause:
<br>
function isWeekDay(name) {
<br>
switch (name) {
<br>
case 'Monday':
<br>

<br>
23.5 while loops
<br>

<br>
195
<br>

<br>
case 'Tuesday':
<br>
case 'Wednesday':
<br>
case 'Thursday':
<br>
case 'Friday':
<br>
return true;
<br>
case 'Saturday':
<br>
case 'Sunday':
<br>
return false;
<br>
}
<br>
}
<br>
assert.equal(isWeekDay('Wednesday'), true);
<br>
assert.equal(isWeekDay('Sunday'), false);
<br>

<br>
23.4.4 Checking for illegal values via a default clause
<br>
A default clause is jumped to if the switch expression has no other match. That makes
<br>
it useful for error checking:
<br>
function isWeekDay(name) {
<br>
switch (name) {
<br>
case 'Monday':
<br>
case 'Tuesday':
<br>
case 'Wednesday':
<br>
case 'Thursday':
<br>
case 'Friday':
<br>
return true;
<br>
case 'Saturday':
<br>
case 'Sunday':
<br>
return false;
<br>
default:
<br>
throw new Error('Illegal value: '+name);
<br>
}
<br>
}
<br>
assert.throws(
<br>
() => isWeekDay('January'),
<br>
{message: 'Illegal value: January'});
<br>

<br>
Exercises: switch
<br>
• exercises/control-flow/number_to_month_test.mjs
<br>
• Bonus: exercises/control-flow/is_object_via_switch_test.mjs
<br>

<br>
23.5
<br>

<br>
while loops
<br>

<br>
A while loop has the following syntax:
<br>

<br>
196
<br>

<br>
23 Control ﬂow statements
<br>

<br>
while («condition») {
<br>
«statements»
<br>
}
<br>

<br>
Before each loop iteration, while evaluates condition:
<br>
• If the result is falsy, the loop is ﬁnished.
<br>
• If the result is truthy, the while body is executed one more time.
<br>

<br>
23.5.1 Examples of while loops
<br>
The following code uses a while loop. In each loop iteration, it removes the ﬁrst element
<br>
of arr via .shift() and logs it.
<br>
const arr = ['a', 'b', 'c'];
<br>
while (arr.length > 0) {
<br>
const elem = arr.shift(); // remove first element
<br>
console.log(elem);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>
// 'c'
<br>

<br>
If the condition always evaluates to true, then while is an inﬁnite loop:
<br>
while (true) {
<br>
if (Math.random() === 0) break;
<br>
}
<br>

<br>
23.6
<br>

<br>
do-while loops
<br>

<br>
The do-while loop works much like while, but it checks its condition after each loop
<br>
iteration, not before.
<br>
let input;
<br>
do {
<br>
input = prompt('Enter text:');
<br>
console.log(input);
<br>
} while (input !== ':q');
<br>
prompt() is a global function that is available in web browsers. It prompts the user to
<br>

<br>
input text and returns it.
<br>

<br>
23.7
<br>

<br>
for loops
<br>

<br>
A for loop has the following syntax:
<br>
for («initialization»; «condition»; «post_iteration») {
<br>
«statements»
<br>
}
<br>

<br>
23.8 for-of loops
<br>

<br>
197
<br>

<br>
The ﬁrst line is the head of the loop and controls how often the body (the remainder of the
<br>
loop) is executed. It has three parts and each of them is optional:
<br>
• initialization: sets up variables, etc. for the loop. Variables declared here via
<br>
let or const only exist inside the loop.
<br>
• condition: This condition is checked before each loop iteration. If it is falsy, the
<br>
loop stops.
<br>
• post_iteration: This code is executed after each loop iteration.
<br>
A for loop is therefore roughly equivalent to the following while loop:
<br>
«initialization»
<br>
while («condition») {
<br>
«statements»
<br>
«post_iteration»
<br>
}
<br>

<br>
23.7.1 Examples of for loops
<br>
As an example, this is how to count from zero to two via a for loop:
<br>
for (let i=0; i<3; i++) {
<br>
console.log(i);
<br>
}
<br>
// Output:
<br>
// 0
<br>
// 1
<br>
// 2
<br>

<br>
This is how to log the contents of an Array via a for loop:
<br>
const arr = ['a', 'b', 'c'];
<br>
for (let i=0; i<arr.length; i++) {
<br>
console.log(arr[i]);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>
// 'c'
<br>

<br>
If you omit all three parts of the head, you get an inﬁnite loop:
<br>
for (;;) {
<br>
if (Math.random() === 0) break;
<br>
}
<br>

<br>
23.8
<br>

<br>
for-of loops
<br>

<br>
A for-of loop iterates over an iterable – a data container that supports the iteration protocol.
<br>
Each iterated value is stored in a variable, as speciﬁed in the head:
<br>

<br>
198
<br>

<br>
23 Control ﬂow statements
<br>

<br>
for («iteration_variable» of «iterable») {
<br>
«statements»
<br>
}
<br>

<br>
The iteration variable is usually created via a variable declaration:
<br>
const iterable = ['hello', 'world'];
<br>
for (const elem of iterable) {
<br>
console.log(elem);
<br>
}
<br>
// Output:
<br>
// 'hello'
<br>
// 'world'
<br>

<br>
But you can also use a (mutable) variable that already exists:
<br>
const iterable = ['hello', 'world'];
<br>
let elem;
<br>
for (elem of iterable) {
<br>
console.log(elem);
<br>
}
<br>

<br>
23.8.1
<br>

<br>
const: for-of vs. for
<br>

<br>
Note that in for-of loops you can use const. The iteration variable can still be different
<br>
for each iteration (it just can’t change during the iteration). Think of it as a new const
<br>
declaration being executed each time in a fresh scope.
<br>
In contrast, in for loops you must declare variables via let or var if their values change.
<br>

<br>
23.8.2 Iterating over iterables
<br>
As mentioned before, for-of works with any iterable object, not just with Arrays – for
<br>
example, with Sets:
<br>
const set = new Set(['hello', 'world']);
<br>
for (const elem of set) {
<br>
console.log(elem);
<br>
}
<br>

<br>
23.8.3 Iterating over [index, element] pairs of Arrays
<br>
Lastly, you can also use for-of to iterate over the [index, element] entries of Arrays:
<br>
const arr = ['a', 'b', 'c'];
<br>
for (const [index, elem] of arr.entries()) {
<br>
console.log(`${index} -> ${elem}`);
<br>
}
<br>
// Output:
<br>
// '0 -> a'
<br>
// '1 -> b'
<br>
// '2 -> c'
<br>

<br>
23.9 for-await-of loops
<br>

<br>
199
<br>

<br>
With [index, element], we are using destructuring to access Array elements.
<br>

<br>
Exercise: for-of
<br>
exercises/control-flow/array_to_string_test.mjs
<br>

<br>
23.9
<br>

<br>
for-await-of loops
<br>

<br>
for-await-of is like for-of, but it works with asynchronous iterables instead of synchronous ones. And it can only be used inside async functions and async generators.
<br>
for await (const item of asyncIterable) {
<br>
// ···
<br>
}
<br>
for-await-of is described in detail in the chapter on asynchronous iteration.
<br>

<br>
23.10 for-in loops (avoid)
<br>
Recommendation: don’t use for-in loops
<br>
for-in has several pitfalls. Therefore, it is usually best to avoid it.
<br>

<br>
This is an example of using for-in properly, which involves boilerplate code (line A):
<br>
function getOwnPropertyNames(obj) {
<br>
const result = [];
<br>
for (const key in obj) {
<br>
if ({}.hasOwnProperty.call(obj, key)) { // (A)
<br>
result.push(key);
<br>
}
<br>
}
<br>
return result;
<br>
}
<br>
assert.deepEqual(
<br>
getOwnPropertyNames({ a: 1, b:2 }),
<br>
['a', 'b']);
<br>
assert.deepEqual(
<br>
getOwnPropertyNames(['a', 'b']),
<br>
['0', '1']); // strings!
<br>

<br>
We can implement the same functionality without for-in, which is almost always better:
<br>
function getOwnPropertyNames(obj) {
<br>
const result = [];
<br>
for (const key of Object.keys(obj)) {
<br>
result.push(key);
<br>
}
<br>

<br>
200
<br>

<br>
23 Control ﬂow statements
<br>
return result;
<br>

<br>
}
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 24
<br>

<br>
Exception handling
<br>
Contents
<br>
24.1 Motivation: throwing and catching exceptions . . . . . . . . . . . . 201
<br>
24.2 throw
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
<br>

<br>
24.2.1 Options for creating error objects . . . . . . . . . . . . . . . . 203
<br>
24.3 The try statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
<br>
24.3.1 The try block . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
<br>
24.3.2 The catch clause . . . . . . . . . . . . . . . . . . . . . . . . . 203
<br>
24.3.3 The finally clause . . . . . . . . . . . . . . . . . . . . . . . . 204
<br>
24.4 Error classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
<br>
24.4.1 Properties of error objects
<br>

<br>
. . . . . . . . . . . . . . . . . . . . 205
<br>

<br>
This chapter covers how JavaScript handles exceptions.
<br>

<br>
Why doesn’t JavaScript throw exceptions more often?
<br>
JavaScript didn’t support exceptions until ES3. That explains why they are used
<br>
sparingly by the language and its standard library.
<br>

<br>
24.1 Motivation: throwing and catching exceptions
<br>
Consider the following code. It reads proﬁles stored in ﬁles into an Array with instances
<br>
of class Profile:
<br>
function readProfiles(filePaths) {
<br>
const profiles = [];
<br>
for (const filePath of filePaths) {
<br>
try {
<br>
const profile = readOneProfile(filePath);
<br>
profiles.push(profile);
<br>

<br>
201
<br>

<br>
202
<br>

<br>
24 Exception handling
<br>
} catch (err) { // (A)
<br>
console.log('Error in: '+filePath, err);
<br>
}
<br>
}
<br>

<br>
}
<br>
function readOneProfile(filePath) {
<br>
const profile = new Profile();
<br>
const file = openFile(filePath);
<br>
// ··· (Read the data in `file` into `profile`)
<br>
return profile;
<br>
}
<br>
function openFile(filePath) {
<br>
if (!fs.existsSync(filePath)) {
<br>
throw new Error('Could not find file '+filePath); // (B)
<br>
}
<br>
// ··· (Open the file whose path is `filePath`)
<br>
}
<br>

<br>
Let’s examine what happens in line B: An error occurred, but the best place to handle
<br>
the problem is not the current location, it’s line A. There, we can skip the current ﬁle and
<br>
move on to the next one.
<br>
Therefore:
<br>
• In line B, we use a throw statement to indicate that there was a problem.
<br>
• In line A, we use a try-catch statement to handle the problem.
<br>
When we throw, the following constructs are active:
<br>
readProfiles(···)
<br>
for (const filePath of filePaths)
<br>
try
<br>
readOneProfile(···)
<br>
openFile(···)
<br>
if (!fs.existsSync(filePath))
<br>
throw
<br>

<br>
One by one, throw exits the nested constructs, until it encounters a try statement. Execution continues in the catch clause of that try statement.
<br>

<br>
24.2
<br>

<br>
throw
<br>

<br>
This is the syntax of the throw statement:
<br>
throw «value»;
<br>

<br>
Any value can be thrown, but it’s best to throw an instance of Error or its subclasses.
<br>
throw new Error('Problem!');
<br>

<br>
24.3 The try statement
<br>

<br>
203
<br>

<br>
24.2.1 Options for creating error objects
<br>
• Use class Error. That is less limiting in JavaScript than in a more static language
<br>
because you can add your own properties to instances:
<br>
const err = new Error('Could not find the file');
<br>
err.filePath = filePath;
<br>
throw err;
<br>

<br>
• Use one of JavaScript’s subclasses of Error (which are listed later).
<br>
• Subclass Error yourself.
<br>
class MyError extends Error {
<br>
}
<br>
function func() {
<br>
throw new MyError('Problem!');
<br>
}
<br>
assert.throws(
<br>
() => func(),
<br>
MyError);
<br>

<br>
24.3 The try statement
<br>
The maximal version of the try statement looks as follows:
<br>
try {
<br>
«try_statements»
<br>
} catch (error) {
<br>
«catch_statements»
<br>
} finally {
<br>
«finally_statements»
<br>
}
<br>

<br>
You can combine these clauses as follows:
<br>
• try-catch
<br>
• try-finally
<br>
• try-catch-finally
<br>
Since ECMAScript 2019, you can omit the catch parameter (error), if you are not interested in the value that was thrown.
<br>

<br>
24.3.1 The try block
<br>
The try block can be considered the body of the statement. This is where we execute the
<br>
regular code.
<br>

<br>
24.3.2 The catch clause
<br>
If an exception reaches the try block, then it is assigned to the parameter of the catch
<br>
clause and the code in that clause is executed. Next, execution normally continues after
<br>

<br>
204
<br>

<br>
24 Exception handling
<br>

<br>
the try statement. That may change if:
<br>
• There is a return, break, or throw inside the catch block.
<br>
• There is a finally clause (which is always executed before the try statement ends).
<br>
The following code demonstrates that the value that is thrown in line A is indeed caught
<br>
in line B.
<br>
const errorObject = new Error();
<br>
function func() {
<br>
throw errorObject; // (A)
<br>
}
<br>
try {
<br>
func();
<br>
} catch (err) { // (B)
<br>
assert.equal(err, errorObject);
<br>
}
<br>

<br>
24.3.3 The finally clause
<br>
The code inside the finally clause is always executed at the end of a try statement – no
<br>
matter what happens in the try block or the catch clause.
<br>
Let’s look at a common use case for finally: You have created a resource and want to
<br>
always destroy it when you are done with it, no matter what happens while working
<br>
with it. You’d implement that as follows:
<br>
const resource = createResource();
<br>
try {
<br>
// Work with `resource`. Errors may be thrown.
<br>
} finally {
<br>
resource.destroy();
<br>
}
<br>

<br>
24.3.3.1
<br>

<br>
finally is always executed
<br>

<br>
The finally clause is always executed, even if an error is thrown (line A):
<br>
let finallyWasExecuted = false;
<br>
assert.throws(
<br>
() => {
<br>
try {
<br>
throw new Error(); // (A)
<br>
} finally {
<br>
finallyWasExecuted = true;
<br>
}
<br>
},
<br>
Error
<br>
);
<br>
assert.equal(finallyWasExecuted, true);
<br>

<br>
24.4 Error classes
<br>

<br>
205
<br>

<br>
And even if there is a return statement (line A):
<br>
let finallyWasExecuted = false;
<br>
function func() {
<br>
try {
<br>
return; // (A)
<br>
} finally {
<br>
finallyWasExecuted = true;
<br>
}
<br>
}
<br>
func();
<br>
assert.equal(finallyWasExecuted, true);
<br>

<br>
24.4 Error classes
<br>
Error is the common superclass of all built-in error classes. It has the following subclasses
<br>
(I’m quoting the ECMAScript speciﬁcation):
<br>

<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
RangeError: Indicates a value that is not in the set or range of allowable values.
<br>
ReferenceError: Indicate that an invalid reference value has been detected.
<br>
SyntaxError: Indicates that a parsing error has occurred.
<br>
TypeError: is used to indicate an unsuccessful operation when none of the other
<br>

<br>
NativeError objects are an appropriate indication of the failure cause.
<br>
• URIError: Indicates that one of the global URI handling functions was used in a
<br>
way that is incompatible with its deﬁnition.
<br>

<br>
24.4.1 Properties of error objects
<br>
Consider err, an instance of Error:
<br>
const err = new Error('Hello!');
<br>
assert.equal(String(err), 'Error: Hello!');
<br>

<br>
Two properties of err are especially useful:
<br>
• .message: contains just the error message.
<br>
assert.equal(err.message, 'Hello!');
<br>

<br>
• .stack: contains a stack trace. It is supported by all mainstream browsers.
<br>
assert.equal(
<br>
err.stack,
<br>
`
<br>
Error: Hello!
<br>
at ch_exception-handling.mjs:1:13
<br>
`.trim());
<br>

<br>
Exercise: Exception handling
<br>

<br>
206
<br>

<br>
24 Exception handling
<br>

<br>
exercises/exception-handling/call_function_test.mjs
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 25
<br>

<br>
Callable values
<br>
Contents
<br>
25.1 Kinds of functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
<br>
25.2 Ordinary functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
<br>
25.2.1 Parts of a function declaration . . . . . . . . . . . . . . . . . . 208
<br>
25.2.2 Roles played by ordinary functions . . . . . . . . . . . . . . . 209
<br>
25.2.3 Names of ordinary functions . . . . . . . . . . . . . . . . . . . 209
<br>
25.3 Specialized functions . . . . . . . . . . . . . . . . . . . . . . . . . . 210
<br>
25.3.1 Specialized functions are still functions . . . . . . . . . . . . . 210
<br>
25.3.2 Recommendation: prefer specialized functions . . . . . . . . . 211
<br>
25.3.3 Arrow functions . . . . . . . . . . . . . . . . . . . . . . . . . . 211
<br>
25.4 More kinds of functions and methods . . . . . . . . . . . . . . . . . 213
<br>
25.5 Returning values from functions and methods . . . . . . . . . . . . 214
<br>
25.6 Parameter handling . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
<br>
25.6.1 Terminology: parameters vs. arguments . . . . . . . . . . . . . 215
<br>
25.6.2 Terminology: callback . . . . . . . . . . . . . . . . . . . . . . 215
<br>
25.6.3 Too many or not enough arguments . . . . . . . . . . . . . . . 216
<br>
25.6.4 Parameter default values . . . . . . . . . . . . . . . . . . . . . 216
<br>
25.6.5 Rest parameters . . . . . . . . . . . . . . . . . . . . . . . . . . 216
<br>
25.6.6 Named parameters . . . . . . . . . . . . . . . . . . . . . . . . 217
<br>
25.6.7 Simulating named parameters . . . . . . . . . . . . . . . . . . 218
<br>
25.6.8 Spreading (...) into function calls . . . . . . . . . . . . . . . . 218
<br>
25.7 Dynamically evaluating code: eval(), new Function() (advanced) . 219
<br>
25.7.1 eval() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
<br>
25.7.2 new Function() . . . . . . . . . . . . . . . . . . . . . . . . . . 220
<br>
25.7.3 Recommendations . . . . . . . . . . . . . . . . . . . . . . . . 221
<br>

<br>
25.1 Kinds of functions
<br>
JavaScript has two categories of functions:
<br>
207
<br>

<br>
208
<br>

<br>
25 Callable values
<br>

<br>
• An ordinary function can play several roles:
<br>
– Real function
<br>
– Method
<br>
– Constructor function
<br>
• A specialized function can only play one of those roles – for example:
<br>
– An arrow function can only be a real function.
<br>
– A method can only be a method.
<br>
– A class can only be a constructor function.
<br>
The next two sections explain what all of those things mean.
<br>

<br>
25.2 Ordinary functions
<br>
The following code shows three ways of doing (roughly) the same thing: creating an
<br>
ordinary function.
<br>
// Function declaration (a statement)
<br>
function ordinary1(a, b, c) {
<br>
// ···
<br>
}
<br>
// const plus anonymous function expression
<br>
const ordinary2 = function (a, b, c) {
<br>
// ···
<br>
};
<br>
// const plus named function expression
<br>
const ordinary3 = function myName(a, b, c) {
<br>
// `myName` is only accessible in here
<br>
};
<br>

<br>
As we have seen in §12.8 “Declarations: scope and activation”, function declarations are
<br>
activated early, while variable declarations (e.g., via const) are not.
<br>
The syntax of function declarations and function expressions is very similar. The context
<br>
determines which is which. For more information on this kind of syntactic ambiguity,
<br>
consult §8.5 “Ambiguous syntax”.
<br>

<br>
25.2.1 Parts of a function declaration
<br>
Let’s examine the parts of a function declaration via an example:
<br>
function add(x, y) {
<br>
return x + y;
<br>
}
<br>

<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
add is the name of the function declaration.
<br>
add(x, y) is the head of the function declaration.
<br>
x and y are the parameters.
<br>

<br>
The curly braces ({ and }) and everything between them are the body of the function
<br>
declaration.
<br>

<br>
25.2 Ordinary functions
<br>

<br>
209
<br>

<br>
• The return statement explicitly returns a value from the function.
<br>

<br>
25.2.2 Roles played by ordinary functions
<br>
Consider the following function declaration from the previous section:
<br>
function add(x, y) {
<br>
return x + y;
<br>
}
<br>

<br>
This function declaration creates an ordinary function whose name is add. As an ordinary
<br>
function, add() can play three roles:
<br>
• Real function: invoked via a function call.
<br>
assert.equal(add(2, 1), 3);
<br>

<br>
• Method: stored in property, invoked via a method call.
<br>
const obj = { addAsMethod: add };
<br>
assert.equal(obj.addAsMethod(2, 4), 6); // (A)
<br>

<br>
In line A, obj is called the receiver of the method call. It can be accessed via this
<br>
inside the method.
<br>
• Constructor function/class: invoked via new.
<br>
const inst = new add();
<br>
assert.equal(inst instanceof add, true);
<br>

<br>
(As an aside, the names of classes normally start with capital letters.)
<br>

<br>
Ordinary function vs. real function
<br>
In JavaScript, we distinguish:
<br>
• The entity ordinary function
<br>
• The role real function, as played by an ordinary function
<br>
In many other programming languages, the entity function only plays one role –
<br>
function. Therefore, the same name function can be used for both.
<br>

<br>
25.2.3 Names of ordinary functions
<br>
The name of a function expression is only accessible inside the function, where the function can use it to refer to itself (e.g., for self-recursion):
<br>
const func = function funcExpr() { return funcExpr };
<br>
assert.equal(func(), func);
<br>
// The name `funcExpr` only exists inside the function:
<br>
assert.throws(() => funcExpr(), ReferenceError);
<br>

<br>
In contrast, the name of a function declaration is accessible inside the current scope:
<br>

<br>
210
<br>

<br>
25 Callable values
<br>

<br>
function funcDecl() { return funcDecl }
<br>
// The name `funcDecl` exists in the current scope
<br>
assert.equal(funcDecl(), funcDecl);
<br>

<br>
25.3 Specialized functions
<br>
Specialized functions are single-purpose versions of ordinary functions. Each one of
<br>
them specializes in a single role:
<br>
• The purpose of an arrow function is to be a real function:
<br>
const arrow = () => { return 123 };
<br>
assert.equal(arrow(), 123);
<br>

<br>
• The purpose of a method is to be a method:
<br>
const obj = { method() { return 'abc' } };
<br>
assert.equal(obj.method(), 'abc');
<br>

<br>
• The purpose of a class is to be a constructor function:
<br>
class MyClass { /* ··· */ }
<br>
const inst = new MyClass();
<br>

<br>
Apart from nicer syntax, each kind of specialized function also supports new features,
<br>
making them better at their jobs than ordinary functions.
<br>
• Arrow functions are explained later in this chapter.
<br>
• Methods are explained in the chapter on single objects.
<br>
• Classes are explained in the chapter on classes.
<br>
Tbl. 25.1 lists the capabilities of ordinary and specialized functions.
<br>
Table 25.1: Capabilities of four kinds of functions. “Implicit this” means
<br>
that this is an implicit parameter.
<br>

<br>
Function call
<br>
Method call
<br>
Constructor call
<br>

<br>
Ordinary function
<br>

<br>
Arrow function
<br>

<br>
Method
<br>

<br>
Class
<br>

<br>
implicit this
<br>

<br>
✔
<br>

<br>
implicit this
<br>

<br>
✘
<br>

<br>
✔
<br>

<br>
✘
<br>

<br>
✔
<br>

<br>
✘
<br>

<br>
✔
<br>

<br>
✘
<br>

<br>
✘
<br>

<br>
✔
<br>

<br>
25.3.1 Specialized functions are still functions
<br>
It’s important to note that arrow functions, methods, and classes are still categorized as
<br>
functions:
<br>
> (() => {}) instanceof Function
<br>
true
<br>
> ({ method() {} }.method) instanceof Function
<br>
true
<br>

<br>
25.3 Specialized functions
<br>

<br>
211
<br>

<br>
> (class SomeClass {}) instanceof Function
<br>
true
<br>

<br>
25.3.2 Recommendation: prefer specialized functions
<br>
Normally, you should prefer specialized functions over ordinary functions, especially
<br>
classes and methods. The choice between an arrow function and an ordinary function is
<br>
less clear-cut, though:
<br>
• Arrow functions don’t have this as an implicit parameter. That is almost always
<br>
what you want if you use a real function because it avoids an important thisrelated pitfall (for details, consult §28.4.6 “Avoiding the pitfalls of this”).
<br>
• However, I like the function declaration (which produces an ordinary function)
<br>
syntactically. If you don’t use this inside it, it is mostly equivalent to const plus
<br>
arrow function:
<br>
function funcDecl(x, y) {
<br>
return x * y;
<br>
}
<br>
const arrowFunc = (x, y) => {
<br>
return x * y;
<br>
};
<br>

<br>
25.3.3 Arrow functions
<br>
Arrow functions were added to JavaScript for two reasons:
<br>
1. To provide a more concise way for creating functions.
<br>
2. To make working with real functions easier: You can’t refer to the this of the surrounding scope inside an ordinary function.
<br>
Next, we’ll ﬁrst look at the syntax of arrow functions and then how they help with this.
<br>
25.3.3.1 The syntax of arrow functions
<br>
Let’s review the syntax of an anonymous function expression:
<br>
const f = function (x, y, z) { return 123 };
<br>

<br>
The (roughly) equivalent arrow function looks as follows. Arrow functions are expressions.
<br>
const f = (x, y, z) => { return 123 };
<br>

<br>
Here, the body of the arrow function is a block. But it can also be an expression. The
<br>
following arrow function works exactly like the previous one.
<br>
const f = (x, y, z) => 123;
<br>

<br>
If an arrow function has only a single parameter and that parameter is an identiﬁer (not
<br>
a destructuring pattern) then you can omit the parentheses around the parameter:
<br>
const id = x => x;
<br>

<br>
212
<br>

<br>
25 Callable values
<br>

<br>
That is convenient when passing arrow functions as parameters to other functions or
<br>
methods:
<br>
> [1,2,3].map(x => x+1)
<br>
[ 2, 3, 4 ]
<br>

<br>
This previous example demonstrates one beneﬁt of arrow functions – conciseness. If we
<br>
perform the same task with a function expression, our code is more verbose:
<br>
[1,2,3].map(function (x) { return x+1 });
<br>

<br>
25.3.3.2 Arrow functions: lexical this
<br>
Ordinary functions can be both methods and real functions. Alas, the two roles are in
<br>
conﬂict:
<br>
• As each ordinary function can be a method, it has its own this.
<br>
• The own this makes it impossible to access the this of the surrounding scope from
<br>
inside an ordinary function. And that is inconvenient for real functions.
<br>
The following code demonstrates the issue:
<br>
const person = {
<br>
name: 'Jill',
<br>
someMethod() {
<br>
const ordinaryFunc = function () {
<br>
assert.throws(
<br>
() => this.name, // (A)
<br>
/^TypeError: Cannot read property 'name' of undefined$/);
<br>
};
<br>
const arrowFunc = () => {
<br>
assert.equal(this.name, 'Jill'); // (B)
<br>
};
<br>
ordinaryFunc();
<br>
arrowFunc();
<br>
},
<br>
}
<br>

<br>
In this code, we can observe two ways of handling this:
<br>
• Dynamic this: In line A, we try to access the this of .someMethod() from an ordinary function. There, it is shadowed by the function’s own this, which is undefined (due the function call). Given that ordinary functions receive their this via
<br>
(dynamic) function or method calls, their this is called dynamic.
<br>
• Lexical this: In line B, we again try to access the this of .someMethod(). This time,
<br>
we succeed because the arrow function does not have its own this. this is resolved
<br>
lexically, just like any other variable. That’s why the this of arrow functions is
<br>
called lexical.
<br>

<br>
25.4 More kinds of functions and methods
<br>

<br>
213
<br>

<br>
25.3.3.3 Syntax pitfall: returning an object literal from an arrow function
<br>
If you want the expression body of an arrow function to be an object literal, you must put
<br>
the literal in parentheses:
<br>
const func1 = () => ({a: 1});
<br>
assert.deepEqual(func1(), { a: 1 });
<br>

<br>
If you don’t, JavaScript thinks, the arrow function has a block body (that doesn’t return
<br>
anything):
<br>
const func2 = () => {a: 1};
<br>
assert.deepEqual(func2(), undefined);
<br>
{a: 1} is interpreted as a block with the label a: and the expression statement 1. Without
<br>
an explicit return statement, the block body returns undefined.
<br>

<br>
This pitfall is caused by syntactic ambiguity: object literals and code blocks have the same
<br>
syntax. We use the parentheses to tell JavaScript that the body is an expression (an object
<br>
literal) and not a statement (a block).
<br>
For more information on shadowing this, consult §28.4.5 “this pitfall: accidentally shadowing this”.
<br>

<br>
25.4 More kinds of functions and methods
<br>
This section is a summary of upcoming content
<br>
This section mainly serves as a reference for the current and upcoming chapters.
<br>
Don’t worry if you don’t understand everything.
<br>
So far, all (real) functions and methods, that we have seen, were:
<br>
• Single-result
<br>
• Synchronous
<br>
Later chapters will cover other modes of programming:
<br>
• Iteration treats objects as containers of data (so-called iterables) and provides a standardized way for retrieving what is inside them. If a function or a method returns
<br>
an iterable, it returns multiple values.
<br>
• Asynchronous programming deals with handling a long-running computation. You
<br>
are notiﬁed when the computation is ﬁnished and can do something else in between. The standard pattern for asynchronously delivering single results is called
<br>
Promise.
<br>
These modes can be combined – for example, there are synchronous iterables and asynchronous iterables.
<br>
Several new kinds of functions and methods help with some of the mode combinations:
<br>
• Async functions help implement functions that return Promises. There are also async
<br>
methods.
<br>

<br>
214
<br>

<br>
25 Callable values
<br>

<br>
• Synchronous generator functions help implement functions that return synchronous
<br>
iterables. There are also synchronous generator methods.
<br>
• Asynchronous generator functions help implement functions that return asynchronous iterables. There are also asynchronous generator methods.
<br>
That leaves us with 4 kinds (2 × 2) of functions and methods:
<br>
• Synchronous vs. asynchronous
<br>
• Generator vs. single-result
<br>
Tbl. 25.2 gives an overview of the syntax for creating these 4 kinds of functions and methods.
<br>
Table 25.2: Syntax for creating functions and methods. The last column
<br>
speciﬁes how many values are produced by an entity.
<br>

<br>
Sync function
<br>

<br>
Sync method
<br>

<br>
function f() {}
<br>

<br>
{ m() {} }
<br>

<br>
Result
<br>

<br>
Values
<br>

<br>
value
<br>

<br>
1
<br>

<br>
iterable
<br>

<br>
0+
<br>

<br>
Promise
<br>

<br>
1
<br>

<br>
async iterable
<br>

<br>
0+
<br>

<br>
f = function () {}
<br>
f = () => {}
<br>

<br>
Sync generator function
<br>

<br>
Sync gen. method
<br>

<br>
function* f() {}
<br>

<br>
{ * m() {} }
<br>

<br>
f = function* () {}
<br>

<br>
Async function
<br>

<br>
Async method
<br>

<br>
async function f() {}
<br>

<br>
{ async m() {} }
<br>

<br>
f = async function () {}
<br>
f = async () => {}
<br>

<br>
Async generator function
<br>

<br>
Async gen. method
<br>

<br>
async function* f() {}
<br>

<br>
{ async * m() {} }
<br>

<br>
f = async function* () {}
<br>

<br>
25.5 Returning values from functions and methods
<br>
(Everything mentioned in this section applies to both functions and methods.)
<br>
The return statement explicitly returns a value from a function:
<br>
function func() {
<br>
return 123;
<br>
}
<br>
assert.equal(func(), 123);
<br>

<br>
Another example:
<br>
function boolToYesNo(bool) {
<br>
if (bool) {
<br>
return 'Yes';
<br>
} else {
<br>
return 'No';
<br>

<br>
25.6 Parameter handling
<br>

<br>
215
<br>

<br>
}
<br>
}
<br>
assert.equal(boolToYesNo(true), 'Yes');
<br>
assert.equal(boolToYesNo(false), 'No');
<br>

<br>
If, at the end of a function, you haven’t returned anything explicitly, JavaScript returns
<br>
undefined for you:
<br>
function noReturn() {
<br>
// No explicit return
<br>
}
<br>
assert.equal(noReturn(), undefined);
<br>

<br>
25.6 Parameter handling
<br>
Once again, I am only mentioning functions in this section, but everything also applies
<br>
to methods.
<br>

<br>
25.6.1 Terminology: parameters vs. arguments
<br>
The term parameter and the term argument basically mean the same thing. If you want to,
<br>
you can make the following distinction:
<br>
• Parameters are part of a function deﬁnition. They are also called formal parameters
<br>
and formal arguments.
<br>
• Arguments are part of a function call. They are also called actual parameters and
<br>
actual arguments.
<br>

<br>
25.6.2 Terminology: callback
<br>
A callback or callback function is a function that is an argument of a function or method call.
<br>
The following is an example of a callback:
<br>
const myArray = ['a', 'b'];
<br>
const callback = (x) => console.log(x);
<br>
myArray.forEach(callback);
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
JavaScript uses the term callback broadly
<br>
In other programming languages, the term callback often has a narrower meaning:
<br>
it refers to a pattern for delivering results asynchronously, via a function-valued
<br>
parameter. In this meaning, the callback (or continuation) is invoked after a function
<br>
has completely ﬁnished its computation.
<br>

<br>
216
<br>

<br>
25 Callable values
<br>

<br>
Callbacks as an asynchronous pattern, are described in the chapter on asynchronous
<br>
programming.
<br>

<br>
25.6.3 Too many or not enough arguments
<br>
JavaScript does not complain if a function call provides a different number of arguments
<br>
than expected by the function deﬁnition:
<br>
• Extra arguments are ignored.
<br>
• Missing parameters are set to undefined.
<br>
For example:
<br>
function foo(x, y) {
<br>
return [x, y];
<br>
}
<br>
// Too many arguments:
<br>
assert.deepEqual(foo('a', 'b', 'c'), ['a', 'b']);
<br>
// The expected number of arguments:
<br>
assert.deepEqual(foo('a', 'b'), ['a', 'b']);
<br>
// Not enough arguments:
<br>
assert.deepEqual(foo('a'), ['a', undefined]);
<br>

<br>
25.6.4 Parameter default values
<br>
Parameter default values specify the value to use if a parameter has not been provided –
<br>
for example:
<br>
function f(x, y=0) {
<br>
return [x, y];
<br>
}
<br>
assert.deepEqual(f(1), [1, 0]);
<br>
assert.deepEqual(f(), [undefined, 0]);
<br>
undefined also triggers the default value:
<br>
assert.deepEqual(
<br>
f(undefined, undefined),
<br>
[undefined, 0]);
<br>

<br>
25.6.5 Rest parameters
<br>
A rest parameter is declared by preﬁxing an identiﬁer with three dots (...). During a
<br>
function or method call, it receives an Array with all remaining arguments. If there are
<br>
no extra arguments at the end, it is an empty Array – for example:
<br>
function f(x, ...y) {
<br>
return [x, y];
<br>

<br>
25.6 Parameter handling
<br>

<br>
217
<br>

<br>
}
<br>
assert.deepEqual(
<br>
f('a', 'b', 'c'),
<br>
['a', ['b', 'c']]);
<br>
assert.deepEqual(
<br>
f(),
<br>
[undefined, []]);
<br>

<br>
25.6.5.1 Enforcing a certain number of arguments via a rest parameter
<br>
You can use a rest parameter to enforce a certain number of arguments. Take, for example,
<br>
the following function:
<br>
function createPoint(x, y) {
<br>
return {x, y};
<br>
// same as {x: x, y: y}
<br>
}
<br>

<br>
This is how we force callers to always provide two arguments:
<br>
function createPoint(...args) {
<br>
if (args.length !== 2) {
<br>
throw new Error('Please provide exactly 2 arguments!');
<br>
}
<br>
const [x, y] = args; // (A)
<br>
return {x, y};
<br>
}
<br>

<br>
In line A, we access the elements of args via destructuring.
<br>

<br>
25.6.6 Named parameters
<br>
When someone calls a function, the arguments provided by the caller are assigned to the
<br>
parameters received by the callee. Two common ways of performing the mapping are:
<br>
1. Positional parameters: An argument is assigned to a parameter if they have the
<br>
same position. A function call with only positional arguments looks as follows.
<br>
selectEntries(3, 20, 2)
<br>

<br>
2. Named parameters: An argument is assigned to a parameter if they have the same
<br>
name. JavaScript doesn’t have named parameters, but you can simulate them. For
<br>
example, this is a function call with only (simulated) named arguments:
<br>
selectEntries({start: 3, end: 20, step: 2})
<br>

<br>
Named parameters have several beneﬁts:
<br>
• They lead to more self-explanatory code because each argument has a descriptive
<br>
label. Just compare the two versions of selectEntries(): with the second one, it
<br>
is much easier to see what happens.
<br>
• The order of the arguments doesn’t matter (as long as the names are correct).
<br>

<br>
218
<br>

<br>
25 Callable values
<br>

<br>
• Handling more than one optional parameter is more convenient: callers can easily
<br>
provide any subset of all optional parameters and don’t have to be aware of the
<br>
ones they omit (with positional parameters, you have to ﬁll in preceding optional
<br>
parameters, with undefined).
<br>

<br>
25.6.7 Simulating named parameters
<br>
JavaScript doesn’t have real named parameters. The ofﬁcial way of simulating them is
<br>
via object literals:
<br>
function selectEntries({start=0, end=-1, step=1}) {
<br>
return {start, end, step};
<br>
}
<br>

<br>
This function uses destructuring to access the properties of its single parameter. The pattern it uses is an abbreviation for the following pattern:
<br>
{start: start=0, end: end=-1, step: step=1}
<br>

<br>
This destructuring pattern works for empty object literals:
<br>
> selectEntries({})
<br>
{ start: 0, end: -1, step: 1 }
<br>

<br>
But it does not work if you call the function without any parameters:
<br>
> selectEntries()
<br>
TypeError: Cannot destructure property `start` of 'undefined' or 'null'.
<br>

<br>
You can ﬁx this by providing a default value for the whole pattern. This default value
<br>
works the same as default values for simpler parameter deﬁnitions: if the parameter is
<br>
missing, the default is used.
<br>
function selectEntries({start=0, end=-1, step=1} = {}) {
<br>
return {start, end, step};
<br>
}
<br>
assert.deepEqual(
<br>
selectEntries(),
<br>
{ start: 0, end: -1, step: 1 });
<br>

<br>
25.6.8 Spreading (...) into function calls
<br>
If you put three dots (...) in front of the argument of a function call, then you spread it.
<br>
That means that the argument must be an iterable object and the iterated values all become
<br>
arguments. In other words, a single argument is expanded into multiple arguments – for
<br>
example:
<br>
function func(x, y) {
<br>
console.log(x);
<br>
console.log(y);
<br>
}
<br>
const someIterable = ['a', 'b'];
<br>
func(...someIterable);
<br>

<br>
219
<br>

<br>
25.7 Dynamically evaluating code: eval(), new Function() (advanced)
<br>
// same as func('a', 'b')
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
Spreading and rest parameters use the same syntax (...), but they serve opposite purposes:
<br>
• Rest parameters are used when deﬁning functions or methods. They collect arguments into Arrays.
<br>
• Spread arguments are used when calling functions or methods. They turn iterable
<br>
objects into arguments.
<br>
25.6.8.1 Example: spreading into Math.max()
<br>
Math.max() returns the largest one of its zero or more arguments. Alas, it can’t be used
<br>

<br>
for Arrays, but spreading gives us a way out:
<br>
> Math.max(-1, 5, 11, 3)
<br>
11
<br>
> Math.max(...[-1, 5, 11, 3])
<br>
11
<br>
> Math.max(-1, ...[-5, 11], 3)
<br>
11
<br>

<br>
25.6.8.2 Example: spreading into Array.prototype.push()
<br>
Similarly, the Array method .push() destructively adds its zero or more parameters to
<br>
the end of its Array. JavaScript has no method for destructively appending an Array to
<br>
another one. Once again, we are saved by spreading:
<br>
const arr1 = ['a', 'b'];
<br>
const arr2 = ['c', 'd'];
<br>
arr1.push(...arr2);
<br>
assert.deepEqual(arr1, ['a', 'b', 'c', 'd']);
<br>

<br>
Exercises: Parameter handling
<br>
• Positional parameters:
<br>

<br>
exercises/callables/positional_parameters_
<br>

<br>
test.mjs
<br>

<br>
• Named parameters: exercises/callables/named_parameters_test.mjs
<br>

<br>
25.7 Dynamically evaluating code: eval(), new
<br>
tion() (advanced)
<br>

<br>
Func-
<br>

<br>
Next, we’ll look at two ways of evaluating code dynamically: eval() and new Function().
<br>

<br>
220
<br>

<br>
25 Callable values
<br>

<br>
25.7.1
<br>

<br>
eval()
<br>

<br>
Given a string str with JavaScript code, eval(str) evaluates that code and returns the
<br>
result:
<br>
> eval('2 ** 4')
<br>
16
<br>

<br>
There are two ways of invoking eval():
<br>
• Directly, via a function call. Then the code in its argument is evaluated inside the
<br>
current scope.
<br>
• Indirectly, not via a function call. Then it evaluates its code in global scope.
<br>
“Not via a function call” means “anything that looks different than eval(···)”:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
eval.call(undefined, '···')
<br>
(0, eval)('···') (uses the comma operator)
<br>
globalThis.eval('···')
<br>
const e = eval; e('···')
<br>

<br>
Etc.
<br>

<br>
The following code illustrates the difference:
<br>
globalThis.myVariable = 'global';
<br>
function func() {
<br>
const myVariable = 'local';
<br>
// Direct eval
<br>
assert.equal(eval('myVariable'), 'local');
<br>
// Indirect eval
<br>
assert.equal(eval.call(undefined, 'myVariable'), 'global');
<br>
}
<br>

<br>
Evaluating code in global context is safer because the code has access to fewer internals.
<br>

<br>
25.7.2
<br>

<br>
new Function()
<br>

<br>
new Function() creates a function object and is invoked as follows:
<br>
const func = new Function('«param_1»', ···, '«param_n»', '«func_body»');
<br>

<br>
The previous statement is equivalent to the next statement. Note that «param_1», etc., are
<br>
not inside string literals, anymore.
<br>
const func = function («param_1», ···, «param_n») {
<br>
«func_body»
<br>
};
<br>

<br>
In the next example, we create the same function twice, ﬁrst via new Function(), then
<br>
via a function expression:
<br>
const times1 = new Function('a', 'b', 'return a * b');
<br>
const times2 = function (a, b) { return a * b };
<br>

<br>
25.7 Dynamically evaluating code: eval(), new Function() (advanced)
<br>

<br>
221
<br>

<br>
new Function() creates non-strict mode functions
<br>

<br>
Functions created via new Function() are sloppy.
<br>

<br>
25.7.3 Recommendations
<br>
Avoid dynamic evaluation of code as much as you can:
<br>
• It’s a security risk because it may enable an attacker to execute arbitrary code with
<br>
the privileges of your code.
<br>
• It may be switched off – for example, in browsers, via a Content Security Policy.
<br>
Very often, JavaScript is dynamic enough so that you don’t need eval() or similar. In the
<br>
following example, what we are doing with eval() (line A) can be achieved just as well
<br>
without it (line B).
<br>
const obj = {a: 1, b: 2};
<br>
const propKey = 'b';
<br>
assert.equal(eval('obj.' + propKey), 2); // (A)
<br>
assert.equal(obj[propKey], 2); // (B)
<br>

<br>
If you have to dynamically evaluate code:
<br>
• Prefer new Function() over eval(): it always executes its code in global context
<br>
and a function provides a clean interface to the evaluated code.
<br>
• Prefer indirect eval over direct eval: evaluating code in global context is safer.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
222
<br>

<br>
25 Callable values
<br>

<br>
Chapter 26
<br>

<br>
Environments: under the hood of
<br>
variables (bonus)
<br>
Contents
<br>
26.1 Environment: data structure for managing variables . . . . . . . . . 223
<br>
26.2 Recursion via environments . . . . . . . . . . . . . . . . . . . . . . . 223
<br>
26.2.1 Executing the code . . . . . . . . . . . . . . . . . . . . . . . . 224
<br>
26.3 Nested scopes via environments . . . . . . . . . . . . . . . . . . . . 224
<br>
26.3.1 Executing the code . . . . . . . . . . . . . . . . . . . . . . . . 226
<br>
26.4 Closures and environments . . . . . . . . . . . . . . . . . . . . . . . 228
<br>

<br>
In this chapter, we take a closer look at how the ECMAScript language speciﬁcation handles variables.
<br>

<br>
26.1 Environment: data structure for managing variables
<br>
An environment is the data structure that the ECMAScript speciﬁcation uses to manage
<br>
variables. It is a dictionary whose keys are variable names and whose values are the
<br>
values of those variables. Each scope has its associated environment. Environments must
<br>
be able to support the following phenomena related to variables:
<br>
• Recursion
<br>
• Nested scopes
<br>
• Closures
<br>
We’ll use examples to illustrate how that is done for each phenomenon.
<br>

<br>
26.2 Recursion via environments
<br>
We’ll tackle recursion ﬁrst. Consider the following code:
<br>
223
<br>

<br>
224
<br>

<br>
26 Environments: under the hood of variables (bonus)
<br>

<br>
function f(x) {
<br>
return x * 2;
<br>
}
<br>
function g(y) {
<br>
const tmp = y + 1;
<br>
return f(tmp);
<br>
}
<br>
assert.equal(g(3), 8);
<br>

<br>
For each function call, you need fresh storage space for the variables (parameters and
<br>
local variables) of the called function. This is managed via a stack of so-called execution
<br>
contexts, which are references to environments (for the purpose of this chapter). Environments themselves are stored on the heap. That is necessary because they occasionally live
<br>
on after execution has left their scopes (we’ll see that when exploring closures). Therefore,
<br>
they themselves can’t be managed via a stack.
<br>

<br>
26.2.1 Executing the code
<br>
While executing the code, we make the following pauses:
<br>
function f(x) {
<br>
// Pause 3
<br>
return x * 2;
<br>
}
<br>
function g(y) {
<br>
const tmp = y + 1;
<br>
// Pause 2
<br>
return f(tmp);
<br>
}
<br>
// Pause 1
<br>
assert.equal(g(3), 8);
<br>

<br>
This is what happens:
<br>
• Pause 1 – before calling g() (ﬁg. 26.1).
<br>
• Pause 2 – while executing g() (ﬁg. 26.2).
<br>
• Pause 3 – while executing f() (ﬁg. 26.3).
<br>
• Remaining steps: Every time there is a return, one execution context is removed
<br>
from the stack.
<br>

<br>
26.3 Nested scopes via environments
<br>
We use the following code to explore how nested scopes are implemented via environments.
<br>
function f(x) {
<br>
function square() {
<br>
const result = x * x;
<br>

<br>
225
<br>

<br>
26.3 Nested scopes via environments
<br>

<br>
Execution contexts
<br>
0
<br>

<br>
Lexical environments
<br>
f
<br>

<br>
function (x) { … }
<br>

<br>
g
<br>

<br>
function (y) { … }
<br>

<br>
Figure 26.1: Recursion, pause 1 – before calling g(): The execution context stack has
<br>
one entry, which points to the top-level environment. In that environment, there are two
<br>
entries; one for f() and one for g().
<br>

<br>
Execution contexts
<br>

<br>
Lexical environments
<br>

<br>
0
<br>

<br>
f
<br>

<br>
function (x) { … }
<br>

<br>
1
<br>

<br>
g
<br>

<br>
function (y) { … }
<br>

<br>
y
<br>

<br>
3
<br>

<br>
tmp
<br>

<br>
4
<br>

<br>
Figure 26.2: Recursion, pause 2 – while executing g(): The top of the execution context
<br>
stack points to the environment that was created for g(). That environment contains
<br>
entries for the argument y and for the local variable tmp.
<br>

<br>
Execution contexts
<br>

<br>
Lexical environments
<br>

<br>
0
<br>

<br>
f
<br>

<br>
function (x) { … }
<br>

<br>
1
<br>

<br>
g
<br>

<br>
function (y) { … }
<br>

<br>
y
<br>

<br>
3
<br>

<br>
tmp
<br>

<br>
4
<br>

<br>
x
<br>

<br>
4
<br>

<br>
2
<br>

<br>
Figure 26.3: Recursion, pause 3 – while executing f(): The top execution context now
<br>
points to the environment for f().
<br>

<br>
226
<br>

<br>
26 Environments: under the hood of variables (bonus)
<br>
return result;
<br>
}
<br>
return square();
<br>

<br>
}
<br>
assert.equal(f(6), 36);
<br>

<br>
Here, we have three nested scopes: The top-level scope, the scope of f(), and the scope
<br>
of square(). Observations:
<br>
• The scopes are connected. An inner scope “inherits” all the variables of an outer
<br>
scope (minus the ones it shadows).
<br>
• Nesting scopes as a mechanism is independent of recursion. The latter is best managed by a stack of independent environments. The former is a relationship that
<br>
each environment has with the environment “in which” it is created.
<br>
Therefore, the environment of each scope points to the environment of the surrounding
<br>
scope via a ﬁeld called outer. When we are looking up the value of a variable, we ﬁrst
<br>
search for its name in the current environment, then in the outer environment, then in
<br>
the outer environment’s outer environment, etc. The whole chain of outer environments
<br>
contains all variables that can currently be accessed (minus shadowed variables).
<br>
When you make a function call, you create a new environment. The outer environment
<br>
of that environment is the environment in which the function was created. To help set up
<br>
the ﬁeld outer of environments created via function calls, each function has an internal
<br>
property named [[Scope]] that points to its “birth environment”.
<br>

<br>
26.3.1 Executing the code
<br>
These are the pauses we are making while executing the code:
<br>
function f(x) {
<br>
function square() {
<br>
const result = x * x;
<br>
// Pause 3
<br>
return result;
<br>
}
<br>
// Pause 2
<br>
return square();
<br>
}
<br>
// Pause 1
<br>
assert.equal(f(6), 36);
<br>

<br>
This is what happens:
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Pause 1 – before calling f() (ﬁg. 26.4).
<br>
Pause 2 – while executing f() (ﬁg. 26.5).
<br>
Pause 3 – while executing square() (ﬁg. 26.6).
<br>
After that, return statements pop execution entries off the stack.
<br>

<br>
227
<br>

<br>
26.3 Nested scopes via environments
<br>

<br>
Execution contexts
<br>
0
<br>

<br>
Lexical environments
<br>

<br>
Functions
<br>

<br>
f
<br>

<br>
[[Scope]]
<br>

<br>
Figure 26.4: Nested scopes, pause 1 – before calling f(): The top-level environment has
<br>
a single entry, for f(). The birth environment of f() is the top-level environment. Therefore, f’s [[Scope]] points to it.
<br>

<br>
Execution contexts
<br>
0
<br>

<br>
Lexical environments
<br>

<br>
Functions
<br>

<br>
f
<br>

<br>
[[Scope]]
<br>

<br>
1
<br>
outer
<br>
x
<br>

<br>
f(6)
<br>

<br>
6
<br>

<br>
square
<br>

<br>
[[Scope]]
<br>

<br>
Figure 26.5: Nested scopes, pause 2 – while executing f(): There is now an environment
<br>
for the function call f(6). The outer environment of that environment is the birth environment of f() (the top-level environment at index 0). We can see that the ﬁeld outer
<br>
was set to the value of f’s [[Scope]]. Furthermore, the [[Scope]] of the new function
<br>
square() is the environment that was just created.
<br>

<br>
Execution contexts
<br>
0
<br>

<br>
Lexical environments
<br>

<br>
Functions
<br>

<br>
f
<br>

<br>
[[Scope]]
<br>

<br>
1
<br>
outer
<br>

<br>
2
<br>

<br>
f(6)
<br>

<br>
x
<br>

<br>
6
<br>

<br>
square
<br>

<br>
[[Scope]]
<br>
outer
<br>
square()
<br>

<br>
result
<br>

<br>
36
<br>

<br>
Figure 26.6: Nested scopes, pause 3 – while executing square(): The previous pattern
<br>
was repeated: the outer of the most recent environment was set up via the [[Scope]]
<br>
of the function that we just called. The chain of scopes created via outer, contains all
<br>
variables that are active right now. For example, we can access result, square, and f
<br>
if we want to. Environments reﬂect two aspects of variables. First, the chain of outer
<br>
environments reﬂects the nested static scopes. Second, the stack of execution contexts
<br>
reﬂects what function calls were made, dynamically.
<br>

<br>
228
<br>

<br>
26 Environments: under the hood of variables (bonus)
<br>

<br>
26.4 Closures and environments
<br>
To see how environments are used to implement closures, we are using the following
<br>
example:
<br>
function add(x) {
<br>
return (y) => { // (A)
<br>
return x + y;
<br>
};
<br>
}
<br>
assert.equal(add(3)(1), 4); // (B)
<br>

<br>
What is going on here? add() is a function that returns a function. When we make the
<br>
nested function call add(3)(1) in line B, the ﬁrst parameter is for add(), the second parameter is for the function it returns. This works because the function created in line A
<br>
does not lose the connection to its birth scope when it leaves that scope. The associated
<br>
environment is kept alive by that connection and the function still has access to variable
<br>
x in that environment (x is free inside the function).
<br>
This nested way of calling add() has an advantage: if you only make the ﬁrst function
<br>
call, you get a version of add() whose parameter x is already ﬁlled in:
<br>
const plus2 = add(2);
<br>
assert.equal(plus2(5), 7);
<br>

<br>
Converting a function with two parameters into two nested functions with one parameter
<br>
each, is called currying. add() is a curried function.
<br>
Only ﬁlling in some of the parameters of a function is called partial application (the function
<br>
has not been fully applied yet). Method .bind() of functions performs partial application. In the previous example, we can see that partial application is simple if a function
<br>
is curried.
<br>
26.4.0.1 Executing the code
<br>
As we are executing the following code, we are making three pauses:
<br>
function add(x) {
<br>
return (y) => {
<br>
// Pause 3: plus2(5)
<br>
return x + y;
<br>
}; // Pause 1: add(2)
<br>
}
<br>
const plus2 = add(2);
<br>
// Pause 2
<br>
assert.equal(plus2(5), 7);
<br>

<br>
This is what happens:
<br>
• Pause 1 – during the execution of add(2) (ﬁg. 26.7).
<br>
• Pause 2 – after the execution of add(2) (ﬁg. 26.8).
<br>
• Pause 3 – while executing plus2(5) (ﬁg. 26.9).
<br>

<br>
229
<br>

<br>
26.4 Closures and environments
<br>

<br>
Execution contexts
<br>

<br>
Lexical environments
<br>

<br>
0
<br>

<br>
add
<br>

<br>
1
<br>

<br>
plus2
<br>

<br>
Functions
<br>
[[Scope]]
<br>

<br>
(uninit.)
<br>
outer
<br>

<br>
x
<br>

<br>
add(2)
<br>

<br>
2
<br>

<br>
[[Scope]]
<br>

<br>
Figure 26.7: Closures, pause 1 – during the execution of add(2): We can see that the
<br>
function returned by add() already exists (see bottom right corner) and that it points to
<br>
its birth environment via its internal property [[Scope]]. Note that plus2 is still in its
<br>
temporal dead zone and uninitialized.
<br>

<br>
Execution contexts
<br>
0
<br>

<br>
Lexical environments
<br>
add
<br>

<br>
Functions
<br>
[[Scope]]
<br>

<br>
plus2
<br>
outer
<br>

<br>
Kept alive by closure
<br>
x
<br>

<br>
add(2)
<br>

<br>
2
<br>

<br>
[[Scope]]
<br>

<br>
Figure 26.8: Closures, pause 2 – after the execution of add(2): plus2 now points to the
<br>
function returned by add(2). That function keeps its birth environment (the environment
<br>
of add(2)) alive via its [[Scope]].
<br>

<br>
Execution contexts
<br>

<br>
Lexical environments
<br>

<br>
0
<br>

<br>
add
<br>

<br>
1
<br>

<br>
plus2
<br>

<br>
[[Scope]]
<br>

<br>
outer
<br>
x
<br>

<br>
add(2)
<br>

<br>
2
<br>
outer
<br>

<br>
y
<br>

<br>
Functions
<br>

<br>
[[Scope]]
<br>

<br>
plus2(5)
<br>

<br>
5
<br>

<br>
Figure 26.9: Closures, pause 3 – while executing plus2(5): The [[Scope]] of plus2 is
<br>
used to set up the outer of the new environment. That’s how the current function gets
<br>
access to x.
<br>

<br>
230
<br>

<br>
26 Environments: under the hood of variables (bonus)
<br>

<br>
Part VI
<br>

<br>
Modularity
<br>

<br>
231
<br>

<br>
Chapter 27
<br>

<br>
Modules
<br>
Contents
<br>
27.1 Overview: syntax of ECMAScript modules . . . . . . . . . . . . . . 234
<br>
27.1.1 Exporting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
<br>
27.1.2 Importing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
<br>
27.2 JavaScript source code formats . . . . . . . . . . . . . . . . . . . . . 235
<br>
27.2.1 Code before built-in modules was written in ECMAScript 5 . . 235
<br>
27.3 Before we had modules, we had scripts . . . . . . . . . . . . . . . . 235
<br>
27.4 Module systems created prior to ES6 . . . . . . . . . . . . . . . . . . 236
<br>
27.4.1 Server side: CommonJS modules
<br>

<br>
. . . . . . . . . . . . . . . . 237
<br>

<br>
27.4.2 Client side: AMD (Asynchronous Module Deﬁnition) modules 237
<br>
27.4.3 Characteristics of JavaScript modules . . . . . . . . . . . . . . 238
<br>
27.5 ECMAScript modules . . . . . . . . . . . . . . . . . . . . . . . . . . 238
<br>
27.5.1 ES modules: syntax, semantics, loader API . . . . . . . . . . . 239
<br>
27.6 Named exports and imports . . . . . . . . . . . . . . . . . . . . . . . 239
<br>
27.6.1 Named exports . . . . . . . . . . . . . . . . . . . . . . . . . . 239
<br>
27.6.2 Named imports . . . . . . . . . . . . . . . . . . . . . . . . . . 240
<br>
27.6.3 Namespace imports . . . . . . . . . . . . . . . . . . . . . . . . 241
<br>
27.6.4 Named exporting styles: inline versus clause (advanced) . . . 241
<br>
27.7 Default exports and imports . . . . . . . . . . . . . . . . . . . . . . . 241
<br>
27.7.1 The two styles of default-exporting . . . . . . . . . . . . . . . 242
<br>
27.7.2 The default export as a named export (advanced)
<br>

<br>
. . . . . . . 243
<br>

<br>
27.8 More details on exporting and importing . . . . . . . . . . . . . . . 244
<br>
27.8.1 Imports are read-only views on exports . . . . . . . . . . . . . 244
<br>
27.8.2 ESM’s transparent support for cyclic imports (advanced) . . . 245
<br>
27.9 npm packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
<br>
27.9.1 Packages are installed inside a directory node_modules/ . . . . 246
<br>
27.9.2 Why can npm be used to install frontend libraries? . . . . . . . 247
<br>
27.10Naming modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
<br>
27.11Module speciﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
<br>

<br>
233
<br>

<br>
234
<br>

<br>
27 Modules
<br>
27.11.1 Categories of module speciﬁers . . . . . . . . . . . . . . . . . 248
<br>
27.11.2 ES module speciﬁers in browsers . . . . . . . . . . . . . . . . 248
<br>
27.11.3 ES module speciﬁers on Node.js . . . . . . . . . . . . . . . . . 249
<br>
27.12Loading modules dynamically via import() . . . . . . . . . . . . . . 250
<br>
27.12.1 Example: loading a module dynamically . . . . . . . . . . . . 250
<br>
27.12.2 Use cases for import() . . . . . . . . . . . . . . . . . . . . . . 251
<br>
27.13Preview: import.meta.url . . . . . . . . . . . . . . . . . . . . . . . . 252
<br>
27.13.1 import.meta.url and class URL . . . . . . . . . . . . . . . . . 252
<br>
27.13.2 import.meta.url on Node.js . . . . . . . . . . . . . . . . . . . 253
<br>
27.14Polyﬁlls: emulating native web platform features (advanced) . . . . 254
<br>
27.14.1 Sources of this section
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . 254
<br>

<br>
27.1 Overview: syntax of ECMAScript modules
<br>
27.1.1 Exporting
<br>
// Named exports
<br>
export function f() {}
<br>
export const one = 1;
<br>
export {foo, b as bar};
<br>
// Default exports
<br>
export default function f() {} // declaration with optional name
<br>
// Replacement for `const` (there must be exactly one value)
<br>
export default 123;
<br>
// Re-exporting from another module
<br>
export * from './some-module.mjs';
<br>
export {foo, b as bar} from './some-module.mjs';
<br>

<br>
27.1.2 Importing
<br>
// Named imports
<br>
import {foo, bar as b} from './some-module.mjs';
<br>
// Namespace import
<br>
import * as someModule from './some-module.mjs';
<br>
// Default import
<br>
import someModule from './some-module.mjs';
<br>
// Combinations:
<br>
import someModule, * as someModule from './some-module.mjs';
<br>
import someModule, {foo, bar as b} from './some-module.mjs';
<br>
// Empty import (for modules with side effects)
<br>
import './some-module.mjs';
<br>

<br>
235
<br>

<br>
27.3 Before we had modules, we had scripts
<br>

<br>
27.2 JavaScript source code formats
<br>
The current landscape of JavaScript modules is quite diverse: ES6 brought built-in modules, but the source code formats that came before them, are still around, too. Understanding the latter helps understand the former, so let’s investigate. The next sections
<br>
describe the following ways of delivering JavaScript source code:
<br>
• Scripts are code fragments that browsers run in global scope. They are precursors
<br>
of modules.
<br>
• CommonJS modules are a module format that is mainly used on servers (e.g., via
<br>
Node.js).
<br>
• AMD modules are a module format that is mainly used in browsers.
<br>
• ECMAScript modules are JavaScript’s built-in module format. It supersedes all previous formats.
<br>
Tbl. 27.1 gives an overview of these code formats. Note that for CommonJS modules
<br>
and ECMAScript modules, two ﬁlename extensions are commonly used. Which one is
<br>
appropriate depends on how you want to use a ﬁle. Details are given later in this chapter.
<br>
Table 27.1: Ways of delivering JavaScript source code.
<br>

<br>
Script
<br>
CommonJS module
<br>
AMD module
<br>
ECMAScript module
<br>

<br>
Runs on
<br>

<br>
Loaded
<br>

<br>
Filename ext.
<br>

<br>
browsers
<br>
servers
<br>
browsers
<br>
browsers and servers
<br>

<br>
async
<br>
sync
<br>
async
<br>
async
<br>

<br>
.js
<br>
.js .cjs
<br>
.js
<br>
.js .mjs
<br>

<br>
27.2.1 Code before built-in modules was written in ECMAScript 5
<br>
Before we get to built-in modules (which were introduced with ES6), all code that you’ll
<br>
see, will be written in ES5. Among other things:
<br>
• ES5 did not have const and let, only var.
<br>
• ES5 did not have arrow functions, only function expressions.
<br>

<br>
27.3 Before we had modules, we had scripts
<br>
Initially, browsers only had scripts – pieces of code that were executed in global scope. As
<br>
an example, consider an HTML ﬁle that loads script ﬁles via the following HTML:
<br>
<script src="other-module1.js"></script>
<br>
<script src="other-module2.js"></script>
<br>
<script src="my-module.js"></script>
<br>

<br>
The main ﬁle is my-module.js, where we simulate a module:
<br>
var myModule = (function () { // Open IIFE
<br>
// Imports (via global variables)
<br>
var importedFunc1 = otherModule1.importedFunc1;
<br>

<br>
236
<br>

<br>
27 Modules
<br>
var importedFunc2 = otherModule2.importedFunc2;
<br>
// Body
<br>
function internalFunc() {
<br>
// ···
<br>
}
<br>
function exportedFunc() {
<br>
importedFunc1();
<br>
importedFunc2();
<br>
internalFunc();
<br>
}
<br>
// Exports (assigned to global variable `myModule`)
<br>
return {
<br>
exportedFunc: exportedFunc,
<br>
};
<br>

<br>
})(); // Close IIFE
<br>
myModule is a global variable that is assigned the result of immediately invoking a func-
<br>

<br>
tion expression. The function expression starts in the ﬁrst line. It is invoked in the last
<br>
line.
<br>
This way of wrapping a code fragment is called immediately invoked function expression
<br>
(IIFE, coined by Ben Alman). What do we gain from an IIFE? var is not block-scoped (like
<br>
const and let), it is function-scoped: the only way to create new scopes for var-declared
<br>
variables is via functions or methods (with const and let, you can use either functions,
<br>
methods, or blocks {}). Therefore, the IIFE in the example hides all of the following variables from global scope and minimizes name clashes: importedFunc1, importedFunc2,
<br>
internalFunc, exportedFunc.
<br>
Note that we are using an IIFE in a particular manner: at the end, we pick what we
<br>
want to export and return it via an object literal. That is called the revealing module pattern
<br>
(coined by Christian Heilmann).
<br>
This way of simulating modules, has several issues:
<br>
• Libraries in script ﬁles export and import functionality via global variables, which
<br>
risks name clashes.
<br>
• Dependencies are not stated explicitly, and there is no built-in way for a script to
<br>
load the scripts it depends on. Therefore, the web page has to load not just the
<br>
scripts that are needed by the page but also the dependencies of those scripts, the
<br>
dependencies’ dependencies, etc. And it has to do so in the right order!
<br>

<br>
27.4 Module systems created prior to ES6
<br>
Prior to ECMAScript 6, JavaScript did not have built-in modules. Therefore, the ﬂexible syntax of the language was used to implement custom module systems within the
<br>
language. Two popular ones are:
<br>
• CommonJS (targeting the server side)
<br>

<br>
27.4 Module systems created prior to ES6
<br>

<br>
237
<br>

<br>
• AMD (Asynchronous Module Deﬁnition, targeting the client side)
<br>

<br>
27.4.1 Server side: CommonJS modules
<br>
The original CommonJS standard for modules was created for server and desktop platforms. It was the foundation of the original Node.js module system, where it achieved
<br>
enormous popularity. Contributing to that popularity were the npm package manager
<br>
for Node and tools that enabled using Node modules on the client side (browserify, webpack, and others).
<br>
From now on, CommonJS module means the Node.js version of this standard (which has a
<br>
few additional features). This is an example of a CommonJS module:
<br>
// Imports
<br>
var importedFunc1 = require('./other-module1.js').importedFunc1;
<br>
var importedFunc2 = require('./other-module2.js').importedFunc2;
<br>
// Body
<br>
function internalFunc() {
<br>
// ···
<br>
}
<br>
function exportedFunc() {
<br>
importedFunc1();
<br>
importedFunc2();
<br>
internalFunc();
<br>
}
<br>
// Exports
<br>
module.exports = {
<br>
exportedFunc: exportedFunc,
<br>
};
<br>

<br>
CommonJS can be characterized as follows:
<br>
• Designed for servers.
<br>
• Modules are meant to be loaded synchronously (the importer waits while the imported module is loaded and executed).
<br>
• Compact syntax.
<br>

<br>
27.4.2 Client side: AMD (Asynchronous Module Deﬁnition) modules
<br>
The AMD module format was created to be easier to use in browsers than the CommonJS
<br>
format. Its most popular implementation is RequireJS. The following is an example of an
<br>
AMD module.
<br>
define(['./other-module1.js', './other-module2.js'],
<br>
function (otherModule1, otherModule2) {
<br>
var importedFunc1 = otherModule1.importedFunc1;
<br>
var importedFunc2 = otherModule2.importedFunc2;
<br>
function internalFunc() {
<br>

<br>
238
<br>

<br>
27 Modules
<br>
// ···
<br>
}
<br>
function exportedFunc() {
<br>
importedFunc1();
<br>
importedFunc2();
<br>
internalFunc();
<br>
}
<br>
return {
<br>
exportedFunc: exportedFunc,
<br>
};
<br>
});
<br>

<br>
AMD can be characterized as follows:
<br>
• Designed for browsers.
<br>
• Modules are meant to be loaded asynchronously. That’s a crucial requirement for
<br>
browsers, where code can’t wait until a module has ﬁnished downloading. It has
<br>
to be notiﬁed once the module is available.
<br>
• The syntax is slightly more complicated.
<br>
On the plus side, AMD modules can be executed directly. In contrast, CommonJS modules must either be compiled before deployment or custom source code must be generated and evaluated dynamically (think eval()). That isn’t always permitted on the web.
<br>

<br>
27.4.3 Characteristics of JavaScript modules
<br>
Looking at CommonJS and AMD, similarities between JavaScript module systems
<br>
emerge:
<br>
• There is one module per ﬁle.
<br>
• Such a ﬁle is basically a piece of code that is executed:
<br>
– Local scope: The code is executed in a local “module scope”. Therefore, by
<br>
default, all of the variables, functions, and classes declared in it are internal
<br>
and not global.
<br>
– Exports: If you want any declared entity to be exported, you must explicitly
<br>
mark it as an export.
<br>
– Imports: Each module can import exported entities from other modules.
<br>
Those other modules are identiﬁed via module speciﬁers (usually paths,
<br>
occasionally full URLs).
<br>
• Modules are singletons: Even if a module is imported multiple times, only a single
<br>
“instance” of it exists.
<br>
• No global variables are used. Instead, module speciﬁers serve as global IDs.
<br>

<br>
27.5 ECMAScript modules
<br>
ECMAScript modules (ES modules or ESM) were introduced with ES6. They continue the
<br>
tradition of JavaScript modules and have all of their aforementioned characteristics. Additionally:
<br>

<br>
27.6 Named exports and imports
<br>

<br>
239
<br>

<br>
• With CommonJS, ES modules share the compact syntax and support for cyclic dependencies.
<br>
• With AMD, ES modules share being designed for asynchronous loading.
<br>
ES modules also have new beneﬁts:
<br>
• The syntax is even more compact than CommonJS’s.
<br>
• Modules have static structures (which can’t be changed at runtime). That helps
<br>
with static checking, optimized access of imports, dead code elimination, and
<br>
more.
<br>
• Support for cyclic imports is completely transparent.
<br>
This is an example of ES module syntax:
<br>
import {importedFunc1} from './other-module1.mjs';
<br>
import {importedFunc2} from './other-module2.mjs';
<br>
function internalFunc() {
<br>
···
<br>
}
<br>
export function exportedFunc() {
<br>
importedFunc1();
<br>
importedFunc2();
<br>
internalFunc();
<br>
}
<br>

<br>
From now on, “module” means “ECMAScript module”.
<br>

<br>
27.5.1 ES modules: syntax, semantics, loader API
<br>
The full standard of ES modules comprises the following parts:
<br>
1. Syntax (how code is written): What is a module? How are imports and exports
<br>
declared? Etc.
<br>
2. Semantics (how code is executed): How are variable bindings exported? How are
<br>
imports connected with exports? Etc.
<br>
3. A programmatic loader API for conﬁguring module loading.
<br>
Parts 1 and 2 were introduced with ES6. Work on part 3 is ongoing.
<br>

<br>
27.6 Named exports and imports
<br>
27.6.1 Named exports
<br>
Each module can have zero or more named exports.
<br>
As an example, consider the following two ﬁles:
<br>
lib/my-math.mjs
<br>
main.mjs
<br>

<br>
Module my-math.mjs has two named exports: square and LIGHTSPEED.
<br>

<br>
240
<br>

<br>
27 Modules
<br>

<br>
// Not exported, private to module
<br>
function times(a, b) {
<br>
return a * b;
<br>
}
<br>
export function square(x) {
<br>
return times(x, x);
<br>
}
<br>
export const LIGHTSPEED = 299792458;
<br>

<br>
To export something, we put the keyword export in front of a declaration. Entities that
<br>
are not exported are private to a module and can’t be accessed from outside.
<br>

<br>
27.6.2 Named imports
<br>
Module main.mjs has a single named import, square:
<br>
import {square} from './lib/my-math.mjs';
<br>
assert.equal(square(3), 9);
<br>

<br>
It can also rename its import:
<br>
import {square as sq} from './lib/my-math.mjs';
<br>
assert.equal(sq(3), 9);
<br>

<br>
27.6.2.1 Syntactic pitfall: named importing is not destructuring
<br>
Both named importing and destructuring look similar:
<br>
import {foo} from './bar.mjs'; // import
<br>
const {foo} = require('./bar.mjs'); // destructuring
<br>

<br>
But they are quite different:
<br>
• Imports remain connected with their exports.
<br>
• You can destructure again inside a destructuring pattern, but the {} in an import
<br>
statement can’t be nested.
<br>
• The syntax for renaming is different:
<br>
import {foo as f} from './bar.mjs'; // importing
<br>
const {foo: f} = require('./bar.mjs'); // destructuring
<br>

<br>
Rationale: Destructuring is reminiscent of an object literal (including nesting),
<br>
while importing evokes the idea of renaming.
<br>

<br>
Exercise: Named exports
<br>
exercises/modules/export_named_test.mjs
<br>

<br>
27.7 Default exports and imports
<br>

<br>
241
<br>

<br>
27.6.3 Namespace imports
<br>
Namespace imports are an alternative to named imports. If we namespace-import a module, it becomes an object whose properties are the named exports. This is what main.mjs
<br>
looks like if we use a namespace import:
<br>
import * as myMath from './lib/my-math.mjs';
<br>
assert.equal(myMath.square(3), 9);
<br>
assert.deepEqual(
<br>
Object.keys(myMath), ['LIGHTSPEED', 'square']);
<br>

<br>
27.6.4 Named exporting styles: inline versus clause (advanced)
<br>
The named export style we have seen so far was inline: We exported entities by preﬁxing
<br>
them with the keyword export.
<br>
But we can also use separate export clauses. For example, this is what lib/my-math.mjs
<br>
looks like with an export clause:
<br>
function times(a, b) {
<br>
return a * b;
<br>
}
<br>
function square(x) {
<br>
return times(x, x);
<br>
}
<br>
const LIGHTSPEED = 299792458;
<br>
export { square, LIGHTSPEED }; // semicolon!
<br>

<br>
With an export clause, we can rename before exporting and use different names internally:
<br>
function times(a, b) {
<br>
return a * b;
<br>
}
<br>
function sq(x) {
<br>
return times(x, x);
<br>
}
<br>
const LS = 299792458;
<br>
export {
<br>
sq as square,
<br>
LS as LIGHTSPEED, // trailing comma is optional
<br>
};
<br>

<br>
27.7 Default exports and imports
<br>
Each module can have at most one default export. The idea is that the module is the defaultexported value.
<br>

<br>
242
<br>

<br>
27 Modules
<br>

<br>
Avoid mixing named exports and default exports
<br>
A module can have both named exports and a default export, but it’s usually better
<br>
to stick to one export style per module.
<br>

<br>
As an example for default exports, consider the following two ﬁles:
<br>
my-func.mjs
<br>
main.mjs
<br>

<br>
Module my-func.mjs has a default export:
<br>
const GREETING = 'Hello!';
<br>
export default function () {
<br>
return GREETING;
<br>
}
<br>

<br>
Module main.mjs default-imports the exported function:
<br>
import myFunc from './my-func.mjs';
<br>
assert.equal(myFunc(), 'Hello!');
<br>

<br>
Note the syntactic difference: the curly braces around named imports indicate that we
<br>
are reaching into the module, while a default import is the module.
<br>

<br>
What are use cases for default exports?
<br>
The most common use case for a default export is a module that contains a single
<br>
function or a single class.
<br>

<br>
27.7.1 The two styles of default-exporting
<br>
There are two styles of doing default exports.
<br>
First, you can label existing declarations with export default:
<br>
export default function foo() {} // no semicolon!
<br>
export default class Bar {} // no semicolon!
<br>

<br>
Second, you can directly default-export values. In that style, export default is itself
<br>
much like a declaration.
<br>
export default 'abc';
<br>
export default foo();
<br>
export default /^xyz$/;
<br>
export default 5 * 7;
<br>
export default { no: false, yes: true };
<br>

<br>
27.7 Default exports and imports
<br>

<br>
243
<br>

<br>
27.7.1.1 Why are there two default export styles?
<br>
The reason is that export default can’t be used to label const: const may deﬁne multiple
<br>
values, but export default needs exactly one value. Consider the following hypothetical
<br>
code:
<br>
// Not legal JavaScript!
<br>
export default const foo = 1, bar = 2, baz = 3;
<br>

<br>
With this code, you don’t know which one of the three values is the default export.
<br>

<br>
Exercise: Default exports
<br>
exercises/modules/export_default_test.mjs
<br>

<br>
27.7.2 The default export as a named export (advanced)
<br>
Internally, a default export is simply a named export whose name is default. As an
<br>
example, consider the previous module my-func.mjs with a default export:
<br>
const GREETING = 'Hello!';
<br>
export default function () {
<br>
return GREETING;
<br>
}
<br>

<br>
The following module my-func2.mjs is equivalent to that module:
<br>
const GREETING = 'Hello!';
<br>
function greet() {
<br>
return GREETING;
<br>
}
<br>
export {
<br>
greet as default,
<br>
};
<br>

<br>
For importing, we can use a normal default import:
<br>
import myFunc from './my-func2.mjs';
<br>
assert.equal(myFunc(), 'Hello!');
<br>

<br>
Or we can use a named import:
<br>
import {default as myFunc} from './my-func2.mjs';
<br>
assert.equal(myFunc(), 'Hello!');
<br>

<br>
The default export is also available via property .default of namespace imports:
<br>
import * as mf from './my-func2.mjs';
<br>
assert.equal(mf.default(), 'Hello!');
<br>

<br>
244
<br>

<br>
27 Modules
<br>

<br>
Isn’t default illegal as a variable name?
<br>
default can’t be a variable name, but it can be an export name and it can be a
<br>

<br>
property name:
<br>
const obj = {
<br>
default: 123,
<br>
};
<br>
assert.equal(obj.default, 123);
<br>

<br>
27.8 More details on exporting and importing
<br>
27.8.1 Imports are read-only views on exports
<br>
So far, we have used imports and exports intuitively, and everything seems to have
<br>
worked as expected. But now it is time to take a closer look at how imports and exports
<br>
are really related.
<br>
Consider the following two modules:
<br>
counter.mjs
<br>
main.mjs
<br>
counter.mjs exports a (mutable!) variable and a function:
<br>
export let counter = 3;
<br>
export function incCounter() {
<br>
counter++;
<br>
}
<br>
main.mjs name-imports both exports. When we use incCounter(), we discover that the
<br>

<br>
connection to counter is live – we can always access the live state of that variable:
<br>
import { counter, incCounter } from './counter.mjs';
<br>
// The imported value `counter` is live
<br>
assert.equal(counter, 3);
<br>
incCounter();
<br>
assert.equal(counter, 4);
<br>

<br>
Note that while the connection is live and we can read counter, we cannot change this
<br>
variable (e.g., via counter++).
<br>
There are two beneﬁts to handling imports this way:
<br>
• It is easier to split modules because previously shared variables can become exports.
<br>
• This behavior is crucial for supporting transparent cyclic imports. Read on for
<br>
more information.
<br>

<br>
245
<br>

<br>
27.9 npm packages
<br>

<br>
27.8.2 ESM’s transparent support for cyclic imports (advanced)
<br>
ESM supports cyclic imports transparently. To understand how that is achieved, consider the following example: ﬁg. 27.1 shows a directed graph of modules importing other
<br>
modules. P importing M is the cycle in this case.
<br>

<br>
M
<br>

<br>
P
<br>

<br>
N
<br>

<br>
O
<br>

<br>
Q
<br>

<br>
R
<br>

<br>
S
<br>

<br>
Figure 27.1: A directed graph of modules importing modules: M imports N and O, N
<br>
imports P and Q, etc.
<br>
After parsing, these modules are set up in two phases:
<br>
• Instantiation: Every module is visited and its imports are connected to its exports.
<br>
Before a parent can be instantiated, all of its children must be instantiated.
<br>
• Evaluation: The bodies of the modules are executed. Once again, children are evaluated before parents.
<br>
This approach handles cyclic imports correctly, due to two features of ES modules:
<br>
• Due to the static structure of ES modules, the exports are already known after parsing. That makes it possible to instantiate P before its child M: P can already look
<br>
up M’s exports.
<br>
• When P is evaluated, M hasn’t been evaluated, yet. However, entities in P can already mention imports from M. They just can’t use them, yet, because the imported
<br>
values are ﬁlled in later. For example, a function in P can access an import from
<br>
M. The only limitation is that we must wait until after the evaluation of M, before
<br>
calling that function.
<br>
Imports being ﬁlled in later is enabled by them being “live immutable views” on
<br>
exports.
<br>

<br>
27.9 npm packages
<br>
The npm software registry is the dominant way of distributing JavaScript libraries and apps
<br>
for Node.js and web browsers. It is managed via the npm package manager (short: npm).
<br>
Software is distributed as so-called packages. A package is a directory containing arbitrary
<br>
ﬁles and a ﬁle package.json at the top level that describes the package. For example,
<br>
when npm creates an empty package inside a directory foo/, you get this package.json:
<br>
{
<br>
"name": "foo",
<br>
"version": "1.0.0",
<br>

<br>
246
<br>

<br>
27 Modules
<br>
"description": "",
<br>
"main": "index.js",
<br>
"scripts": {
<br>
"test": "echo \"Error: no test specified\" && exit 1"
<br>
},
<br>
"keywords": [],
<br>
"author": "",
<br>
"license": "ISC"
<br>

<br>
}
<br>

<br>
Some of these properties contain simple metadata:
<br>
• name speciﬁes the name of this package. Once it is uploaded to the npm registry, it
<br>
can be installed via npm install foo.
<br>
• version is used for version management and follows semantic versioning, with
<br>
three numbers:
<br>
– Major version: is incremented when incompatible API changes are made.
<br>
– Minor version: is incremented when functionality is added in a backward
<br>
compatible manner.
<br>
– Patch version: is incremented when backward compatible changes are made.
<br>
• description, keywords, author make it easier to ﬁnd packages.
<br>
• license clariﬁes how you can use this package.
<br>
Other properties enable advanced conﬁguration:
<br>
• main: speciﬁes the module that “is” the package (explained later in this chapter).
<br>
• scripts: are commands that you can execute via npm run. For example, the script
<br>
test can be executed via npm run test.
<br>
For more information on package.json, consult the npm documentation.
<br>

<br>
27.9.1 Packages are installed inside a directory node_modules/
<br>
npm always installs packages inside a directory node_modules. There are usually many
<br>
of these directories. Which one npm uses, depends on the directory where one currently
<br>
is. For example, if we are inside a directory /tmp/a/b/, npm tries to ﬁnd a node_modules
<br>
in the current directory, its parent directory, the parent directory of the parent, etc. In
<br>
other words, it searches the following chain of locations:
<br>
• /tmp/a/b/node_modules
<br>
• /tmp/a/node_modules
<br>
• /tmp/node_modules
<br>
When installing a package foo, npm uses the closest node_modules. If, for example, we
<br>
are inside /tmp/a/b/ and there is a node_modules in that directory, then npm puts the
<br>
package inside the directory:
<br>
/tmp/a/b/node_modules/foo/
<br>

<br>
When importing a module, we can use a special module speciﬁer to tell Node.js that we
<br>
want to import it from an installed package. How exactly that works, is explained later.
<br>
For now, consider the following example:
<br>

<br>
27.10 Naming modules
<br>

<br>
247
<br>

<br>
// /home/jane/proj/main.mjs
<br>
import * as theModule from 'the-package/the-module.mjs';
<br>

<br>
To ﬁnd the-module.mjs (Node.js prefers the ﬁlename extension .mjs for ES modules),
<br>
Node.js walks up the node_module chain and searches the following locations:
<br>
• /home/jane/proj/node_modules/the-package/the-module.mjs
<br>
• /home/jane/node_modules/the-package/the-module.mjs
<br>
• /home/node_modules/the-package/the-module.mjs
<br>

<br>
27.9.2 Why can npm be used to install frontend libraries?
<br>
Finding installed modules in node_modules directories is only supported on Node.js. So
<br>
why can we also use npm to install libraries for browsers?
<br>
That is enabled via bundling tools, such as webpack, that compile and optimize code
<br>
before it is deployed online. During this compilation process, the code in npm packages
<br>
is adapted so that it works in browsers.
<br>

<br>
27.10 Naming modules
<br>
There are no established best practices for naming module ﬁles and the variables they are
<br>
imported into.
<br>
In this chapter, I’m using the following naming style:
<br>
• The names of module ﬁles are dash-cased and start with lowercase letters:
<br>
./my-module.mjs
<br>
./some-func.mjs
<br>

<br>
• The names of namespace imports are lowercased and camel-cased:
<br>
import * as myModule from './my-module.mjs';
<br>

<br>
• The names of default imports are lowercased and camel-cased:
<br>
import someFunc from './some-func.mjs';
<br>

<br>
What are the rationales behind this style?
<br>
• npm doesn’t allow uppercase letters in package names (source). Thus, we avoid
<br>
camel case, so that “local” ﬁles have names that are consistent with those of npm
<br>
packages. Using only lowercase letters also minimizes conﬂicts between ﬁle systems that are case-sensitive and ﬁle systems that aren’t: the former distinguish ﬁles
<br>
whose names have the same letters, but with different cases; the latter don’t.
<br>
• There are clear rules for translating dash-cased ﬁle names to camel-cased JavaScript
<br>
variable names. Due to how we name namespace imports, these rules work for
<br>
both namespace imports and default imports.
<br>
I also like underscore-cased module ﬁle names because you can directly use these names
<br>
for namespace imports (without any translation):
<br>
import * as my_module from './my_module.mjs';
<br>

<br>
248
<br>

<br>
27 Modules
<br>

<br>
But that style does not work for default imports: I like underscore-casing for namespace
<br>
objects, but it is not a good choice for functions, etc.
<br>

<br>
27.11 Module speciﬁers
<br>
Module speciﬁers are the strings that identify modules. They work slightly differently in
<br>
browsers and Node.js. Before we can look at the differences, we need to learn about the
<br>
different categories of module speciﬁers.
<br>

<br>
27.11.1 Categories of module speciﬁers
<br>
In ES modules, we distinguish the following categories of speciﬁers. These categories
<br>
originated with CommonJS modules.
<br>
• Relative path: starts with a dot. Examples:
<br>
'./some/other/module.mjs'
<br>
'../../lib/counter.mjs'
<br>

<br>
• Absolute path: starts with a slash. Example:
<br>
'/home/jane/file-tools.mjs'
<br>

<br>
• URL: includes a protocol (technically, paths are URLs, too). Examples:
<br>
'https://example.com/some-module.mjs'
<br>
'file:///home/john/tmp/main.mjs'
<br>

<br>
• Bare path: does not start with a dot, a slash or a protocol, and consists of a single
<br>
ﬁlename without an extension. Examples:
<br>
'lodash'
<br>
'the-package'
<br>

<br>
• Deep import path: starts with a bare path and has at least one slash. Example:
<br>
'the-package/dist/the-module.mjs'
<br>

<br>
27.11.2 ES module speciﬁers in browsers
<br>
Browsers handle module speciﬁers as follows:
<br>
• Relative paths, absolute paths, and URLs work as expected. They all must point to
<br>
real ﬁles (in contrast to CommonJS, which lets you omit ﬁlename extensions and
<br>
more).
<br>
• The ﬁle name extensions of modules don’t matter, as long as they are served with
<br>
the content type text/javascript.
<br>
• How bare paths will end up being handled is not yet clear. You will probably
<br>
eventually be able to map them to other speciﬁers via lookup tables.
<br>
Note that bundling tools such as webpack, which combine modules into fewer ﬁles, are
<br>
often less strict with speciﬁers than browsers. That’s because they operate at build/compile time (not at runtime) and can search for ﬁles by traversing the ﬁle system.
<br>

<br>
27.11 Module speciﬁers
<br>

<br>
249
<br>

<br>
27.11.3 ES module speciﬁers on Node.js
<br>
Support for ES modules on Node.js is still new
<br>
You may have to switch it on via a command line ﬂag. See the Node.js documentation for details.
<br>
Node.js handles module speciﬁers as follows:
<br>
• Relative paths are resolved as they are in web browsers – relative to the path of the
<br>
current module.
<br>
• Absolute paths are currently not supported. As a workaround, you can use URLs
<br>
that start with file:///. You can create such URLs via url.pathToFileURL().
<br>
• Only file: is supported as a protocol for URL speciﬁers.
<br>
• A bare path is interpreted as a package name and resolved relative to the closest
<br>
node_modules directory. What module should be loaded, is determined by looking
<br>
at property "main" of the package’s package.json (similarly to CommonJS).
<br>
• Deep import paths are also resolved relatively to the closest node_modules directory. They contain ﬁle names, so it is always clear which module is meant.
<br>
All speciﬁers, except bare paths, must refer to actual ﬁles. That is, ESM does not support
<br>
the following CommonJS features:
<br>
• CommonJS automatically adds missing ﬁlename extensions.
<br>
• CommonJS can import a directory foo if there is a foo/package.json with a "main"
<br>
property.
<br>
• CommonJS can import a directory foo if there is a module foo/index.js.
<br>
All built-in Node.js modules are available via bare paths and have named ESM exports –
<br>
for example:
<br>
import * as path from 'path';
<br>
import {strict as assert} from 'assert';
<br>
assert.equal(
<br>
path.join('a/b/c', '../d'), 'a/b/d');
<br>

<br>
27.11.3.1 Filename extensions on Node.js
<br>
Node.js supports the following default ﬁlename extensions:
<br>
• .mjs for ES modules
<br>
• .cjs for CommonJS modules
<br>
The ﬁlename extension .js stands for either ESM or CommonJS. Which one it is is conﬁgured via the “closest” package.json (in the current directory, the parent directory, etc.).
<br>
Using package.json in this manner is independent of packages.
<br>

<br>
250
<br>

<br>
27 Modules
<br>

<br>
In that package.json, there is a property "type", which has two settings:
<br>
• "commonjs" (the default): ﬁles with the extension .js or without an extension are
<br>
interpreted as CommonJS modules.
<br>
• "module": ﬁles with the extension .js or without an extension are interpreted as
<br>
ESM modules.
<br>
27.11.3.2 Interpreting non-ﬁle source code as either CommonJS or ESM
<br>
Not all source code executed by Node.js comes from ﬁles. You can also send it code via
<br>
stdin, --eval, and --print. The command line option --input-type lets you specify
<br>
how such code is interpreted:
<br>
• As CommonJS (the default): --input-type=commonjs
<br>
• As ESM: --input-type=module
<br>

<br>
27.12 Loading modules dynamically via import()
<br>
So far, the only way to import a module has been via an import statement. That statement
<br>
has several limitations:
<br>
• You must use it at the top level of a module. That is, you can’t, for example, import
<br>
something when you are inside a block.
<br>
• The module speciﬁer is always ﬁxed. That is, you can’t change what you import
<br>
depending on a condition. And you can’t assemble a speciﬁer dynamically.
<br>
The import() operator changes that. Let’s look at an example of it being used.
<br>

<br>
27.12.1 Example: loading a module dynamically
<br>
Consider the following ﬁles:
<br>
lib/my-math.mjs
<br>
main1.mjs
<br>
main2.mjs
<br>

<br>
We have already seen module my-math.mjs:
<br>
// Not exported, private to module
<br>
function times(a, b) {
<br>
return a * b;
<br>
}
<br>
export function square(x) {
<br>
return times(x, x);
<br>
}
<br>
export const LIGHTSPEED = 299792458;
<br>

<br>
This is what using import() looks like in main1.mjs:
<br>
const dir = './lib/';
<br>
const moduleSpecifier = dir + 'my-math.mjs';
<br>

<br>
27.12 Loading modules dynamically via import()
<br>

<br>
251
<br>

<br>
function loadConstant() {
<br>
return import(moduleSpecifier)
<br>
.then(myMath => {
<br>
const result = myMath.LIGHTSPEED;
<br>
assert.equal(result, 299792458);
<br>
return result;
<br>
});
<br>
}
<br>

<br>
Method .then() is part of Promises, a mechanism for handling asynchronous results,
<br>
which is covered later in this book.
<br>
Two things in this code weren’t possible before:
<br>
• We are importing inside a function (not at the top level).
<br>
• The module speciﬁer comes from a variable.
<br>
Next, we’ll implement the exact same functionality in main2.mjs but via a so-called async
<br>
function, which provides nicer syntax for Promises.
<br>
const dir = './lib/';
<br>
const moduleSpecifier = dir + 'my-math.mjs';
<br>
async function loadConstant() {
<br>
const myMath = await import(moduleSpecifier);
<br>
const result = myMath.LIGHTSPEED;
<br>
assert.equal(result, 299792458);
<br>
return result;
<br>
}
<br>

<br>
Why is import() an operator and not a function?
<br>
Even though it works much like a function, import() is an operator: in order to
<br>
resolve module speciﬁers relatively to the current module, it needs to know from
<br>
which module it is invoked. A normal function cannot receive this information as
<br>
implicitly as an operator can. It would need, for example, a parameter.
<br>

<br>
27.12.2 Use cases for import()
<br>
27.12.2.1 Loading code on demand
<br>
Some functionality of web apps doesn’t have to be present when they start, it can be
<br>
loaded on demand. Then import() helps because you can put such functionality into
<br>
modules – for example:
<br>
button.addEventListener('click', event => {
<br>
import('./dialogBox.mjs')
<br>
.then(dialogBox => {
<br>
dialogBox.open();
<br>
})
<br>
.catch(error => {
<br>

<br>
252
<br>

<br>
27 Modules
<br>
/* Error handling */
<br>
})
<br>

<br>
});
<br>

<br>
27.12.2.2 Conditional loading of modules
<br>
We may want to load a module depending on whether a condition is true. For example,
<br>
a module with a polyﬁll that makes a new feature available on legacy platforms:
<br>
if (isLegacyPlatform()) {
<br>
import('./my-polyfill.mjs')
<br>
.then(···);
<br>
}
<br>

<br>
27.12.2.3 Computed module speciﬁers
<br>
For applications such as internationalization, it helps if you can dynamically compute
<br>
module speciﬁers:
<br>
import(`messages_${getLocale()}.mjs`)
<br>
.then(···);
<br>

<br>
27.13 Preview: import.meta.url
<br>
“import.meta” is an ECMAScript feature proposed by Domenic Denicola. The object
<br>
import.meta holds metadata for the current module.
<br>
Its most important property is import.meta.url, which contains a string with the URL
<br>
of the current module ﬁle. For example:
<br>
'https://example.com/code/main.mjs'
<br>

<br>
27.13.1
<br>

<br>
import.meta.url and class URL
<br>

<br>
Class URL is available via a global variable in browsers and on Node.js. You can look up its
<br>
full functionality in the Node.js documentation. When working with import.meta.url,
<br>
its constructor is especially useful:
<br>
new URL(input: string, base?: string|URL)
<br>

<br>
Parameter input contains the URL to be parsed. It can be relative if the second parameter,
<br>
base, is provided.
<br>
In other words, this constructor lets us resolve a relative path against a base URL:
<br>
> new URL('other.mjs', 'https://example.com/code/main.mjs').href
<br>
'https://example.com/code/other.mjs'
<br>
> new URL('../other.mjs', 'https://example.com/code/main.mjs').href
<br>
'https://example.com/other.mjs'
<br>

<br>
This is how we get a URL instance that points to a ﬁle data.txt that sits next to the current
<br>
module:
<br>

<br>
27.13 Preview: import.meta.url
<br>

<br>
253
<br>

<br>
const urlOfData = new URL('data.txt', import.meta.url);
<br>

<br>
27.13.2 import.meta.url on Node.js
<br>
On Node.js, import.meta.url is always a string with a file: URL – for example:
<br>
'file:///Users/rauschma/my-module.mjs'
<br>

<br>
27.13.2.1 Example: reading a sibling ﬁle of a module
<br>
Many Node.js ﬁle system operations accept either strings with paths or instances of URL.
<br>
That enables us to read a sibling ﬁle data.txt of the current module:
<br>
import {promises as fs} from 'fs';
<br>
async function main() {
<br>
const urlOfData = new URL('data.txt', import.meta.url);
<br>
const str = await fs.readFile(urlOfData, {encoding: 'UTF-8'});
<br>
assert.equal(str, 'This is textual data.\n');
<br>
}
<br>
main();
<br>
main() is an async function, as explained in §41 “Async functions”.
<br>
fs.promises contains a Promise-based version of the fs API, which can be used with
<br>
async functions.
<br>

<br>
27.13.2.2 Converting between file: URLs and paths
<br>
The Node.js module url has two functions for converting between file: URLs and
<br>
paths:
<br>
• fileURLToPath(url: URL|string): string
<br>
Converts a file: URL to a path.
<br>
• pathToFileURL(path: string): URL
<br>
Converts a path to a file: URL.
<br>
If you need a path that can be used in the local ﬁle system, then property .pathname of
<br>
URL instances does not always work:
<br>
assert.equal(
<br>
new URL('file:///tmp/with%20space.txt').pathname,
<br>
'/tmp/with%20space.txt');
<br>

<br>
Therefore, it is better to use fileURLToPath():
<br>
import * as url from 'url';
<br>
assert.equal(
<br>
url.fileURLToPath('file:///tmp/with%20space.txt'),
<br>
'/tmp/with space.txt'); // result on Unix
<br>

<br>
Similarly, pathToFileURL() does more than just prepend 'file://' to an absolute path.
<br>

<br>
254
<br>

<br>
27 Modules
<br>

<br>
27.14 Polyﬁlls: emulating native web platform features
<br>
(advanced)
<br>
Backends have polyﬁlls, too
<br>
This section is about frontend development and web browsers, but similar ideas
<br>
apply to backend development.
<br>
Polyﬁlls help with a conﬂict that we are facing when developing a web application in
<br>
JavaScript:
<br>

<br>
• On one hand, we want to use modern web platform features that make the app
<br>
better and/or development easier.
<br>
• On the other hand, the app should run on as many browsers as possible.
<br>
Given a web platform feature X:
<br>
• A polyﬁll for X is a piece of code. If it is executed on a platform that already has builtin support for X, it does nothing. Otherwise, it makes the feature available on the
<br>
platform. In the latter case, the polyﬁlled feature is (mostly) indistinguishable from
<br>
a native implementation. In order to achieve that, the polyﬁll usually makes global
<br>
changes. For example, it may modify global data or conﬁgure a global module
<br>
loader. Polyﬁlls are often packaged as modules.
<br>
– The term polyﬁll was coined by Remy Sharp.
<br>
• A speculative polyﬁll is a polyﬁll for a proposed web platform feature (that is not
<br>
standardized, yet).
<br>
– Alternative term: prollyﬁll
<br>
• A replica of X is a library that reproduces the API and functionality of X locally.
<br>
Such a library exists independently of a native (and global) implementation of X.
<br>
– Replica is a new term introduced in this section. Alternative term: ponyﬁll
<br>
• There is also the term shim, but it doesn’t have a universally agreed upon deﬁnition.
<br>
It often means roughly the same as polyﬁll.
<br>
Every time our web applications starts, it must ﬁrst execute all polyﬁlls for features that
<br>
may not be available everywhere. Afterwards, we can be sure that those features are
<br>
available natively.
<br>

<br>
27.14.1 Sources of this section
<br>
• “What is a Polyﬁll?” by Remy Sharp
<br>
• Inspiration for the term replica: The Eiffel Tower in Las Vegas
<br>
• Useful clariﬁcation of “polyﬁll” and related terms: “Polyﬁlls and the evolution of
<br>
the Web”. Edited by Andrew Betts.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 28
<br>

<br>
Single objects
<br>
Contents
<br>
28.1 What is an object? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
<br>
28.1.1 Roles of objects: record vs. dictionary . . . . . . . . . . . . . . 257
<br>
28.2 Objects as records . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
<br>
28.2.1 Object literals: properties . . . . . . . . . . . . . . . . . . . . . 257
<br>
28.2.2 Object literals: property value shorthands . . . . . . . . . . . . 258
<br>
28.2.3 Getting properties . . . . . . . . . . . . . . . . . . . . . . . . . 258
<br>
28.2.4 Setting properties . . . . . . . . . . . . . . . . . . . . . . . . . 258
<br>
28.2.5 Object literals: methods . . . . . . . . . . . . . . . . . . . . . . 259
<br>
28.2.6 Object literals: accessors . . . . . . . . . . . . . . . . . . . . . 259
<br>
28.3 Spreading into object literals (...) . . . . . . . . . . . . . . . . . . . 260
<br>
28.3.1 Use case for spreading: copying objects . . . . . . . . . . . . . 261
<br>
28.3.2 Use case for spreading: default values for missing properties . 261
<br>
28.3.3 Use case for spreading: non-destructively changing properties
<br>

<br>
262
<br>

<br>
28.4 Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
<br>
28.4.1 Methods are properties whose values are functions
<br>

<br>
. . . . . . 262
<br>

<br>
28.4.2 .call(): specifying this via a parameter . . . . . . . . . . . . 263
<br>
28.4.3 .bind(): pre-ﬁlling this and parameters of functions . . . . . 264
<br>
28.4.4 this pitfall: extracting methods . . . . . . . . . . . . . . . . . 265
<br>
28.4.5 this pitfall: accidentally shadowing this . . . . . . . . . . . . 266
<br>
28.4.6 Avoiding the pitfalls of this . . . . . . . . . . . . . . . . . . . 268
<br>
28.4.7 The value of this in various contexts . . . . . . . . . . . . . . 268
<br>
28.5 Objects as dictionaries (advanced) . . . . . . . . . . . . . . . . . . . 269
<br>
28.5.1 Arbitrary ﬁxed strings as property keys . . . . . . . . . . . . . 269
<br>
28.5.2 Computed property keys . . . . . . . . . . . . . . . . . . . . . 270
<br>
28.5.3 The in operator: is there a property with a given key? . . . . . 271
<br>
28.5.4 Deleting properties . . . . . . . . . . . . . . . . . . . . . . . . 271
<br>
28.5.5 Listing property keys . . . . . . . . . . . . . . . . . . . . . . . 271
<br>
28.5.6 Listing property values via Object.values() . . . . . . . . . . 273
<br>

<br>
255
<br>

<br>
256
<br>

<br>
28 Single objects
<br>
28.5.7 Listing property entries via Object.entries() . . . . . . . . . 273
<br>
28.5.8 Properties are listed deterministically . . . . . . . . . . . . . . 273
<br>
28.5.9 Assembling objects via Object.fromEntries() . . . . . . . . . 274
<br>
28.5.10 The pitfalls of using an object as a dictionary . . . . . . . . . . 276
<br>
28.6 Standard methods (advanced) . . . . . . . . . . . . . . . . . . . . . . 277
<br>
28.6.1 .toString() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
<br>
28.6.2 .valueOf() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
<br>
28.7 Advanced topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
<br>
28.7.1 Object.assign() . . . . . . . . . . . . . . . . . . . . . . . . . 277
<br>
28.7.2 Freezing objects . . . . . . . . . . . . . . . . . . . . . . . . . . 278
<br>
28.7.3 Property attributes and property descriptors . . . . . . . . . . 278
<br>

<br>
In this book, JavaScript’s style of object-oriented programming (OOP) is introduced in
<br>
four steps. This chapter covers step 1; the next chapter covers steps 2–4. The steps are
<br>
(ﬁg. 28.1):
<br>
1. Single objects (this chapter): How do objects, JavaScript’s basic OOP building
<br>
blocks, work in isolation?
<br>
2. Prototype chains (next chapter): Each object has a chain of zero or more prototype
<br>
objects. Prototypes are JavaScript’s core inheritance mechanism.
<br>
3. Classes (next chapter): JavaScript’s classes are factories for objects. The relationship
<br>
between a class and its instances is based on prototypal inheritance.
<br>
4. Subclassing (next chapter): The relationship between a subclass and its superclass
<br>
is also based on prototypal inheritance.
<br>
SuperClass
<br>
superData
<br>
superMthd
<br>
mthd
<br>

<br>
ƒ
<br>
MyClass
<br>

<br>
mthd
<br>

<br>
ƒ
<br>

<br>
__proto__
<br>

<br>
data
<br>

<br>
4
<br>

<br>
data
<br>

<br>
4
<br>

<br>
1. Single objects 2. Prototype chains
<br>

<br>
SubClass
<br>

<br>
data
<br>

<br>
subData
<br>

<br>
mthd
<br>

<br>
subMthd
<br>

<br>
3. Classes
<br>

<br>
4. Subclassing
<br>

<br>
Figure 28.1: This book introduces object-oriented programming in JavaScript in four
<br>
steps.
<br>

<br>
28.1 What is an object?
<br>
In JavaScript:
<br>
• An object is a set of properties (key-value entries).
<br>
• A property key can only be a string or a symbol.
<br>

<br>
28.2 Objects as records
<br>

<br>
257
<br>

<br>
28.1.1 Roles of objects: record vs. dictionary
<br>
Objects play two roles in JavaScript:
<br>
• Records: Objects-as-records have a ﬁxed number of properties, whose keys are
<br>
known at development time. Their values can have different types.
<br>
• Dictionaries: Objects-as-dictionaries have a variable number of properties, whose
<br>
keys are not known at development time. All of their values have the same type.
<br>
These roles inﬂuence how objects are explained in this chapter:
<br>
• First, we’ll explore objects-as-records. Even though property keys are strings or
<br>
symbols under the hood, they will appear as ﬁxed identiﬁers to us, in this part of
<br>
the chapter.
<br>
• Later, we’ll explore objects-as-dictionaries. Note that Maps are usually better dictionaries than objects. However, some of the operations that we’ll encounter, can
<br>
also be useful for objects-as-records.
<br>

<br>
28.2 Objects as records
<br>
Let’s ﬁrst explore the role record of objects.
<br>

<br>
28.2.1 Object literals: properties
<br>
Object literals are one way of creating objects-as-records. They are a stand-out feature of
<br>
JavaScript: you can directly create objects – no need for classes! This is an example:
<br>
const jane = {
<br>
first: 'Jane',
<br>
last: 'Doe', // optional trailing comma
<br>
};
<br>

<br>
In the example, we created an object via an object literal, which starts and ends with curly
<br>
braces {}. Inside it, we deﬁned two properties (key-value entries):
<br>
• The ﬁrst property has the key first and the value 'Jane'.
<br>
• The second property has the key last and the value 'Doe'.
<br>
We will later see other ways of specifying property keys, but with this way of specifying
<br>
them, they must follow the rules of JavaScript variable names. For example, you can
<br>
use first_name as a property key, but not first-name). However, reserved words are
<br>
allowed:
<br>
const obj = {
<br>
if: true,
<br>
const: true,
<br>
};
<br>

<br>
In order to check the effects of various operations on objects, we’ll occasionally use Object.keys() in this part of the chapter. It lists property keys:
<br>

<br>
258
<br>

<br>
28 Single objects
<br>

<br>
> Object.keys({a:1, b:2})
<br>
[ 'a', 'b' ]
<br>

<br>
28.2.2 Object literals: property value shorthands
<br>
Whenever the value of a property is deﬁned via a variable name and that name is the
<br>
same as the key, you can omit the key.
<br>
function createPoint(x, y) {
<br>
return {x, y};
<br>
}
<br>
assert.deepEqual(
<br>
createPoint(9, 2),
<br>
{ x: 9, y: 2 }
<br>
);
<br>

<br>
28.2.3 Getting properties
<br>
This is how you get (read) a property (line A):
<br>
const jane = {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
};
<br>
// Get property .first
<br>
assert.equal(jane.first, 'Jane'); // (A)
<br>

<br>
Getting an unknown property produces undefined:
<br>
assert.equal(jane.unknownProperty, undefined);
<br>

<br>
28.2.4 Setting properties
<br>
This is how you set (write to) a property:
<br>
const obj = {
<br>
prop: 1,
<br>
};
<br>
assert.equal(obj.prop, 1);
<br>
obj.prop = 2; // (A)
<br>
assert.equal(obj.prop, 2);
<br>

<br>
We just changed an existing property via setting. If we set an unknown property, we
<br>
create a new entry:
<br>
const obj = {}; // empty object
<br>
assert.deepEqual(
<br>
Object.keys(obj), []);
<br>
obj.unknownProperty = 'abc';
<br>

<br>
259
<br>

<br>
28.2 Objects as records
<br>
assert.deepEqual(
<br>
Object.keys(obj), ['unknownProperty']);
<br>

<br>
28.2.5 Object literals: methods
<br>
The following code shows how to create the method .says() via an object literal:
<br>
const jane = {
<br>
first: 'Jane', // data property
<br>
says(text) {
<br>

<br>
// method
<br>

<br>
return `${this.first} says “${text}”`; // (A)
<br>
}, // comma as separator (optional at end)
<br>
};
<br>
assert.equal(jane.says('hello'), 'Jane says “hello”');
<br>

<br>
During the method call jane.says('hello'), jane is called the receiver of the method
<br>
call and assigned to the special variable this. That enables method .says() to access the
<br>
sibling property .first in line A.
<br>

<br>
28.2.6 Object literals: accessors
<br>
There are two kinds of accessors in JavaScript:
<br>
• A getter is a method-like entity that is invoked by getting a property.
<br>
• A setter is a method-like entity that is invoked by setting a property.
<br>
28.2.6.1 Getters
<br>
A getter is created by preﬁxing a method deﬁnition with the modiﬁer get:
<br>
const jane = {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
get full() {
<br>
return `${this.first} ${this.last}`;
<br>
},
<br>
};
<br>
assert.equal(jane.full, 'Jane Doe');
<br>
jane.first = 'John';
<br>
assert.equal(jane.full, 'John Doe');
<br>

<br>
28.2.6.2 Setters
<br>
A setter is created by preﬁxing a method deﬁnition with the modiﬁer set:
<br>
const jane = {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
set full(fullName) {
<br>
const parts = fullName.split(' ');
<br>

<br>
260
<br>

<br>
28 Single objects
<br>
this.first = parts[0];
<br>
this.last = parts[1];
<br>
},
<br>

<br>
};
<br>
jane.full = 'Richard Roe';
<br>
assert.equal(jane.first, 'Richard');
<br>
assert.equal(jane.last, 'Roe');
<br>

<br>
Exercise: Creating an object via an object literal
<br>
exercises/single-objects/color_point_object_test.mjs
<br>

<br>
28.3 Spreading into object literals (...)
<br>
Inside a function call, spreading (...) turns the iterated values of an iterable object into
<br>
arguments.
<br>
Inside an object literal, a spread property adds the properties of another object to the current
<br>
one:
<br>
> const obj = {foo: 1, bar: 2};
<br>
> {...obj, baz: 3}
<br>
{ foo: 1, bar: 2, baz: 3 }
<br>

<br>
If property keys clash, the property that is mentioned last “wins”:
<br>
> const obj = {foo: 1, bar: 2, baz: 3};
<br>
> {...obj, foo: true}
<br>
{ foo: true, bar: 2, baz: 3 }
<br>
> {foo: true, ...obj}
<br>
{ foo: 1, bar: 2, baz: 3 }
<br>

<br>
All values are spreadable, even undefined and null:
<br>
> {...undefined}
<br>
{}
<br>
> {...null}
<br>
{}
<br>
> {...123}
<br>
{}
<br>
> {...'abc'}
<br>
{ '0': 'a', '1': 'b', '2': 'c' }
<br>
> {...['a', 'b']}
<br>
{ '0': 'a', '1': 'b' }
<br>

<br>
Property .length of strings and of Arrays is hidden from this kind of operation (it is not
<br>
enumerable; see §28.7.3 “Property attributes and property descriptors” for more information).
<br>

<br>
28.3 Spreading into object literals (...)
<br>

<br>
261
<br>

<br>
28.3.1 Use case for spreading: copying objects
<br>
You can use spreading to create a copy of an object original:
<br>
const copy = {...original};
<br>

<br>
Caveat – copying is shallow: copy is a fresh object with duplicates of all properties (keyvalue entries) of original. But if property values are objects, then those are not copied
<br>
themselves; they are shared between original and copy. Let’s look at an example:
<br>
const original = { a: 1, b: {foo: true} };
<br>
const copy = {...original};
<br>

<br>
The ﬁrst level of copy is really a copy: If you change any properties at that level, it does
<br>
not affect the original:
<br>
copy.a = 2;
<br>
assert.deepEqual(
<br>
original, { a: 1, b: {foo: true} }); // no change
<br>

<br>
However, deeper levels are not copied. For example, the value of .b is shared between
<br>
original and copy. Changing .b in the copy also changes it in the original.
<br>
copy.b.foo = false;
<br>
assert.deepEqual(
<br>
original, { a: 1, b: {foo: false} });
<br>

<br>
JavaScript doesn’t have built-in support for deep copying
<br>
Deep copies of objects (where all levels are copied) are notoriously difﬁcult to do
<br>
generically. Therefore, JavaScript does not have a built-in operation for them (for
<br>
now). If you need such an operation, you have to implement it yourself.
<br>

<br>
28.3.2 Use case for spreading: default values for missing properties
<br>
If one of the inputs of your code is an object with data, you can make properties optional
<br>
by specifying default values that are used if those properties are missing. One technique
<br>
for doing so is via an object whose properties contain the default values. In the following
<br>
example, that object is DEFAULTS:
<br>
const DEFAULTS = {foo: 'a', bar: 'b'};
<br>
const providedData = {foo: 1};
<br>
const allData = {...DEFAULTS, ...providedData};
<br>
assert.deepEqual(allData, {foo: 1, bar: 'b'});
<br>

<br>
The result, the object allData, is created by copying DEFAULTS and overriding its properties with those of providedData.
<br>
But you don’t need an object to specify the default values; you can also specify them
<br>
inside the object literal, individually:
<br>

<br>
262
<br>

<br>
28 Single objects
<br>

<br>
const providedData = {foo: 1};
<br>
const allData = {foo: 'a', bar: 'b', ...providedData};
<br>
assert.deepEqual(allData, {foo: 1, bar: 'b'});
<br>

<br>
28.3.3 Use case for spreading: non-destructively changing properties
<br>
So far, we have encountered one way of changing a property .foo of an object: We set it
<br>
(line A) and mutate the object. That is, this way of changing a property is destructive.
<br>
const obj = {foo: 'a', bar: 'b'};
<br>
obj.foo = 1; // (A)
<br>
assert.deepEqual(obj, {foo: 1, bar: 'b'});
<br>

<br>
With spreading, we can change .foo non-destructively – we make a copy of obj where
<br>
.foo has a different value:
<br>
const obj = {foo: 'a', bar: 'b'};
<br>
const updatedObj = {...obj, foo: 1};
<br>
assert.deepEqual(updatedObj, {foo: 1, bar: 'b'});
<br>

<br>
Exercise: Non-destructively updating a property via spreading (ﬁxed key)
<br>
exercises/single-objects/update_name_test.mjs
<br>

<br>
28.4 Methods
<br>
28.4.1 Methods are properties whose values are functions
<br>
Let’s revisit the example that was used to introduce methods:
<br>
const jane = {
<br>
first: 'Jane',
<br>
says(text) {
<br>
return `${this.first} says “${text}”`;
<br>
},
<br>
};
<br>

<br>
Somewhat surprisingly, methods are functions:
<br>
assert.equal(typeof jane.says, 'function');
<br>

<br>
Why is that? We learned in the chapter on callable values, that ordinary functions play
<br>
several roles. Method is one of those roles. Therefore, under the hood, jane roughly looks
<br>
as follows.
<br>
const jane = {
<br>
first: 'Jane',
<br>
says: function (text) {
<br>
return `${this.first} says “${text}”`;
<br>

<br>
28.4 Methods
<br>

<br>
263
<br>

<br>
},
<br>
};
<br>

<br>
28.4.2
<br>

<br>
.call(): specifying this via a parameter
<br>

<br>
Remember that each function someFunc is also an object and therefore has methods. One
<br>
such method is .call() – it lets you call a function while specifying this via a parameter:
<br>
someFunc.call(thisValue, arg1, arg2, arg3);
<br>

<br>
28.4.2.1 Methods and .call()
<br>
If you make a method call, this is an implicit parameter that is ﬁlled in via the receiver
<br>
of the call:
<br>
const obj = {
<br>
method(x) {
<br>
assert.equal(this, obj); // implicit parameter
<br>
assert.equal(x, 'a');
<br>
},
<br>
};
<br>
obj.method('a'); // receiver is `obj`
<br>

<br>
The method call in the last line sets up this as follows:
<br>
obj.method.call(obj, 'a');
<br>

<br>
As an aside, that means that there are actually two different dot operators:
<br>
1. One for accessing properties: obj.prop
<br>
2. One for making method calls: obj.prop()
<br>
They are different in that (2) is not just (1) followed by the function call operator (). Instead, (2) additionally speciﬁes a value for this.
<br>
28.4.2.2 Functions and .call()
<br>
If you function-call an ordinary function, its implicit parameter this is also provided – it
<br>
is implicitly set to undefined:
<br>
function func(x) {
<br>
assert.equal(this, undefined); // implicit parameter
<br>
assert.equal(x, 'a');
<br>
}
<br>
func('a');
<br>

<br>
The method call in the last line sets up this as follows:
<br>
func.call(undefined, 'a');
<br>
this being set to undefined during a function call, indicates that it is a feature that is only
<br>
needed during a method call.
<br>

<br>
264
<br>

<br>
28 Single objects
<br>

<br>
Next, we’ll examine the pitfalls of using this. Before we can do that, we need one more
<br>
tool: method .bind() of functions.
<br>

<br>
28.4.3
<br>

<br>
.bind(): pre-ﬁlling this and parameters of functions
<br>

<br>
.bind() is another method of function objects. This method is invoked as follows:
<br>
const boundFunc = someFunc.bind(thisValue, arg1, arg2);
<br>
.bind() returns a new function boundFunc(). Calling that function invokes someFunc()
<br>
with this set to thisValue and these parameters: arg1, arg2, followed by the parameters
<br>
of boundFunc().
<br>

<br>
That is, the following two function calls are equivalent:
<br>
boundFunc('a', 'b')
<br>
someFunc.call(thisValue, arg1, arg2, 'a', 'b')
<br>

<br>
28.4.3.1 An alternative to .bind()
<br>
Another way of pre-ﬁlling this and parameters is via an arrow function:
<br>
const boundFunc2 = (...args) =>
<br>
someFunc.call(thisValue, arg1, arg2, ...args);
<br>

<br>
28.4.3.2 An implementation of .bind()
<br>
Considering the previous section, .bind() can be implemented as a real function as follows:
<br>
function bind(func, thisValue, ...boundArgs) {
<br>
return (...args) =>
<br>
func.call(thisValue, ...boundArgs, ...args);
<br>
}
<br>

<br>
28.4.3.3 Example: binding a real function
<br>
Using .bind() for real functions is somewhat unintuitive because you have to provide
<br>
a value for this. Given that it is undefined during function calls, it is usually set to
<br>
undefined or null.
<br>
In the following example, we create add8(), a function that has one parameter, by binding
<br>
the ﬁrst parameter of add() to 8.
<br>
function add(x, y) {
<br>
return x + y;
<br>
}
<br>
const add8 = add.bind(undefined, 8);
<br>
assert.equal(add8(1), 9);
<br>

<br>
28.4 Methods
<br>

<br>
265
<br>

<br>
28.4.3.4 Example: binding a method
<br>
In the following code, we turn method .says() into the stand-alone function func():
<br>
const jane = {
<br>
first: 'Jane',
<br>
says(text) {
<br>
return `${this.first} says “${text}”`; // (A)
<br>
},
<br>
};
<br>
const func = jane.says.bind(jane, 'hello');
<br>
assert.equal(func(), 'Jane says “hello”');
<br>

<br>
Setting this to jane via .bind() is crucial here. Otherwise, func() wouldn’t work properly because this is used in line A.
<br>

<br>
28.4.4
<br>

<br>
this pitfall: extracting methods
<br>

<br>
We now know quite a bit about functions and methods and are ready to take a look at the
<br>
biggest pitfall involving methods and this: function-calling a method extracted from an
<br>
object can fail if you are not careful.
<br>
In the following example, we fail when we extract method jane.says(), store it in the
<br>
variable func, and function-call func().
<br>
const jane = {
<br>
first: 'Jane',
<br>
says(text) {
<br>
return `${this.first} says “${text}”`;
<br>
},
<br>
};
<br>
const func = jane.says; // extract the method
<br>
assert.throws(
<br>
() => func('hello'), // (A)
<br>
{
<br>
name: 'TypeError',
<br>
message: "Cannot read property 'first' of undefined",
<br>
});
<br>

<br>
The function call in line A is equivalent to:
<br>
assert.throws(
<br>
() => jane.says.call(undefined, 'hello'), // `this` is undefined!
<br>
{
<br>
name: 'TypeError',
<br>
message: "Cannot read property 'first' of undefined",
<br>
});
<br>

<br>
So how do we ﬁx this? We need to use .bind() to extract method .says():
<br>
const func2 = jane.says.bind(jane);
<br>
assert.equal(func2('hello'), 'Jane says “hello”');
<br>

<br>
266
<br>

<br>
28 Single objects
<br>

<br>
The .bind() ensures that this is always jane when we call func().
<br>
You can also use arrow functions to extract methods:
<br>
const func3 = text => jane.says(text);
<br>
assert.equal(func3('hello'), 'Jane says “hello”');
<br>

<br>
28.4.4.1 Example: extracting a method
<br>
The following is a simpliﬁed version of code that you may see in actual web development:
<br>
class ClickHandler {
<br>
constructor(id, elem) {
<br>
this.id = id;
<br>
elem.addEventListener('click', this.handleClick); // (A)
<br>
}
<br>
handleClick(event) {
<br>
alert('Clicked ' + this.id);
<br>
}
<br>
}
<br>

<br>
In line A, we don’t extract the method .handleClick() properly. Instead, we should do:
<br>
elem.addEventListener('click', this.handleClick.bind(this));
<br>

<br>
Exercise: Extracting a method
<br>
exercises/single-objects/method_extraction_exrc.mjs
<br>

<br>
28.4.5
<br>

<br>
this pitfall: accidentally shadowing this
<br>

<br>
Accidentally shadowing this is only an issue with ordinary functions
<br>
Arrow functions don’t shadow this.
<br>
Consider the following problem: when you are inside an ordinary function, you can’t
<br>
access the this of the surrounding scope because the ordinary function has its own this.
<br>
In other words, a variable in an inner scope hides a variable in an outer scope. That is
<br>
called shadowing. The following code is an example:
<br>
const prefixer = {
<br>
prefix: '==> ',
<br>
prefixStringArray(stringArray) {
<br>
return stringArray.map(
<br>
function (x) {
<br>
return this.prefix + x; // (A)
<br>
});
<br>
},
<br>
};
<br>

<br>
267
<br>

<br>
28.4 Methods
<br>
assert.throws(
<br>
() => prefixer.prefixStringArray(['a', 'b']),
<br>
/^TypeError: Cannot read property 'prefix' of undefined$/);
<br>

<br>
In line A, we want to access the this of .prefixStringArray(). But we can’t since the
<br>
surrounding ordinary function has its own this that shadows (blocks access to) the this of
<br>
the method. The value of the former this is undefined due to the callback being functioncalled. That explains the error message.
<br>
The simplest way to ﬁx this problem is via an arrow function, which doesn’t have its own
<br>
this and therefore doesn’t shadow anything:
<br>
const prefixer = {
<br>
prefix: '==> ',
<br>
prefixStringArray(stringArray) {
<br>
return stringArray.map(
<br>
(x) => {
<br>
return this.prefix + x;
<br>
});
<br>
},
<br>
};
<br>
assert.deepEqual(
<br>
prefixer.prefixStringArray(['a', 'b']),
<br>
['==> a', '==> b']);
<br>

<br>
We can also store this in a different variable (line A), so that it doesn’t get shadowed:
<br>
prefixStringArray(stringArray) {
<br>
const that = this; // (A)
<br>
return stringArray.map(
<br>
function (x) {
<br>
return that.prefix + x;
<br>
});
<br>
},
<br>

<br>
Another option is to specify a ﬁxed this for the callback via .bind() (line A):
<br>
prefixStringArray(stringArray) {
<br>
return stringArray.map(
<br>
function (x) {
<br>
return this.prefix + x;
<br>
}.bind(this)); // (A)
<br>
},
<br>

<br>
Lastly, .map() lets us specify a value for this (line A) that it uses when invoking the
<br>
callback:
<br>
prefixStringArray(stringArray) {
<br>
return stringArray.map(
<br>
function (x) {
<br>
return this.prefix + x;
<br>
},
<br>

<br>
268
<br>

<br>
28 Single objects
<br>
this); // (A)
<br>

<br>
},
<br>

<br>
28.4.6 Avoiding the pitfalls of this
<br>
We have seen two big this-related pitfalls:
<br>
1. Extracting methods
<br>
2. Accidentally shadowing this
<br>
One simple rule helps avoid the second pitfall:
<br>
“Avoid the keyword function”: Never use ordinary functions, only arrow
<br>
functions (for real functions) and method deﬁnitions.
<br>
Following this rule has two beneﬁts:
<br>
• It prevents the second pitfall because ordinary functions are never used as real
<br>
functions.
<br>
• this becomes easier to understand because it will only appear inside methods
<br>
(never inside ordinary functions). That makes it clear that this is an OOP feature.
<br>
However, even though I don’t use (ordinary) function expressions anymore, I do like function declarations syntactically. You can use them safely if you don’t refer to this inside
<br>
them. The static checking tool ESLint can warn you during development when you do
<br>
this wrong via a built-in rule.
<br>
Alas, there is no simple way around the ﬁrst pitfall: whenever you extract a method, you
<br>
have to be careful and do it properly – for example, by binding this.
<br>

<br>
28.4.7 The value of this in various contexts
<br>
What is the value of this in various contexts?
<br>
Inside a callable entity, the value of this depends on how the callable entity is invoked
<br>
and what kind of callable entity it is:
<br>
• Function call:
<br>
– Ordinary functions: this === undefined
<br>
– Arrow functions: this is same as in surrounding scope (lexical this)
<br>
• Method call: this is receiver of call
<br>
• new: this refers to newly created instance
<br>
You can also access this in all common top-level scopes:
<br>
• <script> element: this === globalThis
<br>
• ECMAScript modules: this === undefined
<br>
• CommonJS modules: this === module.exports
<br>
However, I like to pretend that you can’t access this in top-level scopes because top-level
<br>
this is confusing and rarely useful.
<br>

<br>
28.5 Objects as dictionaries (advanced)
<br>

<br>
269
<br>

<br>
28.5 Objects as dictionaries (advanced)
<br>
Objects work best as records. But before ES6, JavaScript did not have a data structure for
<br>
dictionaries (ES6 brought Maps). Therefore, objects had to be used as dictionaries, which
<br>
imposed a signﬁcant constraint: keys had to be strings (symbols were also introduced
<br>
with ES6).
<br>
We ﬁrst look at features of objects that are related to dictionaries but also useful for objectsas-records. This section concludes with tips for actually using objects as dictionaries
<br>
(spoiler: use Maps if you can).
<br>

<br>
28.5.1 Arbitrary ﬁxed strings as property keys
<br>
So far, we have always used objects as records. Property keys were ﬁxed tokens that had
<br>
to be valid identiﬁers and internally became strings:
<br>
const obj = {
<br>
mustBeAnIdentifier: 123,
<br>
};
<br>
// Get property
<br>
assert.equal(obj.mustBeAnIdentifier, 123);
<br>
// Set property
<br>
obj.mustBeAnIdentifier = 'abc';
<br>
assert.equal(obj.mustBeAnIdentifier, 'abc');
<br>

<br>
As a next step, we’ll go beyond this limitation for property keys: In this section, we’ll use
<br>
arbitrary ﬁxed strings as keys. In the next subsection, we’ll dynamically compute keys.
<br>
Two techniques allow us to use arbitrary strings as property keys.
<br>
First, when creating property keys via object literals, we can quote property keys (with
<br>
single or double quotes):
<br>
const obj = {
<br>
'Can be any string!': 123,
<br>
};
<br>

<br>
Second, when getting or setting properties, we can use square brackets with strings inside
<br>
them:
<br>
// Get property
<br>
assert.equal(obj['Can be any string!'], 123);
<br>
// Set property
<br>
obj['Can be any string!'] = 'abc';
<br>
assert.equal(obj['Can be any string!'], 'abc');
<br>

<br>
You can also use these techniques for methods:
<br>
const obj = {
<br>
'A nice method'() {
<br>

<br>
270
<br>

<br>
28 Single objects
<br>
return 'Yes!';
<br>
},
<br>

<br>
};
<br>
assert.equal(obj['A nice method'](), 'Yes!');
<br>

<br>
28.5.2 Computed property keys
<br>
So far, property keys were always ﬁxed strings inside object literals. In this section we
<br>
learn how to dynamically compute property keys. That enables us to use either arbitrary
<br>
strings or symbols.
<br>
The syntax of dynamically computed property keys in object literals is inspired by dynamically accessing properties. That is, we can use square brackets to wrap expressions:
<br>
const obj = {
<br>
['Hello world!']: true,
<br>
['f'+'o'+'o']: 123,
<br>
[Symbol.toStringTag]: 'Goodbye', // (A)
<br>
};
<br>
assert.equal(obj['Hello world!'], true);
<br>
assert.equal(obj.foo, 123);
<br>
assert.equal(obj[Symbol.toStringTag], 'Goodbye');
<br>

<br>
The main use case for computed keys is having symbols as property keys (line A).
<br>
Note that the square brackets operator for getting and setting properties works with arbitrary expressions:
<br>
assert.equal(obj['f'+'o'+'o'], 123);
<br>
assert.equal(obj['==> foo'.slice(-3)], 123);
<br>

<br>
Methods can have computed property keys, too:
<br>
const methodKey = Symbol();
<br>
const obj = {
<br>
[methodKey]() {
<br>
return 'Yes!';
<br>
},
<br>
};
<br>
assert.equal(obj[methodKey](), 'Yes!');
<br>

<br>
For the remainder of this chapter, we’ll mostly use ﬁxed property keys again (because
<br>
they are syntactically more convenient). But all features are also available for arbitrary
<br>
strings and symbols.
<br>

<br>
Exercise: Non-destructively updating a property via spreading (computed
<br>
key)
<br>

<br>
28.5 Objects as dictionaries (advanced)
<br>

<br>
271
<br>

<br>
exercises/single-objects/update_property_test.mjs
<br>

<br>
28.5.3 The in operator: is there a property with a given key?
<br>
The in operator checks if an object has a property with a given key:
<br>
const obj = {
<br>
foo: 'abc',
<br>
bar: false,
<br>
};
<br>
assert.equal('foo' in obj, true);
<br>
assert.equal('unknownKey' in obj, false);
<br>

<br>
28.5.3.1 Checking if a property exists via truthiness
<br>
You can also use a truthiness check to determine if a property exists:
<br>
assert.equal(
<br>
obj.foo ? 'exists' : 'does not exist',
<br>
'exists');
<br>
assert.equal(
<br>
obj.unknownKey ? 'exists' : 'does not exist',
<br>
'does not exist');
<br>

<br>
The previous checks work because obj.foo is truthy and because reading a missing property returns undefined (which is falsy).
<br>
There is, however, one important caveat: truthiness checks fail if the property exists, but
<br>
has a falsy value (undefined, null, false, 0, "", etc.):
<br>
assert.equal(
<br>
obj.bar ? 'exists' : 'does not exist',
<br>
'does not exist'); // should be: 'exists'
<br>

<br>
28.5.4 Deleting properties
<br>
You can delete properties via the delete operator:
<br>
const obj = {
<br>
foo: 123,
<br>
};
<br>
assert.deepEqual(Object.keys(obj), ['foo']);
<br>
delete obj.foo;
<br>
assert.deepEqual(Object.keys(obj), []);
<br>

<br>
28.5.5 Listing property keys
<br>

<br>
272
<br>

<br>
28 Single objects
<br>

<br>
Table 28.1: Standard library methods for listing own (non-inherited) property keys. All of them return Arrays with strings and/or symbols.
<br>
enumerable
<br>

<br>
non-e.
<br>

<br>
Object.keys()
<br>

<br>
✔
<br>

<br>
Object.getOwnPropertyNames()
<br>

<br>
✔
<br>

<br>
✔
<br>

<br>
Object.getOwnPropertySymbols()
<br>

<br>
✔
<br>

<br>
✔
<br>

<br>
Reflect.ownKeys()
<br>

<br>
✔
<br>

<br>
✔
<br>

<br>
string
<br>

<br>
symbol
<br>

<br>
✔
<br>
✔
<br>
✔
<br>
✔
<br>

<br>
✔
<br>

<br>
Each of the methods in tbl. 28.1 returns an Array with the own property keys of the
<br>
parameter. In the names of the methods, you can see that the following distinction is
<br>
made:
<br>
• A property key can be either a string or a symbol.
<br>
• A property name is a property key whose value is a string.
<br>
• A property symbol is a property key whose value is a symbol.
<br>
The next section describes the term enumerable and demonstrates each of the methods.
<br>
28.5.5.1 Enumerability
<br>
Enumerability is an attribute of a property. Non-enumerable properties are ignored by
<br>
some operations – for example, by Object.keys() (see tbl. 28.1) and by spread properties.
<br>
By default, most properties are enumerable. The next example shows how to change that.
<br>
It also demonstrates the various ways of listing property keys.
<br>
const enumerableSymbolKey = Symbol('enumerableSymbolKey');
<br>
const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');
<br>
// We create enumerable properties via an object literal
<br>
const obj = {
<br>
enumerableStringKey: 1,
<br>
[enumerableSymbolKey]: 2,
<br>
}
<br>
// For non-enumerable properties, we need a more powerful tool
<br>
Object.defineProperties(obj, {
<br>
nonEnumStringKey: {
<br>
value: 3,
<br>
enumerable: false,
<br>
},
<br>
[nonEnumSymbolKey]: {
<br>
value: 4,
<br>
enumerable: false,
<br>
},
<br>
});
<br>
assert.deepEqual(
<br>

<br>
28.5 Objects as dictionaries (advanced)
<br>

<br>
273
<br>

<br>
Object.keys(obj),
<br>
[ 'enumerableStringKey' ]);
<br>
assert.deepEqual(
<br>
Object.getOwnPropertyNames(obj),
<br>
[ 'enumerableStringKey', 'nonEnumStringKey' ]);
<br>
assert.deepEqual(
<br>
Object.getOwnPropertySymbols(obj),
<br>
[ enumerableSymbolKey, nonEnumSymbolKey ]);
<br>
assert.deepEqual(
<br>
Reflect.ownKeys(obj),
<br>
[
<br>
'enumerableStringKey', 'nonEnumStringKey',
<br>
enumerableSymbolKey, nonEnumSymbolKey,
<br>
]);
<br>
Object.defineProperties() is explained later in this chapter.
<br>

<br>
28.5.6 Listing property values via Object.values()
<br>
Object.values() lists the values of all enumerable properties of an object:
<br>
const obj = {foo: 1, bar: 2};
<br>
assert.deepEqual(
<br>
Object.values(obj),
<br>
[1, 2]);
<br>

<br>
28.5.7 Listing property entries via Object.entries()
<br>
Object.entries() lists key-value pairs of enumerable properties. Each pair is encoded
<br>

<br>
as a two-element Array:
<br>
const obj = {foo: 1, bar: 2};
<br>
assert.deepEqual(
<br>
Object.entries(obj),
<br>
[
<br>
['foo', 1],
<br>
['bar', 2],
<br>
]);
<br>

<br>
Exercise: Object.entries()
<br>
exercises/single-objects/find_key_test.mjs
<br>

<br>
28.5.8 Properties are listed deterministically
<br>
Own (non-inherited) properties of objects are always listed in the following order:
<br>
1. Properties with string keys that contain integer indices (that includes Array indices):
<br>
In ascending numeric order
<br>

<br>
274
<br>

<br>
28 Single objects
<br>

<br>
2. Remaining properties with string keys:
<br>
In the order in which they were added
<br>
3. Properties with symbol keys:
<br>
In the order in which they were added
<br>
The following example demonstrates how property keys are sorted according to these
<br>
rules:
<br>
> Object.keys({b:0,a:0, 10:0,2:0})
<br>
[ '2', '10', 'b', 'a' ]
<br>

<br>
The order of properties
<br>
The ECMAScript speciﬁcation describes in more detail how properties are ordered.
<br>

<br>
28.5.9 Assembling objects via Object.fromEntries()
<br>
Given an iterable over [key, value] pairs, Object.fromEntries() creates an object:
<br>
assert.deepEqual(
<br>
Object.fromEntries([['foo',1], ['bar',2]]),
<br>
{
<br>
foo: 1,
<br>
bar: 2,
<br>
}
<br>
);
<br>
Object.fromEntries() does the opposite of Object.entries().
<br>

<br>
To demonstrate both, we’ll use them to implement two tool functions from the library
<br>
Underscore in the next subsubsections.
<br>
28.5.9.1 Example: pick(object, ...keys)
<br>
pick returns a copy of object that only has those properties whose keys are mentioned
<br>

<br>
as arguments:
<br>
const address = {
<br>
street: 'Evergreen Terrace',
<br>
number: '742',
<br>
city: 'Springfield',
<br>
state: 'NT',
<br>
zip: '49007',
<br>
};
<br>
assert.deepEqual(
<br>
pick(address, 'street', 'number'),
<br>
{
<br>
street: 'Evergreen Terrace',
<br>
number: '742',
<br>
}
<br>
);
<br>

<br>
28.5 Objects as dictionaries (advanced)
<br>

<br>
275
<br>

<br>
We can implement pick() as follows:
<br>
function pick(object, ...keys) {
<br>
const filteredEntries = Object.entries(object)
<br>
.filter(([key, _value]) => keys.includes(key));
<br>
return Object.fromEntries(filteredEntries);
<br>
}
<br>

<br>
28.5.9.2 Example: invert(object)
<br>
invert returns a copy of object where the keys and values of all properties are swapped:
<br>
assert.deepEqual(
<br>
invert({a: 1, b: 2, c: 3}),
<br>
{1: 'a', 2: 'b', 3: 'c'}
<br>
);
<br>

<br>
We can implement invert() like this:
<br>
function invert(object) {
<br>
const mappedEntries = Object.entries(object)
<br>
.map(([key, value]) => [value, key]);
<br>
return Object.fromEntries(mappedEntries);
<br>
}
<br>

<br>
28.5.9.3 A simple implementation of Object.fromEntries()
<br>
The following function is a simpliﬁed version of Object.fromEntries():
<br>
function fromEntries(iterable) {
<br>
const result = {};
<br>
for (const [key, value] of iterable) {
<br>
let coercedKey;
<br>
if (typeof key === 'string' || typeof key === 'symbol') {
<br>
coercedKey = key;
<br>
} else {
<br>
coercedKey = String(key);
<br>
}
<br>
result[coercedKey] = value;
<br>
}
<br>
return result;
<br>
}
<br>

<br>
28.5.9.4 A polyﬁll for Object.fromEntries()
<br>
The npm package object.fromentries is a polyﬁll for Object.entries(): it installs its
<br>
own implementation if that method doesn’t exist on the current platform.
<br>

<br>
Exercise: Object.entries() and Object.fromEntries()
<br>

<br>
276
<br>

<br>
28 Single objects
<br>

<br>
exercises/single-objects/omit_properties_test.mjs
<br>

<br>
28.5.10 The pitfalls of using an object as a dictionary
<br>
If you use plain objects (created via object literals) as dictionaries, you have to look out
<br>
for two pitfalls.
<br>
The ﬁrst pitfall is that the in operator also ﬁnds inherited properties:
<br>
const dict = {};
<br>
assert.equal('toString' in dict, true);
<br>

<br>
We want dict to be treated as empty, but the in operator detects the properties it inherits
<br>
from its prototype, Object.prototype.
<br>
The second pitfall is that you can’t use the property key __proto__ because it has special
<br>
powers (it sets the prototype of the object):
<br>
const dict = {};
<br>
dict['__proto__'] = 123;
<br>
// No property was added to dict:
<br>
assert.deepEqual(Object.keys(dict), []);
<br>

<br>
So how do we avoid these pitfalls?
<br>
• Whenever you can, use Maps. They are the best solution for dictionaries.
<br>
• If you can’t, use a library for objects-as-dictionaries that does everything safely.
<br>
• If you can’t, use an object without a prototype.
<br>
The following code demonstrates using objects without prototypes as dictionaries:
<br>
const dict = Object.create(null); // no prototype
<br>
assert.equal('toString' in dict, false); // (A)
<br>
dict['__proto__'] = 123;
<br>
assert.deepEqual(Object.keys(dict), ['__proto__']);
<br>

<br>
We avoided both pitfalls: First, a property without a prototype does not inherit any
<br>
properties (line A). Second, in modern JavaScript, __proto__ is implemented via Object.prototype. That means that it is switched off if Object.prototype is not in the
<br>
prototype chain.
<br>

<br>
Exercise: Using an object as a dictionary
<br>
exercises/single-objects/simple_dict_test.mjs
<br>

<br>
28.6 Standard methods (advanced)
<br>

<br>
277
<br>

<br>
28.6 Standard methods (advanced)
<br>
Object.prototype deﬁnes several standard methods that can be overridden to conﬁgure
<br>
how an object is treated by the language. Two important ones are:
<br>

<br>
• .toString()
<br>
• .valueOf()
<br>

<br>
28.6.1
<br>

<br>
.toString()
<br>

<br>
.toString() determines how objects are converted to strings:
<br>
> String({toString() { return 'Hello!' }})
<br>
'Hello!'
<br>
> String({})
<br>
'[object Object]'
<br>

<br>
28.6.2
<br>

<br>
.valueOf()
<br>

<br>
.valueOf() determines how objects are converted to numbers:
<br>
> Number({valueOf() { return 123 }})
<br>
123
<br>
> Number({})
<br>
NaN
<br>

<br>
28.7 Advanced topics
<br>
The following subsections give brief overviews of a few advanced topics.
<br>

<br>
28.7.1
<br>

<br>
Object.assign()
<br>

<br>
Object.assign() is a tool method:
<br>
Object.assign(target, source_1, source_2, ···)
<br>

<br>
This expression assigns all properties of source_1 to target, then all properties of
<br>
source_2, etc. At the end, it returns target – for example:
<br>
const target = { foo: 1 };
<br>
const result = Object.assign(
<br>
target,
<br>
{bar: 2},
<br>
{baz: 3, bar: 4});
<br>
assert.deepEqual(
<br>
result, { foo: 1, bar: 4, baz: 3 });
<br>
// target was modified and returned:
<br>
assert.equal(result, target);
<br>

<br>
278
<br>

<br>
28 Single objects
<br>

<br>
The use cases for Object.assign() are similar to those for spread properties. In a way, it
<br>
spreads destructively.
<br>

<br>
28.7.2 Freezing objects
<br>
Object.freeze(obj) makes obj completely immutable: You can’t change properties,
<br>

<br>
add properties, or change its prototype – for example:
<br>
const frozen = Object.freeze({ x: 2, y: 5 });
<br>
assert.throws(
<br>
() => { frozen.x = 7 },
<br>
{
<br>
name: 'TypeError',
<br>
message: /^Cannot assign to read only property 'x'/,
<br>
});
<br>

<br>
There is one caveat: Object.freeze(obj) freezes shallowly. That is, only the properties
<br>
of obj are frozen but not objects stored in properties.
<br>

<br>
28.7.3 Property attributes and property descriptors
<br>
Just as objects are composed of properties, properties are composed of attributes. The
<br>
value of a property is only one of several attributes. Others include:
<br>
• writable: Is it possible to change the value of the property?
<br>
• enumerable: Is the property considered by Object.keys(), spreading, etc.?
<br>
When you are using one of the operations for handling property attributes, attributes
<br>
are speciﬁed via property descriptors: objects where each property represents one attribute.
<br>
For example, this is how you read the attributes of a property obj.foo:
<br>
const obj = { foo: 123 };
<br>
assert.deepEqual(
<br>
Object.getOwnPropertyDescriptor(obj, 'foo'),
<br>
{
<br>
value: 123,
<br>
writable: true,
<br>
enumerable: true,
<br>
configurable: true,
<br>
});
<br>

<br>
And this is how you set the attributes of a property obj.bar:
<br>
const obj = {
<br>
foo: 1,
<br>
bar: 2,
<br>
};
<br>
assert.deepEqual(Object.keys(obj), ['foo', 'bar']);
<br>
// Hide property `bar` from Object.keys()
<br>
Object.defineProperty(obj, 'bar', {
<br>

<br>
28.7 Advanced topics
<br>

<br>
279
<br>

<br>
enumerable: false,
<br>
});
<br>
assert.deepEqual(Object.keys(obj), ['foo']);
<br>

<br>
Enumerability is covered in greater detail earlier in this chapter. For more information
<br>
on property attributes and property descriptors, consult Speaking JavaScript.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
280
<br>

<br>
28 Single objects
<br>

<br>
Chapter 29
<br>

<br>
Prototype chains and classes
<br>
Contents
<br>
29.1 Prototype chains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
<br>
29.1.1 JavaScript’s operations: all properties vs. own properties . . . 283
<br>
29.1.2 Pitfall: only the ﬁrst member of a prototype chain is mutated . 283
<br>
29.1.3 Tips for working with prototypes (advanced) . . . . . . . . . . 284
<br>
29.1.4 Sharing data via prototypes . . . . . . . . . . . . . . . . . . . 285
<br>
29.2 Classes
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
<br>

<br>
29.2.1 A class for persons . . . . . . . . . . . . . . . . . . . . . . . . 287
<br>
29.2.2 Classes under the hood . . . . . . . . . . . . . . . . . . . . . . 288
<br>
29.2.3 Class deﬁnitions: prototype properties . . . . . . . . . . . . . 289
<br>
29.2.4 Class deﬁnitions: static properties . . . . . . . . . . . . . . . . 290
<br>
29.2.5 The instanceof operator . . . . . . . . . . . . . . . . . . . . . 290
<br>
29.2.6 Why I recommend classes . . . . . . . . . . . . . . . . . . . . 290
<br>
29.3 Private data for classes . . . . . . . . . . . . . . . . . . . . . . . . . . 291
<br>
29.3.1 Private data: naming convention
<br>

<br>
. . . . . . . . . . . . . . . . 291
<br>

<br>
29.3.2 Private data: WeakMaps . . . . . . . . . . . . . . . . . . . . . 292
<br>
29.3.3 More techniques for private data . . . . . . . . . . . . . . . . . 293
<br>
29.4 Subclassing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
<br>
29.4.1 Subclasses under the hood (advanced)
<br>

<br>
. . . . . . . . . . . . . 294
<br>

<br>
29.4.2 instanceof in more detail (advanced) . . . . . . . . . . . . . . 295
<br>
29.4.3 Prototype chains of built-in objects (advanced) . . . . . . . . . 295
<br>
29.4.4 Dispatched vs. direct method calls (advanced) . . . . . . . . . 298
<br>
29.4.5 Mixin classes (advanced) . . . . . . . . . . . . . . . . . . . . . 299
<br>
29.5 FAQ: objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
<br>
29.5.1 Why do objects preserve the insertion order of properties? . . . 301
<br>

<br>
In this book, JavaScript’s style of object-oriented programming (OOP) is introduced in
<br>
four steps. This chapter covers steps 2–4, the previous chapter covers step 1. The steps
<br>
are (ﬁg. 29.1):
<br>
281
<br>

<br>
282
<br>

<br>
29 Prototype chains and classes
<br>

<br>
1. Single objects (previous chapter): How do objects, JavaScript’s basic OOP building
<br>
blocks, work in isolation?
<br>
2. Prototype chains (this chapter): Each object has a chain of zero or more prototype
<br>
objects. Prototypes are JavaScript’s core inheritance mechanism.
<br>
3. Classes (this chapter): JavaScript’s classes are factories for objects. The relationship
<br>
between a class and its instances is based on prototypal inheritance.
<br>
4. Subclassing (this chapter): The relationship between a subclass and its superclass is
<br>
also based on prototypal inheritance.
<br>
SuperClass
<br>
superData
<br>
superMthd
<br>
mthd
<br>

<br>
ƒ
<br>
MyClass
<br>

<br>
mthd
<br>

<br>
ƒ
<br>

<br>
__proto__
<br>

<br>
data
<br>

<br>
4
<br>

<br>
data
<br>

<br>
4
<br>

<br>
1. Single objects 2. Prototype chains
<br>

<br>
SubClass
<br>

<br>
data
<br>

<br>
subData
<br>

<br>
mthd
<br>

<br>
subMthd
<br>

<br>
3. Classes
<br>

<br>
4. Subclassing
<br>

<br>
Figure 29.1: This book introduces object-oriented programming in JavaScript in four
<br>
steps.
<br>

<br>
29.1 Prototype chains
<br>
Prototypes are JavaScript’s only inheritance mechanism: each object has a prototype that
<br>
is either null or an object. In the latter case, the object inherits all of the prototype’s
<br>
properties.
<br>
In an object literal, you can set the prototype via the special property __proto__:
<br>
const proto = {
<br>
protoProp: 'a',
<br>
};
<br>
const obj = {
<br>
__proto__: proto,
<br>
objProp: 'b',
<br>
};
<br>
// obj inherits .protoProp:
<br>
assert.equal(obj.protoProp, 'a');
<br>
assert.equal('protoProp' in obj, true);
<br>

<br>
Given that a prototype object can have a prototype itself, we get a chain of objects – the
<br>
so-called prototype chain. That means that inheritance gives us the impression that we are
<br>
dealing with single objects, but we are actually dealing with chains of objects.
<br>
Fig. 29.2 shows what the prototype chain of obj looks like.
<br>
Non-inherited properties are called own properties. obj has one own property, .objProp.
<br>

<br>
283
<br>

<br>
29.1 Prototype chains
<br>

<br>
...
<br>
proto
<br>
__proto__
<br>
protoProp
<br>

<br>
'a'
<br>

<br>
obj
<br>
__proto__
<br>
objProp
<br>

<br>
'b'
<br>

<br>
Figure 29.2: obj starts a chain of objects that continues with proto and other objects.
<br>

<br>
29.1.1 JavaScript’s operations: all properties vs. own properties
<br>
Some operations consider all properties (own and inherited) – for example, getting properties:
<br>
> const obj = { foo: 1 };
<br>
> typeof obj.foo // own
<br>
'number'
<br>
> typeof obj.toString // inherited
<br>
'function'
<br>

<br>
Other operations only consider own properties – for example, Object.keys():
<br>
> Object.keys(obj)
<br>
[ 'foo' ]
<br>

<br>
Read on for another operation that also only considers own properties: setting properties.
<br>

<br>
29.1.2 Pitfall: only the ﬁrst member of a prototype chain is mutated
<br>
One aspect of prototype chains that may be counter-intuitive is that setting any property
<br>
via an object – even an inherited one – only changes that very object – never one of the
<br>
prototypes.
<br>
Consider the following object obj:
<br>
const proto = {
<br>
protoProp: 'a',
<br>
};
<br>
const obj = {
<br>
__proto__: proto,
<br>
objProp: 'b',
<br>
};
<br>

<br>
In the next code snippet, we set the inherited property obj.protoProp (line A). That
<br>

<br>
284
<br>

<br>
29 Prototype chains and classes
<br>

<br>
“changes” it by creating an own property: When reading obj.protoProp, the own property is found ﬁrst and its value overrides the value of the inherited property.
<br>
// In the beginning, obj has one own property
<br>
assert.deepEqual(Object.keys(obj), ['objProp']);
<br>
obj.protoProp = 'x'; // (A)
<br>
// We created a new own property:
<br>
assert.deepEqual(Object.keys(obj), ['objProp', 'protoProp']);
<br>
// The inherited property itself is unchanged:
<br>
assert.equal(proto.protoProp, 'a');
<br>
// The own property overrides the inherited property:
<br>
assert.equal(obj.protoProp, 'x');
<br>

<br>
The prototype chain of obj is depicted in ﬁg. 29.3.
<br>

<br>
...
<br>
proto
<br>
__proto__
<br>
protoProp
<br>

<br>
'a'
<br>

<br>
obj
<br>
__proto__
<br>
objProp
<br>

<br>
'b'
<br>

<br>
protoProp
<br>

<br>
'x'
<br>

<br>
Figure 29.3: The own property .protoProp of obj overrides the property inherited from
<br>
proto.
<br>

<br>
29.1.3 Tips for working with prototypes (advanced)
<br>
29.1.3.1 Best practice: avoid __proto__, except in object literals
<br>
I recommend to avoid the pseudo-property __proto__: As we will see later, not all objects
<br>
have it.
<br>
However, __proto__ in object literals is different. There, it is a built-in feature and always
<br>
available.
<br>
The recommended ways of getting and setting prototypes are:
<br>
• The best way to get a prototype is via the following method:
<br>

<br>
29.1 Prototype chains
<br>

<br>
285
<br>

<br>
Object.getPrototypeOf(obj: Object) : Object
<br>

<br>
• The best way to set a prototype is when creating an object – via __proto__ in an
<br>
object literal or via:
<br>
Object.create(proto: Object) : Object
<br>

<br>
If you have to, you can use Object.setPrototypeOf() to change the prototype of
<br>
an existing object. But that may affect performance negatively.
<br>
This is how these features are used:
<br>
const proto1 = {};
<br>
const proto2 = {};
<br>
const obj = Object.create(proto1);
<br>
assert.equal(Object.getPrototypeOf(obj), proto1);
<br>
Object.setPrototypeOf(obj, proto2);
<br>
assert.equal(Object.getPrototypeOf(obj), proto2);
<br>

<br>
29.1.3.2 Check: is an object a prototype of another one?
<br>
So far, “p is a prototype of o” always meant “p is a direct prototype of o”. But it can also be
<br>
used more loosely and mean that p is in the prototype chain of o. That looser relationship
<br>
can be checked via:
<br>
p.isPrototypeOf(o)
<br>

<br>
For example:
<br>
const a = {};
<br>
const b = {__proto__: a};
<br>
const c = {__proto__: b};
<br>
assert.equal(a.isPrototypeOf(b), true);
<br>
assert.equal(a.isPrototypeOf(c), true);
<br>
assert.equal(a.isPrototypeOf(a), false);
<br>
assert.equal(c.isPrototypeOf(a), false);
<br>

<br>
29.1.4 Sharing data via prototypes
<br>
Consider the following code:
<br>
const jane = {
<br>
name: 'Jane',
<br>
describe() {
<br>
return 'Person named '+this.name;
<br>
},
<br>
};
<br>
const tarzan = {
<br>
name: 'Tarzan',
<br>

<br>
286
<br>

<br>
29 Prototype chains and classes
<br>
describe() {
<br>
return 'Person named '+this.name;
<br>
},
<br>

<br>
};
<br>
assert.equal(jane.describe(), 'Person named Jane');
<br>
assert.equal(tarzan.describe(), 'Person named Tarzan');
<br>

<br>
We have two objects that are very similar. Both have two properties whose names are
<br>
.name and .describe. Additionally, method .describe() is the same. How can we avoid
<br>
duplicating that method?
<br>
We can move it to an object PersonProto and make that object a prototype of both jane
<br>
and tarzan:
<br>
const PersonProto = {
<br>
describe() {
<br>
return 'Person named ' + this.name;
<br>
},
<br>
};
<br>
const jane = {
<br>
__proto__: PersonProto,
<br>
name: 'Jane',
<br>
};
<br>
const tarzan = {
<br>
__proto__: PersonProto,
<br>
name: 'Tarzan',
<br>
};
<br>

<br>
The name of the prototype reﬂects that both jane and tarzan are persons.
<br>

<br>
PersonProto
<br>
describe
<br>
jane
<br>

<br>
tarzan
<br>

<br>
__proto__
<br>
name
<br>

<br>
function() {···}
<br>

<br>
__proto__
<br>
'Jane'
<br>

<br>
name
<br>

<br>
'Tarzan'
<br>

<br>
Figure 29.4: Objects jane and tarzan share method .describe(), via their common prototype PersonProto.
<br>
Fig. 29.4 illustrates how the three objects are connected: The objects at the bottom now
<br>
contain the properties that are speciﬁc to jane and tarzan. The object at the top contains
<br>
the properties that are shared between them.
<br>
When you make the method call jane.describe(), this points to the receiver of that
<br>
method call, jane (in the bottom-left corner of the diagram). That’s why the method still
<br>
works. tarzan.describe() works similarly.
<br>

<br>
29.2 Classes
<br>

<br>
287
<br>

<br>
assert.equal(jane.describe(), 'Person named Jane');
<br>
assert.equal(tarzan.describe(), 'Person named Tarzan');
<br>

<br>
29.2 Classes
<br>
We are now ready to take on classes, which are basically a compact syntax for setting up
<br>
prototype chains. Under the hood, JavaScript’s classes are unconventional. But that is
<br>
something you rarely see when working with them. They should normally feel familiar
<br>
to people who have used other object-oriented programming languages.
<br>

<br>
29.2.1 A class for persons
<br>
We have previously worked with jane and tarzan, single objects representing persons.
<br>
Let’s use a class declaration to implement a factory for person objects:
<br>
class Person {
<br>
constructor(name) {
<br>
this.name = name;
<br>
}
<br>
describe() {
<br>
return 'Person named '+this.name;
<br>
}
<br>
}
<br>
jane and tarzan can now be created via new Person():
<br>
const jane = new Person('Jane');
<br>
assert.equal(jane.name, 'Jane');
<br>
assert.equal(jane.describe(), 'Person named Jane');
<br>
const tarzan = new Person('Tarzan');
<br>
assert.equal(tarzan.name, 'Tarzan');
<br>
assert.equal(tarzan.describe(), 'Person named Tarzan');
<br>

<br>
Class Person has two methods:
<br>
• The normal method .describe()
<br>
• The special method .constructor() which is called directly after a new instance
<br>
has been created and initializes that instance. It receives the arguments that are
<br>
passed to the new operator (after the class name). If you don’t need any arguments
<br>
to set up a new instance, you can omit the constructor.
<br>
29.2.1.1 Class expressions
<br>
There are two kinds of class deﬁnitions (ways of deﬁning classes):
<br>
• Class declarations, which we have seen in the previous section.
<br>
• Class expressions, which we’ll see next.
<br>
Class expressions can be anonymous and named:
<br>

<br>
288
<br>

<br>
29 Prototype chains and classes
<br>

<br>
// Anonymous class expression
<br>
const Person = class { ··· };
<br>
// Named class expression
<br>
const Person = class MyClass { ··· };
<br>

<br>
The name of a named class expression works similarly to the name of a named function
<br>
expression.
<br>
This was a ﬁrst look at classes. We’ll explore more features soon, but ﬁrst we need to
<br>
learn the internals of classes.
<br>

<br>
29.2.2 Classes under the hood
<br>
There is a lot going on under the hood of classes. Let’s look at the diagram for jane
<br>
(ﬁg. 29.5).
<br>

<br>
Person
<br>
prototype
<br>

<br>
Person.prototype
<br>
constructor
<br>
describe
<br>

<br>
function() {...}
<br>

<br>
jane
<br>
__proto__
<br>
name
<br>

<br>
'Jane'
<br>

<br>
Figure 29.5: The class Person has the property .prototype that points to an object that is
<br>
the prototype of all instances of Person. jane is one such instance.
<br>
The main purpose of class Person is to set up the prototype chain on the right (jane,
<br>
followed by Person.prototype). It is interesting to note that both constructs inside class
<br>
Person (.constructor and .describe()) created properties for Person.prototype, not
<br>
for Person.
<br>
The reason for this slightly odd approach is backward compatibility: prior to classes,
<br>
constructor functions (ordinary functions, invoked via the new operator) were often used
<br>
as factories for objects. Classes are mostly better syntax for constructor functions and
<br>
therefore remain compatible with old code. That explains why classes are functions:
<br>
> typeof Person
<br>
'function'
<br>

<br>
In this book, I use the terms constructor (function) and class interchangeably.
<br>
It is easy to confuse .__proto__ and .prototype. Hopefully, ﬁg. 29.5 makes it clear how
<br>
they differ:
<br>

<br>
29.2 Classes
<br>

<br>
289
<br>

<br>
• .__proto__ is a pseudo-property for accessing the prototype of an object.
<br>
• .prototype is a normal property that is only special due to how the new operator
<br>
uses it. The name is not ideal: Person.prototype does not point to the prototype
<br>
of Person, it points to the prototype of all instances of Person.
<br>
29.2.2.1 Person.prototype.constructor (advanced)
<br>
There is one detail in ﬁg. 29.5 that we haven’t looked at, yet: Person.prototype.constructor
<br>
points back to Person:
<br>
> Person.prototype.constructor === Person
<br>
true
<br>

<br>
This setup also exists due to backward compatibility. But it has two additional beneﬁts.
<br>
First, each instance of a class inherits property .constructor. Therefore, given an instance, you can make “similar” objects using it:
<br>
const jane = new Person('Jane');
<br>
const cheeta = new jane.constructor('Cheeta');
<br>
// cheeta is also an instance of Person
<br>
// (the instanceof operator is explained later)
<br>
assert.equal(cheeta instanceof Person, true);
<br>

<br>
Second, you can get the name of the class that created a given instance:
<br>
const tarzan = new Person('Tarzan');
<br>
assert.equal(tarzan.constructor.name, 'Person');
<br>

<br>
29.2.3 Class deﬁnitions: prototype properties
<br>
All constructs in the body of the following class declaration create properties of
<br>
Foo.prototype.
<br>
class Foo {
<br>
constructor(prop) {
<br>
this.prop = prop;
<br>
}
<br>
protoMethod() {
<br>
return 'protoMethod';
<br>
}
<br>
get protoGetter() {
<br>
return 'protoGetter';
<br>
}
<br>
}
<br>

<br>
Let’s examine them in order:
<br>
• .constructor() is called after creating a new instance of Foo to set up that instance.
<br>
• .protoMethod() is a normal method. It is stored in Foo.prototype.
<br>
• .protoGetter is a getter that is stored in Foo.prototype.
<br>

<br>
290
<br>

<br>
29 Prototype chains and classes
<br>

<br>
The following interaction uses class Foo:
<br>
> const foo = new Foo(123);
<br>
> foo.prop
<br>
123
<br>
> foo.protoMethod()
<br>
'protoMethod'
<br>
> foo.protoGetter
<br>
'protoGetter'
<br>

<br>
29.2.4 Class deﬁnitions: static properties
<br>
All constructs in the body of the following class declaration create so-called static properties – properties of Bar itself.
<br>
class Bar {
<br>
static staticMethod() {
<br>
return 'staticMethod';
<br>
}
<br>
static get staticGetter() {
<br>
return 'staticGetter';
<br>
}
<br>
}
<br>

<br>
The static method and the static getter are used as follows:
<br>
> Bar.staticMethod()
<br>
'staticMethod'
<br>
> Bar.staticGetter
<br>
'staticGetter'
<br>

<br>
29.2.5 The instanceof operator
<br>
The instanceof operator tells you if a value is an instance of a given class:
<br>
> new Person('Jane') instanceof Person
<br>
true
<br>
> ({}) instanceof Person
<br>
false
<br>
> ({}) instanceof Object
<br>
true
<br>
> [] instanceof Array
<br>
true
<br>

<br>
We’ll explore the instanceof operator in more detail later, after we have looked at subclassing.
<br>

<br>
29.2.6 Why I recommend classes
<br>
I recommend using classes for the following reasons:
<br>

<br>
29.3 Private data for classes
<br>

<br>
291
<br>

<br>
• Classes are a common standard for object creation and inheritance that is now
<br>
widely supported across frameworks (React, Angular, Ember, etc.). This is an improvement to how things were before, when almost every framework had its own
<br>
inheritance library.
<br>
• They help tools such as IDEs and type checkers with their work and enable new
<br>
features there.
<br>
• If you come from another language to JavaScript and are used to classes, then you
<br>
can get started more quickly.
<br>
• JavaScript engines optimize them. That is, code that uses classes is almost always
<br>
faster than code that uses a custom inheritance library.
<br>
• You can subclass built-in constructor functions such as Error.
<br>
That doesn’t mean that classes are perfect:
<br>
• There is a risk of overdoing inheritance.
<br>
• There is a risk of putting too much functionality in classes (when some of it is often
<br>
better put in functions).
<br>
• How they work superﬁcially and under the hood is quite different. In other words,
<br>
there is a disconnect between syntax and semantics. Two examples are:
<br>
– A method deﬁnition inside a class C creates a method in the object
<br>
C.prototype.
<br>
– Classes are functions.
<br>
The motivation for the disconnect is backward compatibility. Thankfully, the disconnect causes few problems in practice; you are usually OK if you go along with
<br>
what classes pretend to be.
<br>

<br>
Exercise: Writing a class
<br>
exercises/proto-chains-classes/point_class_test.mjs
<br>

<br>
29.3 Private data for classes
<br>
This section describes techniques for hiding some of the data of an object from the outside.
<br>
We discuss them in the context of classes, but they also work for objects created directly,
<br>
e.g., via object literals.
<br>

<br>
29.3.1 Private data: naming convention
<br>
The ﬁrst technique makes a property private by preﬁxing its name with an underscore.
<br>
This doesn’t protect the property in any way; it merely signals to the outside: “You don’t
<br>
need to know about this property.”
<br>
In the following code, the properties ._counter and ._action are private.
<br>

<br>
292
<br>

<br>
29 Prototype chains and classes
<br>

<br>
class Countdown {
<br>
constructor(counter, action) {
<br>
this._counter = counter;
<br>
this._action = action;
<br>
}
<br>
dec() {
<br>
this._counter--;
<br>
if (this._counter === 0) {
<br>
this._action();
<br>
}
<br>
}
<br>
}
<br>
// The two properties aren’t really private:
<br>
assert.deepEqual(
<br>
Object.keys(new Countdown()),
<br>
['_counter', '_action']);
<br>

<br>
With this technique, you don’t get any protection and private names can clash. On the
<br>
plus side, it is easy to use.
<br>

<br>
29.3.2 Private data: WeakMaps
<br>
Another technique is to use WeakMaps. How exactly that works is explained in the chapter on WeakMaps. This is a preview:
<br>
const _counter = new WeakMap();
<br>
const _action = new WeakMap();
<br>
class Countdown {
<br>
constructor(counter, action) {
<br>
_counter.set(this, counter);
<br>
_action.set(this, action);
<br>
}
<br>
dec() {
<br>
let counter = _counter.get(this);
<br>
counter--;
<br>
_counter.set(this, counter);
<br>
if (counter === 0) {
<br>
_action.get(this)();
<br>
}
<br>
}
<br>
}
<br>
// The two pseudo-properties are truly private:
<br>
assert.deepEqual(
<br>
Object.keys(new Countdown()),
<br>
[]);
<br>

<br>
This technique offers you considerable protection from outside access and there can’t be
<br>

<br>
29.4 Subclassing
<br>

<br>
293
<br>

<br>
any name clashes. But it is also more complicated to use.
<br>

<br>
29.3.3 More techniques for private data
<br>
This book explains the most important techniques for private data in classes. There will
<br>
also probably soon be built-in support for it. Consult the ECMAScript proposal “Class
<br>
Public Instance Fields & Private Instance Fields” for details.
<br>
A few additional techniques are explained in Exploring ES6.
<br>

<br>
29.4 Subclassing
<br>
Classes can also subclass (“extend”) existing classes. As an example, the following class
<br>
Employee subclasses Person:
<br>
class Person {
<br>
constructor(name) {
<br>
this.name = name;
<br>
}
<br>
describe() {
<br>
return `Person named ${this.name}`;
<br>
}
<br>
static logNames(persons) {
<br>
for (const person of persons) {
<br>
console.log(person.name);
<br>
}
<br>
}
<br>
}
<br>
class Employee extends Person {
<br>
constructor(name, title) {
<br>
super(name);
<br>
this.title = title;
<br>
}
<br>
describe() {
<br>
return super.describe() +
<br>
` (${this.title})`;
<br>
}
<br>
}
<br>
const jane = new Employee('Jane', 'CTO');
<br>
assert.equal(
<br>
jane.describe(),
<br>
'Person named Jane (CTO)');
<br>

<br>
Two comments:
<br>
• Inside a .constructor() method, you must call the super-constructor via super()
<br>
before you can access this. That’s because this doesn’t exist before the superconstructor is called (this phenomenon is speciﬁc to classes).
<br>

<br>
294
<br>

<br>
29 Prototype chains and classes
<br>

<br>
• Static methods are also inherited. For example, Employee inherits the static method
<br>
.logNames():
<br>
> 'logNames' in Employee
<br>
true
<br>

<br>
Exercise: Subclassing
<br>
exercises/proto-chains-classes/color_point_class_test.mjs
<br>

<br>
29.4.1 Subclasses under the hood (advanced)
<br>
Function.prototype
<br>

<br>
Object.prototype
<br>

<br>
__proto__
<br>
Person
<br>

<br>
__proto__
<br>
prototype
<br>

<br>
Person.prototype
<br>

<br>
__proto__
<br>
Employee
<br>

<br>
__proto__
<br>
prototype
<br>

<br>
Employee.prototype
<br>
__proto__
<br>
jane
<br>

<br>
Figure 29.6: These are the objects that make up class Person and its subclass, Employee.
<br>
The left column is about classes. The right column is about the Employee instance jane
<br>
and its prototype chain.
<br>
The classes Person and Employee from the previous section are made up of several objects
<br>
(ﬁg. 29.6). One key insight for understanding how these objects are related is that there
<br>
are two prototype chains:
<br>
• The instance prototype chain, on the right.
<br>
• The class prototype chain, on the left.
<br>
29.4.1.1 The instance prototype chain (right column)
<br>
The instance prototype chain starts with jane and continues with Employee.prototype
<br>
and Person.prototype. In principle, the prototype chain ends at this point, but we get
<br>
one more object: Object.prototype. This prototype provides services to virtually all
<br>
objects, which is why it is included here, too:
<br>
> Object.getPrototypeOf(Person.prototype) === Object.prototype
<br>
true
<br>

<br>
29.4 Subclassing
<br>

<br>
295
<br>

<br>
29.4.1.2 The class prototype chain (left column)
<br>
In the class prototype chain, Employee comes ﬁrst, Person next. Afterward, the chain
<br>
continues with Function.prototype, which is only there because Person is a function
<br>
and functions need the services of Function.prototype.
<br>
> Object.getPrototypeOf(Person) === Function.prototype
<br>
true
<br>

<br>
29.4.2
<br>

<br>
instanceof in more detail (advanced)
<br>

<br>
We have not yet seen how instanceof really works. Given the expression:
<br>
x instanceof C
<br>

<br>
How does instanceof determine if x is an instance of C (or a subclass of C)? It does so by
<br>
checking if C.prototype is in the prototype chain of x. That is, the following expression
<br>
is equivalent:
<br>
C.prototype.isPrototypeOf(x)
<br>

<br>
If we go back to ﬁg. 29.6, we can conﬁrm that the prototype chain does lead us to the
<br>
following correct answers:
<br>
> jane instanceof Employee
<br>
true
<br>
> jane instanceof Person
<br>
true
<br>
> jane instanceof Object
<br>
true
<br>

<br>
29.4.3 Prototype chains of built-in objects (advanced)
<br>
Next, we’ll use our knowledge of subclassing to understand the prototype chains of a
<br>
few built-in objects. The following tool function p() helps us with our explorations.
<br>
const p = Object.getPrototypeOf.bind(Object);
<br>

<br>
We extracted method .getPrototypeOf() of Object and assigned it to p.
<br>
29.4.3.1 The prototype chain of {}
<br>
Let’s start by examining plain objects:
<br>
> p({}) === Object.prototype
<br>
true
<br>
> p(p({})) === null
<br>
true
<br>

<br>
Fig. 29.7 shows a diagram for this prototype chain. We can see that {} really is an instance
<br>
of Object – Object.prototype is in its prototype chain.
<br>

<br>
296
<br>

<br>
29 Prototype chains and classes
<br>

<br>
null
<br>
__proto__
<br>
Object.prototype
<br>
__proto__
<br>
{}
<br>

<br>
Figure 29.7: The prototype chain of an object created via an object literal starts with that
<br>
object, continues with Object.prototype, and ends with null.
<br>

<br>
29.4.3.2 The prototype chain of []
<br>
What does the prototype chain of an Array look like?
<br>
> p([]) === Array.prototype
<br>
true
<br>
> p(p([])) === Object.prototype
<br>
true
<br>
> p(p(p([]))) === null
<br>
true
<br>

<br>
null
<br>
__proto__
<br>
Object.prototype
<br>
__proto__
<br>
Array.prototype
<br>
__proto__
<br>
[]
<br>

<br>
Figure 29.8: The prototype chain of an Array has these members: the Array instance,
<br>
Array.prototype, Object.prototype, null.
<br>

<br>
This prototype chain (visualized in ﬁg. 29.8) tells us that an Array object is an instance of
<br>
Array, which is a subclass of Object.
<br>

<br>
29.4 Subclassing
<br>

<br>
297
<br>

<br>
29.4.3.3 The prototype chain of function () {}
<br>
Lastly, the prototype chain of an ordinary function tells us that all functions are objects:
<br>
> p(function () {}) === Function.prototype
<br>
true
<br>
> p(p(function () {})) === Object.prototype
<br>
true
<br>

<br>
29.4.3.4 Objects that aren’t instances of Object
<br>
An object is only an instance of Object if Object.prototype is in its prototype chain.
<br>
Most objects created via various literals are instances of Object:
<br>
> ({}) instanceof Object
<br>
true
<br>
> (() => {}) instanceof Object
<br>
true
<br>
> /abc/ug instanceof Object
<br>
true
<br>

<br>
Objects that don’t have prototypes are not instances of Object:
<br>
> ({ __proto__: null }) instanceof Object
<br>
false
<br>
Object.prototype ends most prototype chains. Its prototype is null, which means it
<br>
isn’t an instance of Object either:
<br>
> Object.prototype instanceof Object
<br>
false
<br>

<br>
29.4.3.5 How exactly does the pseudo-property .__proto__ work?
<br>
The pseudo-property .__proto__ is implemented by class Object via a getter and a setter.
<br>
It could be implemented like this:
<br>
class Object {
<br>
get __proto__() {
<br>
return Object.getPrototypeOf(this);
<br>
}
<br>
set __proto__(other) {
<br>
Object.setPrototypeOf(this, other);
<br>
}
<br>
// ···
<br>
}
<br>

<br>
That means that you can switch .__proto__ off by creating an object that doesn’t have
<br>
Object.prototype in its prototype chain (see the previous section):
<br>
> '__proto__' in {}
<br>
true
<br>
> '__proto__' in { __proto__: null }
<br>
false
<br>

<br>
298
<br>

<br>
29 Prototype chains and classes
<br>

<br>
29.4.4 Dispatched vs. direct method calls (advanced)
<br>
Let’s examine how method calls work with classes. We are revisiting jane from earlier:
<br>
class Person {
<br>
constructor(name) {
<br>
this.name = name;
<br>
}
<br>
describe() {
<br>
return 'Person named '+this.name;
<br>
}
<br>
}
<br>
const jane = new Person('Jane');
<br>

<br>
Fig. 29.9 has a diagram with jane’s prototype chain.
<br>

<br>
...
<br>
Person.prototype
<br>
__proto__
<br>
describe
<br>

<br>
function() {···}
<br>

<br>
jane
<br>
__proto__
<br>
name
<br>

<br>
'Jane'
<br>

<br>
Figure 29.9: The prototype chain of jane starts with jane and continues with Person.prototype.
<br>
Normal method calls are dispatched – the method call jane.describe() happens in two
<br>
steps:
<br>
• Dispatch: In the prototype chain of jane, ﬁnd the ﬁrst property whose key is 'describe' and retrieve its value.
<br>
const func = jane.describe;
<br>

<br>
• Call: Call the value, while setting this to jane.
<br>
func.call(jane);
<br>

<br>
This way of dynamically looking for a method and invoking it is called dynamic dispatch.
<br>
You can make the same method call directly, without dispatching:
<br>
Person.prototype.describe.call(jane)
<br>

<br>
This time, we directly point to the method via Person.prototype.describe and don’t
<br>
search for it in the prototype chain. We also specify this differently via .call().
<br>

<br>
29.4 Subclassing
<br>

<br>
299
<br>

<br>
Note that this always points to the beginning of a prototype chain. That enables .describe() to access .name.
<br>
29.4.4.1 Borrowing methods
<br>
Direct method calls become useful when you are working with methods of Object.prototype. For example, Object.prototype.hasOwnProperty(k) checks if this
<br>

<br>
has a non-inherited property whose key is k:
<br>
> const obj = { foo: 123 };
<br>
> obj.hasOwnProperty('foo')
<br>
true
<br>
> obj.hasOwnProperty('bar')
<br>
false
<br>

<br>
However, in the prototype chain of an object, there may be another property with the key
<br>
'hasOwnProperty' that overrides the method in Object.prototype. Then a dispatched
<br>
method call doesn’t work:
<br>
> const obj = { hasOwnProperty: true };
<br>
> obj.hasOwnProperty('bar')
<br>
TypeError: obj.hasOwnProperty is not a function
<br>

<br>
The workaround is to use a direct method call:
<br>
> Object.prototype.hasOwnProperty.call(obj, 'bar')
<br>
false
<br>
> Object.prototype.hasOwnProperty.call(obj, 'hasOwnProperty')
<br>
true
<br>

<br>
This kind of direct method call is often abbreviated as follows:
<br>
> ({}).hasOwnProperty.call(obj, 'bar')
<br>
false
<br>
> ({}).hasOwnProperty.call(obj, 'hasOwnProperty')
<br>
true
<br>

<br>
This pattern may seem inefﬁcient, but most engines optimize this pattern, so performance
<br>
should not be an issue.
<br>

<br>
29.4.5 Mixin classes (advanced)
<br>
JavaScript’s class system only supports single inheritance. That is, each class can have at
<br>
most one superclass. One way around this limitation is via a technique called mixin classes
<br>
(short: mixins).
<br>
The idea is as follows: Let’s say we want a class C to inherit from two superclasses S1 and
<br>
S2. That would be multiple inheritance, which JavaScript doesn’t support.
<br>
Our workaround is to turn S1 and S2 into mixins, factories for subclasses:
<br>
const S1 = (Sup) => class extends Sup { /*···*/ };
<br>
const S2 = (Sup) => class extends Sup { /*···*/ };
<br>

<br>
300
<br>

<br>
29 Prototype chains and classes
<br>

<br>
Each of these two functions returns a class that extends a given superclass Sup. We create
<br>
class C as follows:
<br>
class C extends S2(S1(Object)) {
<br>
/*···*/
<br>
}
<br>

<br>
We now have a class C that extends a class S2 that extends a class S1 that extends Object
<br>
(which most classes do implicitly).
<br>

<br>
29.4.5.1 Example: a mixin for brand management
<br>
We implement a mixin Branded that has helper methods for setting and getting the brand
<br>
of an object:
<br>
const Branded = (Sup) => class extends Sup {
<br>
setBrand(brand) {
<br>
this._brand = brand;
<br>
return this;
<br>
}
<br>
getBrand() {
<br>
return this._brand;
<br>
}
<br>
};
<br>

<br>
We use this mixin to implement brand management for a class Car:
<br>
class Car extends Branded(Object) {
<br>
constructor(model) {
<br>
super();
<br>
this._model = model;
<br>
}
<br>
toString() {
<br>
return `${this.getBrand()} ${this._model}`;
<br>
}
<br>
}
<br>

<br>
The following code conﬁrms that the mixin worked: Car has method .setBrand() of
<br>
Branded.
<br>
const modelT = new Car('Model T').setBrand('Ford');
<br>
assert.equal(modelT.toString(), 'Ford Model T');
<br>

<br>
29.4.5.2 The beneﬁts of mixins
<br>
Mixins free us from the constraints of single inheritance:
<br>
• The same class can extend a single superclass and zero or more mixins.
<br>
• The same mixin can be used by multiple classes.
<br>

<br>
29.5 FAQ: objects
<br>

<br>
301
<br>

<br>
29.5 FAQ: objects
<br>
29.5.1 Why do objects preserve the insertion order of properties?
<br>
In principle, objects are unordered. The main reason for ordering properties is so that
<br>
operations that list entries, keys, or values are deterministic. That helps, e.g., with testing.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
302
<br>

<br>
29 Prototype chains and classes
<br>

<br>
Part VII
<br>

<br>
Collections
<br>

<br>
303
<br>

<br>
Chapter 30
<br>

<br>
Synchronous iteration
<br>
Contents
<br>
30.1 What is synchronous iteration about? . . . . . . . . . . . . . . . . . 305
<br>
30.2 Core iteration constructs: iterables and iterators . . . . . . . . . . . . 306
<br>
30.3 Iterating manually . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
<br>
30.3.1 Iterating over an iterable via while
<br>

<br>
. . . . . . . . . . . . . . . 307
<br>

<br>
30.4 Iteration in practice . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
<br>
30.4.1 Iterating over Arrays . . . . . . . . . . . . . . . . . . . . . . . 308
<br>
30.4.2 Iterating over Sets . . . . . . . . . . . . . . . . . . . . . . . . . 308
<br>
30.5 Quick reference: synchronous iteration . . . . . . . . . . . . . . . . 309
<br>
30.5.1 Iterable data sources . . . . . . . . . . . . . . . . . . . . . . . 309
<br>
30.5.2 Iterating constructs . . . . . . . . . . . . . . . . . . . . . . . . 309
<br>

<br>
30.1 What is synchronous iteration about?
<br>
Synchronous iteration is a protocol (interfaces plus rules for using them) that connects two
<br>
groups of entities in JavaScript:
<br>
• Data sources: On one hand, data comes in all shapes and sizes. In JavaScript’s
<br>
standard library, you have the linear data structure Array, the ordered collection
<br>
Set (elements are ordered by time of addition), the ordered dictionary Map (entries
<br>
are ordered by time of addition), and more. In libraries, you may ﬁnd tree-shaped
<br>
data structures and more.
<br>
• Data consumers: On the other hand, you have a whole class of constructs and
<br>
algorithms that only need to access their input sequentially: one value at a time,
<br>
until all values were visited. Examples include the for-of loop and spreading
<br>
into function calls (via ...).
<br>
The iteration protocol connects these two groups via the interface Iterable: data sources
<br>
deliver their contents sequentially “through it”; data consumers get their input via it.
<br>
305
<br>

<br>
306
<br>

<br>
30 Synchronous iteration
<br>

<br>
Data consumers
<br>

<br>
Interface
<br>

<br>
Data sources
<br>

<br>
for-of loop
<br>

<br>
Arrays
<br>
Iterable
<br>

<br>
Maps
<br>

<br>
spreading
<br>

<br>
Strings
<br>

<br>
Figure 30.1: Data consumers such as the for-of loop use the interface Iterable. Data
<br>
sources such as Arrays implement that interface.
<br>

<br>
Fig. 30.1 illustrates how iteration works: data consumers use the interface Iterable; data
<br>
sources implement it.
<br>

<br>
The JavaScript way of implementing interfaces
<br>
In JavaScript, an object implements an interface if it has all the methods that it describes. The interfaces mentioned in this chapter only exist in the ECMAScript speciﬁcation.
<br>
Both sources and consumers of data proﬁt from this arrangement:
<br>
• If you develop a new data structure, you only need to implement Iterable and a
<br>
raft of tools can immediately be applied to it.
<br>
• If you write code that uses iteration, it automatically works with many sources of
<br>
data.
<br>

<br>
30.2 Core iteration constructs: iterables and iterators
<br>
Two roles (described by interfaces) form the core of iteration (ﬁg. 30.2):
<br>
• An iterable is an object whose contents can be traversed sequentially.
<br>
• An iterator is the pointer used for the traversal.
<br>

<br>
Iterable:
<br>
traversable data structure
<br>
···
<br>

<br>
Iterator:
<br>
pointer for traversing iterable
<br>

<br>
returns
<br>

<br>
next()
<br>

<br>
[Symbol.iterator]()
<br>
Figure 30.2: Iteration has two main interfaces: Iterable and Iterator. The former has
<br>
a method that returns the latter.
<br>
These are type deﬁnitions (in TypeScript’s notation) for the interfaces of the iteration protocol:
<br>
interface Iterable<T> {
<br>

<br>
30.3 Iterating manually
<br>

<br>
307
<br>

<br>
[Symbol.iterator]() : Iterator<T>;
<br>
}
<br>
interface Iterator<T> {
<br>
next() : IteratorResult<T>;
<br>
}
<br>
interface IteratorResult<T> {
<br>
value: T;
<br>
done: boolean;
<br>
}
<br>

<br>
The interfaces are used as follows:
<br>
• You ask an Iterable for an iterator via the method whose key is Symbol.iterator.
<br>
• The Iterator returns the iterated values via its method .next().
<br>
• The values are not returned directly, but wrapped in objects with two properties:
<br>
– .value is the iterated value.
<br>
– .done indicates if the end of the iteration has been reached yet. It is true after
<br>
the last iterated value and false beforehand.
<br>

<br>
30.3 Iterating manually
<br>
This is an example of using the iteration protocol:
<br>
const iterable = ['a', 'b'];
<br>
// The iterable is a factory for iterators:
<br>
const iterator = iterable[Symbol.iterator]();
<br>
// Call .next() until .done is true:
<br>
assert.deepEqual(
<br>
iterator.next(), { value: 'a', done: false });
<br>
assert.deepEqual(
<br>
iterator.next(), { value: 'b', done: false });
<br>
assert.deepEqual(
<br>
iterator.next(), { value: undefined, done: true });
<br>

<br>
30.3.1 Iterating over an iterable via while
<br>
The following code demonstrates how to use a while loop to iterate over an iterable:
<br>
function logAll(iterable) {
<br>
const iterator = iterable[Symbol.iterator]();
<br>
while (true) {
<br>
const {value, done} = iterator.next();
<br>
if (done) break;
<br>
console.log(value);
<br>
}
<br>

<br>
308
<br>

<br>
30 Synchronous iteration
<br>

<br>
}
<br>
logAll(['a', 'b']);
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
Exercise: Using sync iteration manually
<br>
exercises/sync-iteration-use/sync_iteration_manually_exrc.mjs
<br>

<br>
30.4 Iteration in practice
<br>
We have seen how to use the iteration protocol manually, and it is relatively cumbersome.
<br>
But the protocol is not meant to be used directly – it is meant to be used via higher-level
<br>
language constructs built on top of it. This section shows what that looks like.
<br>

<br>
30.4.1 Iterating over Arrays
<br>
JavaScript’s Arrays are iterable. That enables us to use the for-of loop:
<br>
const myArray = ['a', 'b', 'c'];
<br>
for (const x of myArray) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>
// 'c'
<br>

<br>
Destructuring via Array patterns (explained later) also uses iteration under the hood:
<br>
const [first, second] = myArray;
<br>
assert.equal(first, 'a');
<br>
assert.equal(second, 'b');
<br>

<br>
30.4.2 Iterating over Sets
<br>
JavaScript’s Set data structure is iterable. That means for-of works:
<br>
const mySet = new Set().add('a').add('b').add('c');
<br>
for (const x of mySet) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>

<br>
30.5 Quick reference: synchronous iteration
<br>

<br>
309
<br>

<br>
// 'b'
<br>
// 'c'
<br>

<br>
As does Array-destructuring:
<br>
const [first, second] = mySet;
<br>
assert.equal(first, 'a');
<br>
assert.equal(second, 'b');
<br>

<br>
30.5 Quick reference: synchronous iteration
<br>
30.5.1 Iterable data sources
<br>
The following built-in data sources are iterable:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Arrays
<br>
Strings
<br>
Maps
<br>
Sets
<br>
(Browsers: DOM data structures)
<br>

<br>
To iterate over the properties of objects, you need helpers such as Object.keys() and
<br>
Object.entries(). That is necessary because properties exist at a different level that is
<br>
independent of the level of data structures.
<br>

<br>
30.5.2 Iterating constructs
<br>
The following constructs are based on iteration:
<br>
• Destructuring via an Array pattern:
<br>
const [x,y] = iterable;
<br>

<br>
• The for-of loop:
<br>
for (const x of iterable) { /*···*/ }
<br>

<br>
• Array.from():
<br>
const arr = Array.from(iterable);
<br>

<br>
• Spreading (via ...) into function calls and Array literals:
<br>
func(...iterable);
<br>
const arr = [...iterable];
<br>

<br>
• new Map() and new Set():
<br>
const m = new Map(iterableOverKeyValuePairs);
<br>
const s = new Set(iterableOverElements);
<br>

<br>
• Promise.all() and Promise.race():
<br>
const promise1 = Promise.all(iterableOverPromises);
<br>
const promise2 = Promise.race(iterableOverPromises);
<br>

<br>
310
<br>

<br>
30 Synchronous iteration
<br>

<br>
• yield*:
<br>
function* generatorFunction() {
<br>
yield* iterable;
<br>
}
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 31
<br>

<br>
Arrays (Array)
<br>
Contents
<br>
31.1 The two roles of Arrays in JavaScript . . . . . . . . . . . . . . . . . . 312
<br>
31.2 Basic Array operations . . . . . . . . . . . . . . . . . . . . . . . . . . 312
<br>
31.2.1 Creating, reading, writing Arrays . . . . . . . . . . . . . . . . 312
<br>
31.2.2 The .length of an Array . . . . . . . . . . . . . . . . . . . . . 313
<br>
31.2.3 Clearing an Array . . . . . . . . . . . . . . . . . . . . . . . . . 313
<br>
31.2.4 Spreading into Array literals . . . . . . . . . . . . . . . . . . . 314
<br>
31.2.5 Arrays: listing indices and entries . . . . . . . . . . . . . . . . 314
<br>
31.2.6 Is a value an Array? . . . . . . . . . . . . . . . . . . . . . . . . 315
<br>
31.3 for-of and Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
<br>
31.3.1 for-of: iterating over elements . . . . . . . . . . . . . . . . . 315
<br>
31.3.2 for-of: iterating over [index, element] pairs . . . . . . . . . . 316
<br>
31.4 Array-like objects
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
<br>

<br>
31.5 Converting iterable and Array-like values to Arrays . . . . . . . . . 317
<br>
31.5.1 Converting iterables to Arrays via spreading (...) . . . . . . . 317
<br>
31.5.2 Converting iterables and Array-like objects to Arrays via Array.from() (advanced) . . . . . . . . . . . . . . . . . . . . . . 317
<br>
31.6 Creating and ﬁlling Arrays with arbitrary lengths
<br>

<br>
. . . . . . . . . . 318
<br>

<br>
31.6.1 Do you need to create an empty Array that you’ll ﬁll completely
<br>
later on? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
<br>
31.6.2 Do you need to create an Array ﬁlled with a primitive value? . 318
<br>
31.6.3 Do you need to create an Array ﬁlled with objects? . . . . . . . 319
<br>
31.6.4 Do you need to create a range of integers?
<br>

<br>
. . . . . . . . . . . 319
<br>

<br>
31.6.5 Use a Typed Array if the elements are all integers or all ﬂoats . 319
<br>
31.7 Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . 319
<br>
31.8 More Array features (advanced) . . . . . . . . . . . . . . . . . . . . . 320
<br>
31.8.1 Array indices are (slightly special) property keys . . . . . . . . 320
<br>
31.8.2 Arrays are dictionaries and can have holes . . . . . . . . . . . 321
<br>
31.9 Adding and removing elements (destructively and non-destructively) 323
<br>

<br>
311
<br>

<br>
312
<br>

<br>
31 Arrays (Array)
<br>
31.9.1 Prepending elements and Arrays . . . . . . . . . . . . . . . . 323
<br>
31.9.2 Appending elements and Arrays
<br>

<br>
. . . . . . . . . . . . . . . . 324
<br>

<br>
31.9.3 Removing elements . . . . . . . . . . . . . . . . . . . . . . . . 324
<br>
31.10Methods: iteration and transformation (.find(), .map(), .filter(),
<br>
etc.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
<br>
31.10.1 Callbacks for iteration and transformation methods . . . . . . 325
<br>
31.10.2 Searching elements: .find(), .findIndex() . . . . . . . . . . 326
<br>
31.10.3 .map(): copy while giving elements new values . . . . . . . . 326
<br>
31.10.4 .flatMap(): mapping to zero or more values . . . . . . . . . . 327
<br>
31.10.5 .filter(): only keep some of the elements . . . . . . . . . . . 329
<br>
31.10.6 .reduce(): deriving a value from an Array (advanced) . . . . 329
<br>
31.11 .sort(): sorting Arrays . . . . . . . . . . . . . . . . . . . . . . . . . 332
<br>
31.11.1 Customizing the sort order . . . . . . . . . . . . . . . . . . . . 333
<br>
31.11.2 Sorting numbers
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . 333
<br>

<br>
31.11.3 Sorting objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
<br>
31.12Quick reference: Array<T> . . . . . . . . . . . . . . . . . . . . . . . . 334
<br>
31.12.1 new Array() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
<br>
31.12.2 Static methods of Array . . . . . . . . . . . . . . . . . . . . . . 334
<br>
31.12.3 Methods of Array<T>.prototype . . . . . . . . . . . . . . . . 335
<br>
31.12.4 Sources
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
<br>

<br>
31.1 The two roles of Arrays in JavaScript
<br>
Arrays play two roles in JavaScript:
<br>
• Tuples: Arrays-as-tuples have a ﬁxed number of indexed elements. Each of those
<br>
elements can have a different type.
<br>
• Sequences: Arrays-as-sequences have a variable number of indexed elements.
<br>
Each of those elements has the same type.
<br>
In practice, these two roles are often mixed.
<br>
Notably, Arrays-as-sequences are so ﬂexible that you can use them as (traditional) arrays,
<br>
stacks, and queues (see exercise later in this chapter).
<br>

<br>
31.2 Basic Array operations
<br>
31.2.1 Creating, reading, writing Arrays
<br>
The best way to create an Array is via an Array literal:
<br>
const arr = ['a', 'b', 'c'];
<br>

<br>
The Array literal starts and ends with square brackets []. It creates an Array with three
<br>
elements: 'a', 'b', and 'c'.
<br>
To read an Array element, you put an index in square brackets (indices start at zero):
<br>
assert.equal(arr[0], 'a');
<br>

<br>
31.2 Basic Array operations
<br>

<br>
313
<br>

<br>
To change an Array element, you assign to an Array with an index:
<br>
arr[0] = 'x';
<br>
assert.deepEqual(arr, ['x', 'b', 'c']);
<br>

<br>
The range of Array indices is 32 bits (excluding the maximum length): [0, 232 −1)
<br>

<br>
31.2.2 The .length of an Array
<br>
Every Array has a property .length that can be used to both read and change(!) the
<br>
number of elements in an Array.
<br>
The length of an Array is always the highest index plus one:
<br>
> const arr = ['a', 'b'];
<br>
> arr.length
<br>
2
<br>

<br>
If you write to the Array at the index of the length, you append an element:
<br>
> arr[arr.length] = 'c';
<br>
> arr
<br>
[ 'a', 'b', 'c' ]
<br>
> arr.length
<br>
3
<br>

<br>
Another way of (destructively) appending an element is via the Array method .push():
<br>
> arr.push('d');
<br>
> arr
<br>
[ 'a', 'b', 'c', 'd' ]
<br>

<br>
If you set .length, you are pruning the Array by removing elements:
<br>
> arr.length = 1;
<br>
> arr
<br>
[ 'a' ]
<br>

<br>
31.2.3 Clearing an Array
<br>
To clear (empty) an Array, you can either set its .length to zero:
<br>
const arr = ['a', 'b', 'c'];
<br>
arr.length = 0;
<br>
assert.deepEqual(arr, []);
<br>

<br>
or you can assign a new empty Array to the variable storing the Array:
<br>
let arr = ['a', 'b', 'c'];
<br>
arr = [];
<br>
assert.deepEqual(arr, []);
<br>

<br>
The latter approach has the advantage of not affecting other locations that point to the
<br>
same Array. If, however, you do want to reset a shared Array for everyone, then you
<br>
need the former approach.
<br>

<br>
314
<br>

<br>
31 Arrays (Array)
<br>

<br>
Exercise: Removing empty lines via .push()
<br>
exercises/arrays/remove_empty_lines_push_test.mjs
<br>

<br>
31.2.4 Spreading into Array literals
<br>
Inside an Array literal, a spread element consists of three dots (...) followed by an expression. It results in the expression being evaluated and then iterated over. Each iterated
<br>
value becomes an additional Array element – for example:
<br>
> const iterable = ['b', 'c'];
<br>
> ['a', ...iterable, 'd']
<br>
[ 'a', 'b', 'c', 'd' ]
<br>

<br>
That means that we can use spreading to create a copy of an Array:
<br>
const original = ['a', 'b', 'c'];
<br>
const copy = [...original];
<br>

<br>
Spreading is also convenient for concatenating Arrays (and other iterables) into Arrays:
<br>
const arr1 = ['a', 'b'];
<br>
const arr2 = ['c', 'd'];
<br>
const concatenated = [...arr1, ...arr2, 'e'];
<br>
assert.deepEqual(
<br>
concatenated,
<br>
['a', 'b', 'c', 'd', 'e']);
<br>

<br>
Due to spreading using iteration, it only works if the value is iterable:
<br>
> [...'abc'] // strings are iterable
<br>
[ 'a', 'b', 'c' ]
<br>
> [...123]
<br>
TypeError: number 123 is not iterable
<br>
> [...undefined]
<br>
TypeError: undefined is not iterable
<br>

<br>
Spreading into Array literals is shallow
<br>
Similar to spreading into object literals, spreading into Array literals creates shallow
<br>
copies. That is, nested Arrays are not copied.
<br>

<br>
31.2.5 Arrays: listing indices and entries
<br>
Method .keys() lists the indices of an Array:
<br>
const arr = ['a', 'b'];
<br>
assert.deepEqual(
<br>

<br>
31.3 for-of and Arrays
<br>

<br>
315
<br>

<br>
[...arr.keys()], // (A)
<br>
[0, 1]);
<br>
.keys() returns an iterable. In line A, we spread to obtain an Array.
<br>

<br>
Listing Array indices is different from listing properties. The former produces numbers;
<br>
the latter produces stringiﬁed numbers (in addition to non-index property keys):
<br>
const arr = ['a', 'b'];
<br>
arr.prop = true;
<br>
assert.deepEqual(
<br>
Object.keys(arr),
<br>
['0', '1', 'prop']);
<br>

<br>
Method .entries() lists the contents of an Array as [index, element] pairs:
<br>
const arr = ['a', 'b'];
<br>
assert.deepEqual(
<br>
[...arr.entries()],
<br>
[[0, 'a'], [1, 'b']]);
<br>

<br>
31.2.6 Is a value an Array?
<br>
Following are two ways of checking if a value is an Array:
<br>
> [] instanceof Array
<br>
true
<br>
> Array.isArray([])
<br>
true
<br>
instanceof is usually ﬁne. You need Array.isArray() if a value may come from another
<br>
realm. Roughly, a realm is an instance of JavaScript’s global scope. Some realms are isolated from each other (e.g., Web Workers in browsers), but there are also realms between
<br>
which you can move data – for example, same-origin iframes in browsers. x instanceof
<br>
Array checks the prototype chain of x and therefore returns false if x is an Array from
<br>
another realm.
<br>
typeof categorizes Arrays as objects:
<br>
> typeof []
<br>
'object'
<br>

<br>
31.3
<br>

<br>
for-of and Arrays
<br>

<br>
We have already encountered the for-of loop. This section brieﬂy recaps how to use it
<br>
for Arrays.
<br>

<br>
31.3.1
<br>

<br>
for-of: iterating over elements
<br>

<br>
The following for-of loop iterates over the elements of an Array.
<br>

<br>
316
<br>

<br>
31 Arrays (Array)
<br>

<br>
for (const element of ['a', 'b']) {
<br>
console.log(element);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
31.3.2
<br>

<br>
for-of: iterating over [index, element] pairs
<br>

<br>
The following for-of loop iterates over [index, element] pairs. Destructuring (described
<br>
later), gives us convenient syntax for setting up index and element in the head of for-of.
<br>
for (const [index, element] of ['a', 'b'].entries()) {
<br>
console.log(index, element);
<br>
}
<br>
// Output:
<br>
// 0, 'a'
<br>
// 1, 'b'
<br>

<br>
31.4 Array-like objects
<br>
Some operations that work with Arrays require only the bare minimum: values must
<br>
only be Array-like. An Array-like value is an object with the following properties:
<br>
• .length: holds the length of the Array-like object.
<br>
• [0]: holds the element at index 0 (etc.). Note that if you use numbers as property
<br>
names, they are always coerced to strings. Therefore, [0] retrieves the value of the
<br>
property whose key is '0'.
<br>
For example, Array.from() accepts Array-like objects and converts them to Arrays:
<br>
// If you omit .length, it is interpreted as 0
<br>
assert.deepEqual(
<br>
Array.from({}),
<br>
[]);
<br>
assert.deepEqual(
<br>
Array.from({length:2, 0:'a', 1:'b'}),
<br>
[ 'a', 'b' ]);
<br>

<br>
The TypeScript interface for Array-like objects is:
<br>
interface ArrayLike<T> {
<br>
length: number;
<br>
[n: number]: T;
<br>
}
<br>

<br>
Array-like objects are relatively rare in modern JavaScript
<br>

<br>
31.5 Converting iterable and Array-like values to Arrays
<br>

<br>
317
<br>

<br>
Array-like objects used to be common before ES6; now you don’t see them very
<br>
often.
<br>

<br>
31.5 Converting iterable and Array-like values to Arrays
<br>
There are two common ways of converting iterable and Array-like values to Arrays:
<br>
spreading and Array.from().
<br>

<br>
31.5.1 Converting iterables to Arrays via spreading (...)
<br>
Inside an Array literal, spreading via ... converts any iterable object into a series of
<br>
Array elements. For example:
<br>
// Get an Array-like collection from a web browser’s DOM
<br>
const domCollection = document.querySelectorAll('a');
<br>
// Alas, the collection is missing many Array methods
<br>
assert.equal('map' in domCollection, false);
<br>
// Solution: convert it to an Array
<br>
const arr = [...domCollection];
<br>
assert.deepEqual(
<br>
arr.map(x => x.href),
<br>
['https://2ality.com', 'https://exploringjs.com']);
<br>

<br>
The conversion works because the DOM collection is iterable.
<br>

<br>
31.5.2 Converting iterables and Array-like objects to Arrays via Array.from() (advanced)
<br>
Array.from() can be used in two modes.
<br>

<br>
31.5.2.1 Mode 1 of Array.from(): converting
<br>
The ﬁrst mode has the following type signature:
<br>
.from<T>(iterable: Iterable<T> | ArrayLike<T>): T[]
<br>

<br>
Interface Iterable is shown in the chapter on synchronous iteration. Interface ArrayLike
<br>
appeared earlier in this chapter.
<br>
With a single parameter, Array.from() converts anything iterable or Array-like to an
<br>
Array:
<br>
> Array.from(new Set(['a', 'b']))
<br>
[ 'a', 'b' ]
<br>
> Array.from({length: 2, 0:'a', 1:'b'})
<br>
[ 'a', 'b' ]
<br>

<br>
318
<br>

<br>
31 Arrays (Array)
<br>

<br>
31.5.2.2 Mode 2 of Array.from(): converting and mapping
<br>
The second mode of Array.from() involves two parameters:
<br>
.from<T, U>(
<br>
iterable: Iterable<T> | ArrayLike<T>,
<br>
mapFunc: (v: T, i: number) => U,
<br>
thisArg?: any)
<br>
: U[]
<br>

<br>
In this mode, Array.from() does several things:
<br>
• It iterates over iterable.
<br>
• It calls mapFunc with each iterated value. The optional parameter thisArg speciﬁes
<br>
a this for mapFunc.
<br>
• It applies mapFunc to each iterated value.
<br>
• It collects the results in a new Array and returns it.
<br>
In other words: we are going from an iterable with elements of type T to an Array with
<br>
elements of type U.
<br>
This is an example:
<br>
> Array.from(new Set(['a', 'b']), x => x + x)
<br>
[ 'aa', 'bb' ]
<br>

<br>
31.6 Creating and ﬁlling Arrays with arbitrary lengths
<br>
The best way of creating an Array is via an Array literal. However, you can’t always use
<br>
one: The Array may be too large, you may not know its length during development, or
<br>
you may want to keep its length ﬂexible. Then I recommend the following techniques
<br>
for creating, and possibly ﬁlling, Arrays.
<br>

<br>
31.6.1 Do you need to create an empty Array that you’ll ﬁll completely
<br>
later on?
<br>
> new Array(3)
<br>
[ , , ,]
<br>

<br>
Note that the result has three holes (empty slots) – the last comma in an Array literal is
<br>
always ignored.
<br>

<br>
31.6.2 Do you need to create an Array ﬁlled with a primitive value?
<br>
> new Array(3).fill(0)
<br>
[0, 0, 0]
<br>

<br>
Caveat: If you use .fill() with an object, then each Array element will refer to this
<br>
object (sharing it).
<br>
const arr = new Array(3).fill({});
<br>
arr[0].prop = true;
<br>

<br>
31.7 Multidimensional Arrays
<br>

<br>
319
<br>

<br>
assert.deepEqual(
<br>
arr, [
<br>
{prop: true},
<br>
{prop: true},
<br>
{prop: true},
<br>
]);
<br>

<br>
The next subsection explains how to ﬁx this.
<br>

<br>
31.6.3 Do you need to create an Array ﬁlled with objects?
<br>
> Array.from({length: 3}, () => ({}))
<br>
[{}, {}, {}]
<br>

<br>
31.6.4 Do you need to create a range of integers?
<br>
function createRange(start, end) {
<br>
return Array.from({length: end-start}, (_, i) => i+start);
<br>
}
<br>
assert.deepEqual(
<br>
createRange(2, 5),
<br>
[2, 3, 4]);
<br>

<br>
Here is an alternative, slightly hacky technique for creating integer ranges that start at
<br>
zero:
<br>
/** Returns an iterable */
<br>
function createRange(end) {
<br>
return new Array(end).keys();
<br>
}
<br>
assert.deepEqual(
<br>
[...createRange(4)],
<br>
[0, 1, 2, 3]);
<br>

<br>
This works because .keys() treats holes like undefined elements and lists their indices.
<br>

<br>
31.6.5 Use a Typed Array if the elements are all integers or all ﬂoats
<br>
If you are dealing with Arrays of integers or ﬂoats, consider Typed Arrays, which were
<br>
created for this purpose.
<br>

<br>
31.7 Multidimensional Arrays
<br>
JavaScript does not have real multidimensional Arrays; you need to resort to Arrays
<br>
whose elements are Arrays:
<br>
function initMultiArray(...dimensions) {
<br>
function initMultiArrayRec(dimIndex) {
<br>
if (dimIndex >= dimensions.length) {
<br>
return 0;
<br>

<br>
320
<br>

<br>
31 Arrays (Array)
<br>
} else {
<br>
const dim = dimensions[dimIndex];
<br>
const arr = [];
<br>
for (let i=0; i<dim; i++) {
<br>
arr.push(initMultiArrayRec(dimIndex+1));
<br>
}
<br>
return arr;
<br>
}
<br>
}
<br>
return initMultiArrayRec(0);
<br>

<br>
}
<br>
const arr = initMultiArray(4, 3, 2);
<br>
arr[3][2][1] = 'X'; // last in each dimension
<br>
assert.deepEqual(arr, [
<br>
[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
<br>
[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
<br>
[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
<br>
[ [ 0, 0 ], [ 0, 0 ], [ 0, 'X' ] ],
<br>
]);
<br>

<br>
31.8 More Array features (advanced)
<br>
In this section, we look at phenomena you don’t encounter often when working with
<br>
Arrays.
<br>

<br>
31.8.1 Array indices are (slightly special) property keys
<br>
You’d think that Array elements are special because you are accessing them via numbers.
<br>
But the square brackets operator [] for doing so is the same operator that is used for
<br>
accessing properties. It coerces any value (that is not a symbol) to a string. Therefore,
<br>
Array elements are (almost) normal properties (line A) and it doesn’t matter if you use
<br>
numbers or strings as indices (lines B and C):
<br>
const arr = ['a', 'b'];
<br>
arr.prop = 123;
<br>
assert.deepEqual(
<br>
Object.keys(arr),
<br>
['0', '1', 'prop']); // (A)
<br>
assert.equal(arr[0], 'a');
<br>

<br>
// (B)
<br>

<br>
assert.equal(arr['0'], 'a'); // (C)
<br>

<br>
To make matters even more confusing, this is only how the language speciﬁcation deﬁnes
<br>
things (the theory of JavaScript, if you will). Most JavaScript engines optimize under the
<br>
hood and do use actual integers to access Array elements (the practice of JavaScript, if
<br>
you will).
<br>
Property keys (strings!) that are used for Array elements are called indices. A string str
<br>

<br>
31.8 More Array features (advanced)
<br>

<br>
321
<br>

<br>
is an index if converting it to a 32-bit unsigned integer and back results in the original
<br>
value. Written as a formula:
<br>
ToString(ToUint32(str)) === str
<br>

<br>
31.8.1.1 Listing indices
<br>
When listing property keys, indices are treated specially – they always come ﬁrst and are
<br>
sorted like numbers ('2' comes before '10'):
<br>
const arr = [];
<br>
arr.prop = true;
<br>
arr[1] = 'b';
<br>
arr[0] = 'a';
<br>
assert.deepEqual(
<br>
Object.keys(arr),
<br>
['0', '1', 'prop']);
<br>

<br>
Note that .length, .entries() and .keys() treat Array indices as numbers and ignore
<br>
non-index properties:
<br>
assert.equal(arr.length, 2);
<br>
assert.deepEqual(
<br>
[...arr.keys()], [0, 1]);
<br>
assert.deepEqual(
<br>
[...arr.entries()], [[0, 'a'], [1, 'b']]);
<br>

<br>
We used a spread element (...) to convert the iterables returned by .keys() and .entries() to Arrays.
<br>

<br>
31.8.2 Arrays are dictionaries and can have holes
<br>
We distinguish two kinds of Arrays in JavaScript:
<br>
• An Array arr is dense if all indices i, with 0 ≤ i < arr.length, exist. That is, the
<br>
indices form a contiguous range.
<br>
• An Array is sparse if the range of indices has holes in it. That is, some indices are
<br>
missing.
<br>
Arrays can be sparse in JavaScript because Arrays are actually dictionaries from indices
<br>
to values.
<br>

<br>
Recommendation: avoid holes
<br>
So far, we have only seen dense Arrays and it’s indeed recommended to avoid holes:
<br>
They make your code more complicated and are not handled consistently by Array
<br>
methods. Additionally, JavaScript engines optimize dense Arrays, making them
<br>
faster.
<br>

<br>
322
<br>

<br>
31 Arrays (Array)
<br>

<br>
31.8.2.1 Creating holes
<br>
You can create holes by skipping indices when assigning elements:
<br>
const arr = [];
<br>
arr[0] = 'a';
<br>
arr[2] = 'c';
<br>
assert.deepEqual(Object.keys(arr), ['0', '2']); // (A)
<br>
assert.equal(0 in arr, true); // element
<br>
assert.equal(1 in arr, false); // hole
<br>

<br>
In line A, we are using Object.keys() because arr.keys() treats holes as if they were
<br>
undefined elements and does not reveal them.
<br>
Another way of creating holes is to skip elements in Array literals:
<br>
const arr = ['a', , 'c'];
<br>
assert.deepEqual(Object.keys(arr), ['0', '2']);
<br>

<br>
You can also delete Array elements:
<br>
const arr = ['a', 'b', 'c'];
<br>
assert.deepEqual(Object.keys(arr), ['0', '1', '2']);
<br>
delete arr[1];
<br>
assert.deepEqual(Object.keys(arr), ['0', '2']);
<br>

<br>
31.8.2.2 How do Array operations treat holes?
<br>
Alas, there are many different ways in which Array operations treat holes.
<br>
Some Array operations remove holes:
<br>
> ['a',,'b'].filter(x => true)
<br>
[ 'a', 'b' ]
<br>

<br>
Some Array operations ignore holes:
<br>
> ['a', ,'a'].every(x => x === 'a')
<br>
true
<br>

<br>
Some Array operations ignore but preserve holes:
<br>
> ['a',,'b'].map(x => 'c')
<br>
[ 'c', , 'c' ]
<br>

<br>
Some Array operations treat holes as undefined elements:
<br>
> Array.from(['a',,'b'], x => x)
<br>
[ 'a', undefined, 'b' ]
<br>
> [...['a',,'b'].entries()]
<br>
[[0, 'a'], [1, undefined], [2, 'b']]
<br>

<br>
31.9 Adding and removing elements (destructively and non-destructively)
<br>

<br>
323
<br>

<br>
Object.keys() works differently than .keys() (strings vs. numbers, holes don’t have
<br>

<br>
keys):
<br>
> [...['a',,'b'].keys()]
<br>
[ 0, 1, 2 ]
<br>
> Object.keys(['a',,'b'])
<br>
[ '0', '2' ]
<br>

<br>
There is no rule to remember here. If it ever matters how an Array operation treats holes,
<br>
the best approach is to do a quick test in a console.
<br>

<br>
31.9 Adding and removing elements (destructively and
<br>
non-destructively)
<br>
JavaScript’s Array is quite ﬂexible and more like a combination of array, stack, and queue.
<br>
This section explores ways of adding and removing Array elements. Most operations can
<br>
be performed both destructively (modifying the Array) and non-destructively (producing a
<br>
modiﬁed copy).
<br>

<br>
31.9.1 Prepending elements and Arrays
<br>
In the following code, we destructively prepend single elements to arr1 and an Array to
<br>
arr2:
<br>
const arr1 = ['a', 'b'];
<br>
arr1.unshift('x', 'y'); // prepend single elements
<br>
assert.deepEqual(arr1, ['x', 'y', 'a', 'b']);
<br>
const arr2 = ['a', 'b'];
<br>
arr2.unshift(...['x', 'y']); // prepend Array
<br>
assert.deepEqual(arr2, ['x', 'y', 'a', 'b']);
<br>

<br>
Spreading lets us unshift an Array into arr2.
<br>
Non-destructive prepending is done via spread elements:
<br>
const arr1 = ['a', 'b'];
<br>
assert.deepEqual(
<br>
['x', 'y', ...arr1], // prepend single elements
<br>
['x', 'y', 'a', 'b']);
<br>
assert.deepEqual(arr1, ['a', 'b']); // unchanged!
<br>
const arr2 = ['a', 'b'];
<br>
assert.deepEqual(
<br>
[...['x', 'y'], ...arr2], // prepend Array
<br>
['x', 'y', 'a', 'b']);
<br>
assert.deepEqual(arr2, ['a', 'b']); // unchanged!
<br>

<br>
324
<br>

<br>
31 Arrays (Array)
<br>

<br>
31.9.2 Appending elements and Arrays
<br>
In the following code, we destructively append single elements to arr1 and an Array to
<br>
arr2:
<br>
const arr1 = ['a', 'b'];
<br>
arr1.push('x', 'y'); // append single elements
<br>
assert.deepEqual(arr1, ['a', 'b', 'x', 'y']);
<br>
const arr2 = ['a', 'b'];
<br>
arr2.push(...['x', 'y']); // append Array
<br>
assert.deepEqual(arr2, ['a', 'b', 'x', 'y']);
<br>

<br>
Spreading lets us push an Array into arr2.
<br>
Non-destructive appending is done via spread elements:
<br>
const arr1 = ['a', 'b'];
<br>
assert.deepEqual(
<br>
[...arr1, 'x', 'y'], // append single elements
<br>
['a', 'b', 'x', 'y']);
<br>
assert.deepEqual(arr1, ['a', 'b']); // unchanged!
<br>
const arr2 = ['a', 'b'];
<br>
assert.deepEqual(
<br>
[...arr2, ...['x', 'y']], // append Array
<br>
['a', 'b', 'x', 'y']);
<br>
assert.deepEqual(arr2, ['a', 'b']); // unchanged!
<br>

<br>
31.9.3 Removing elements
<br>
These are three destructive ways of removing Array elements:
<br>
// Destructively remove first element:
<br>
const arr1 = ['a', 'b', 'c'];
<br>
assert.equal(arr1.shift(), 'a');
<br>
assert.deepEqual(arr1, ['b', 'c']);
<br>
// Destructively remove last element:
<br>
const arr2 = ['a', 'b', 'c'];
<br>
assert.equal(arr2.pop(), 'c');
<br>
assert.deepEqual(arr2, ['a', 'b']);
<br>
// Remove one or more elements anywhere:
<br>
const arr3 = ['a', 'b', 'c', 'd'];
<br>
assert.deepEqual(arr3.splice(1, 2), ['b', 'c']);
<br>
assert.deepEqual(arr3, ['a', 'd']);
<br>
.splice() is covered in more detail in the quick reference at the end of this chapter.
<br>

<br>
Destructuring via a rest element lets you non-destructively remove elements from the
<br>
beginning of an Array (destructuring is covered later).
<br>

<br>
31.10 Methods: iteration and transformation (.find(), .map(), .filter(), etc.)
<br>

<br>
325
<br>

<br>
const arr1 = ['a', 'b', 'c'];
<br>
// Ignore first element, extract remaining elements
<br>
const [, ...arr2] = arr1;
<br>
assert.deepEqual(arr2, ['b', 'c']);
<br>
assert.deepEqual(arr1, ['a', 'b', 'c']); // unchanged!
<br>

<br>
Alas, a rest element must come last in an Array. Therefore, you can only use it to extract
<br>
sufﬁxes.
<br>

<br>
Exercise: Implementing a queue via an Array
<br>
exercises/arrays/queue_via_array_test.mjs
<br>

<br>
31.10 Methods: iteration and transformation (.find(),
<br>
.map(), .filter(), etc.)
<br>
In this section, we take a look at Array methods for iterating over Arrays and for transforming Arrays.
<br>

<br>
31.10.1 Callbacks for iteration and transformation methods
<br>
All iteration and transformation methods use callbacks. The former feed all iterated values to their callbacks; the latter ask their callbacks how to transform Arrays.
<br>
These callbacks have type signatures that look as follows:
<br>
callback: (value: T, index: number, array: Array<T>) => boolean
<br>

<br>
That is, the callback gets three parameters (it is free to ignore any of them):
<br>
• value is the most important one. This parameter holds the iterated value that is
<br>
currently being processed.
<br>
• index can additionally tell the callback what the index of the iterated value is.
<br>
• array points to the current Array (the receiver of the method call). Some algorithms need to refer to the whole Array – e.g., to search it for answers. This parameter lets you write reusable callbacks for such algorithms.
<br>
What the callback is expected to return depends on the method it is passed to. Possibilities
<br>
include:
<br>
• .map() ﬁlls its result with the values returned by its callback:
<br>
> ['a', 'b', 'c'].map(x => x + x)
<br>
[ 'aa', 'bb', 'cc' ]
<br>

<br>
• .find() returns the ﬁrst Array element for which its callback returns true:
<br>
> ['a', 'bb', 'ccc'].find(str => str.length >= 2)
<br>
'bb'
<br>

<br>
Both of these methods are described in more detail later.
<br>

<br>
326
<br>

<br>
31 Arrays (Array)
<br>

<br>
31.10.2 Searching elements: .find(), .findIndex()
<br>
.find() returns the ﬁrst element for which its callback returns a truthy value (and undefined if it can’t ﬁnd anything):
<br>
> [6, -5, 8].find(x => x < 0)
<br>
-5
<br>
> [6, 5, 8].find(x => x < 0)
<br>
undefined
<br>
.findIndex() returns the index of the ﬁrst element for which its callback returns a truthy
<br>
value (and -1 if it can’t ﬁnd anything):
<br>
> [6, -5, 8].findIndex(x => x < 0)
<br>
1
<br>
> [6, 5, 8].findIndex(x => x < 0)
<br>
-1
<br>
.findIndex() can be implemented as follows:
<br>
function findIndex(arr, callback) {
<br>
for (const [i, x] of arr.entries()) {
<br>
if (callback(x, i, arr)) {
<br>
return i;
<br>
}
<br>
}
<br>
return -1;
<br>
}
<br>

<br>
31.10.3
<br>

<br>
.map(): copy while giving elements new values
<br>

<br>
.map() returns a modiﬁed copy of the receiver. The elements of the copy are the results
<br>

<br>
of applying map’s callback to the elements of the receiver.
<br>
All of this is easier to understand via examples:
<br>
> [1, 2, 3].map(x => x * 3)
<br>
[ 3, 6, 9 ]
<br>
> ['how', 'are', 'you'].map(str => str.toUpperCase())
<br>
[ 'HOW', 'ARE', 'YOU' ]
<br>
> [true, true, true].map((_x, index) => index)
<br>
[ 0, 1, 2 ]
<br>
.map() can be implemented as follows:
<br>
function map(arr, mapFunc) {
<br>
const result = [];
<br>
for (const [i, x] of arr.entries()) {
<br>
result.push(mapFunc(x, i, arr));
<br>
}
<br>
return result;
<br>
}
<br>

<br>
31.10 Methods: iteration and transformation (.find(), .map(), .filter(), etc.)
<br>

<br>
327
<br>

<br>
Exercise: Numbering lines via .map()
<br>
exercises/arrays/number_lines_test.mjs
<br>

<br>
31.10.4 .flatMap(): mapping to zero or more values
<br>
The type signature of Array<T>.prototype.flatMap() is:
<br>
.flatMap<U>(
<br>
callback: (value: T, index: number, array: T[]) => U|Array<U>,
<br>
thisValue?: any
<br>
): U[]
<br>

<br>
Both .map() and .flatMap() take a function callback as a parameter that controls how
<br>
an input Array is translated to an output Array:
<br>
• With .map(), each input Array element is translated to exactly one output element.
<br>
That is, callback returns a single value.
<br>
• With .flatMap(), each input Array element is translated to zero or more output
<br>
elements. That is, callback returns an Array of values (it can also return non-Array
<br>
values, but that is rare).
<br>
This is .flatMap() in action:
<br>
> ['a', 'b', 'c'].flatMap(x => [x,x])
<br>
[ 'a', 'a', 'b', 'b', 'c', 'c' ]
<br>
> ['a', 'b', 'c'].flatMap(x => [x])
<br>
[ 'a', 'b', 'c' ]
<br>
> ['a', 'b', 'c'].flatMap(x => [])
<br>
[]
<br>

<br>
31.10.4.1 A simple implementation
<br>
You could implement .flatMap() as follows. Note: This implementation is simpler than
<br>
the built-in version, which, for example, performs more checks.
<br>
function flatMap(arr, mapFunc) {
<br>
const result = [];
<br>
for (const [index, elem] of arr.entries()) {
<br>
const x = mapFunc(elem, index, arr);
<br>
// We allow mapFunc() to return non-Arrays
<br>
if (Array.isArray(x)) {
<br>
result.push(...x);
<br>
} else {
<br>
result.push(x);
<br>
}
<br>
}
<br>
return result;
<br>
}
<br>

<br>
What is .flatMap() good for? Let’s look at use cases!
<br>

<br>
328
<br>

<br>
31 Arrays (Array)
<br>

<br>
31.10.4.2 Use case: ﬁltering and mapping at the same time
<br>
The result of the Array method .map() always has the same length as the Array it is
<br>
invoked on. That is, its callback can’t skip Array elements it isn’t interested in. The
<br>
ability of .flatMap() to do so is useful in the next example.
<br>
We will use the following function processArray() to create an Array that we’ll then
<br>
ﬁlter and map via .flatMap():
<br>
function processArray(arr, callback) {
<br>
return arr.map(x => {
<br>
try {
<br>
return { value: callback(x) };
<br>
} catch (e) {
<br>
return { error: e };
<br>
}
<br>
});
<br>
}
<br>

<br>
Next, we create an Array results via processArray():
<br>
const results = processArray([1, -5, 6], throwIfNegative);
<br>
assert.deepEqual(results, [
<br>
{ value: 1 },
<br>
{ error: new Error('Illegal value: -5') },
<br>
{ value: 6 },
<br>
]);
<br>
function throwIfNegative(value) {
<br>
if (value < 0) {
<br>
throw new Error('Illegal value: '+value);
<br>
}
<br>
return value;
<br>
}
<br>

<br>
We can now use .flatMap() to extract just the values or just the errors from results:
<br>
const values = results.flatMap(
<br>
result => result.value ? [result.value] : []);
<br>
assert.deepEqual(values, [1, 6]);
<br>
const errors = results.flatMap(
<br>
result => result.error ? [result.error] : []);
<br>
assert.deepEqual(errors, [new Error('Illegal value: -5')]);
<br>

<br>
31.10.4.3 Use case: mapping to multiple values
<br>
The Array method .map() maps each input Array element to one output element. But
<br>
what if we want to map it to multiple output elements?
<br>
That becomes necessary in the following example:
<br>

<br>
31.10 Methods: iteration and transformation (.find(), .map(), .filter(), etc.)
<br>

<br>
329
<br>

<br>
> stringsToCodePoints(['many', 'a', 'moon'])
<br>
['m', 'a', 'n', 'y', 'a', 'm', 'o', 'o', 'n']
<br>

<br>
We want to convert an Array of strings to an Array of Unicode characters (code points).
<br>
The following function achieves that via .flatMap():
<br>
function stringsToCodePoints(strs) {
<br>
return strs.flatMap(str => [...str]);
<br>
}
<br>

<br>
Exercises: .flatMap()
<br>
• exercises/arrays/convert_to_numbers_test.mjs
<br>
• exercises/arrays/replace_objects_test.mjs
<br>

<br>
31.10.5 .filter(): only keep some of the elements
<br>
The Array method .filter() returns an Array collecting all elements for which the callback returns a truthy value.
<br>
For example:
<br>
> [-1, 2, 5, -7, 6].filter(x => x >= 0)
<br>
[ 2, 5, 6 ]
<br>
> ['a', 'b', 'c', 'd'].filter((_x,i) => (i%2)===0)
<br>
[ 'a', 'c' ]
<br>
.filter() can be implemented as follows:
<br>
function filter(arr, filterFunc) {
<br>
const result = [];
<br>
for (const [i, x] of arr.entries()) {
<br>
if (filterFunc(x, i, arr)) {
<br>
result.push(x);
<br>
}
<br>
}
<br>
return result;
<br>
}
<br>

<br>
Exercise: Removing empty lines via .filter()
<br>
exercises/arrays/remove_empty_lines_filter_test.mjs
<br>

<br>
31.10.6 .reduce(): deriving a value from an Array (advanced)
<br>
Method .reduce() is a powerful tool for computing a “summary” of an Array arr. A
<br>
summary can be any kind of value:
<br>
• A number. For example, the sum of all elements of arr.
<br>

<br>
330
<br>

<br>
31 Arrays (Array)
<br>

<br>
• An Array. For example, a copy of arr, where each element is twice the original
<br>
element.
<br>
• Etc.
<br>
reduce is also known as foldl (“fold left”) in functional programming and popular there.
<br>
One caveat is that it can make code difﬁcult to understand.
<br>
.reduce() has the following type signature (inside an Array<T>):
<br>
.reduce<U>(
<br>
callback: (accumulator: U, element: T, index: number, array: T[]) => U,
<br>
init?: U)
<br>
: U
<br>
T is the type of the Array elements, U is the type of the summary. The two may or may
<br>

<br>
not be different. accumulator is just another name for “summary”.
<br>
To compute the summary of an Array arr, .reduce() feeds all Array elements to its
<br>
callback one at a time:
<br>
const accumulator_0 = callback(init, arr[0]);
<br>
const accumulator_1 = callback(accumulator_0, arr[1]);
<br>
const accumulator_2 = callback(accumulator_1, arr[2]);
<br>
// Etc.
<br>
callback combines the previously computed summary (stored in its parameter accumulator) with the current Array element and returns the next accumulator. The result
<br>

<br>
of .reduce() is the ﬁnal accumulator – the last result of callback after it has visited all
<br>
elements.
<br>
In other words: callback does most of the work; .reduce() just invokes it in a useful
<br>
manner.
<br>
You could say that the callback folds Array elements into the accumulator. That’s why
<br>
this operation is called “fold” in functional programming.
<br>
31.10.6.1 A ﬁrst example
<br>
Let’s look at an example of .reduce() in action: function addAll() computes the sum of
<br>
all numbers in an Array arr.
<br>
function addAll(arr) {
<br>
const startSum = 0;
<br>
const callback = (sum, element) => sum + element;
<br>
return arr.reduce(callback, startSum);
<br>
}
<br>
assert.equal(addAll([1,
<br>

<br>
2, 3]), 6); // (A)
<br>

<br>
assert.equal(addAll([7, -4, 2]), 5);
<br>

<br>
In this case, the accumulator holds the sum of all Array elements that callback has already visited.
<br>
How was the result 6 derived from the Array in line A? Via the following invocations of
<br>
callback:
<br>

<br>
31.10 Methods: iteration and transformation (.find(), .map(), .filter(), etc.)
<br>

<br>
331
<br>

<br>
callback(0, 1) --> 1
<br>
callback(1, 2) --> 3
<br>
callback(3, 3) --> 6
<br>

<br>
Notes:
<br>
• The ﬁrst parameters are the current accumulators (starting with parameter init of
<br>
.reduce()).
<br>
• The second parameters are the current Array elements.
<br>
• The results are the next accumulators.
<br>
• The last result of callback is also the result of .reduce().
<br>
Alternatively, we could have implemented addAll() via a for-of loop:
<br>
function addAll(arr) {
<br>
let sum = 0;
<br>
for (const element of arr) {
<br>
sum = sum + element;
<br>
}
<br>
return sum;
<br>
}
<br>

<br>
It’s hard to say which of the two implementations is “better”: the one based on .reduce()
<br>
is a little more concise, while the one based on for-of may be a little easier to understand
<br>
– especially if you are not familiar with functional programming.
<br>
31.10.6.2 Example: ﬁnding indices via .reduce()
<br>
The following function is an implementation of the Array method .indexOf(). It returns
<br>
the ﬁrst index at which the given searchValue appears inside the Array arr:
<br>
const NOT_FOUND = -1;
<br>
function indexOf(arr, searchValue) {
<br>
return arr.reduce(
<br>
(result, elem, index) => {
<br>
if (result !== NOT_FOUND) {
<br>
// We have already found something: don’t change anything
<br>
return result;
<br>
} else if (elem === searchValue) {
<br>
return index;
<br>
} else {
<br>
return NOT_FOUND;
<br>
}
<br>
},
<br>
NOT_FOUND);
<br>
}
<br>
assert.equal(indexOf(['a', 'b', 'c'], 'b'), 1);
<br>
assert.equal(indexOf(['a', 'b', 'c'], 'x'), -1);
<br>

<br>
One limitation of .reduce() is that you can’t ﬁnish early (in a for-of loop, you can break).
<br>
Here, we always immediately return the result once we have found it.
<br>

<br>
332
<br>

<br>
31 Arrays (Array)
<br>

<br>
31.10.6.3 Example: doubling Array elements
<br>
Function double(arr) returns a copy of inArr whose elements are all multiplied by 2:
<br>
function double(inArr) {
<br>
return inArr.reduce(
<br>
(outArr, element) => {
<br>
outArr.push(element * 2);
<br>
return outArr;
<br>
},
<br>
[]);
<br>
}
<br>
assert.deepEqual(
<br>
double([1, 2, 3]),
<br>
[2, 4, 6]);
<br>

<br>
We modify the initial value [] by pushing into it. A non-destructive, more functional
<br>
version of double() looks as follows:
<br>
function double(inArr) {
<br>
return inArr.reduce(
<br>
// Don’t change `outArr`, return a fresh Array
<br>
(outArr, element) => [...outArr, element * 2],
<br>
[]);
<br>
}
<br>
assert.deepEqual(
<br>
double([1, 2, 3]),
<br>
[2, 4, 6]);
<br>

<br>
This version is more elegant but also slower and uses more memory.
<br>

<br>
Exercises: .reduce()
<br>
• map() via .reduce(): exercises/arrays/map_via_reduce_test.mjs
<br>
• filter() via .reduce(): exercises/arrays/filter_via_reduce_test.mjs
<br>
• countMatches() via .reduce(): exercises/arrays/count_matches_via_
<br>
reduce_test.mjs
<br>

<br>
31.11 .sort(): sorting Arrays
<br>
.sort() has the following type deﬁnition:
<br>
sort(compareFunc?: (a: T, b: T) => number): this
<br>

<br>
By default, .sort() sorts string representations of the elements. These representations
<br>
are compared via <. This operator compares lexicographically (the ﬁrst characters are most
<br>
signiﬁcant). You can see that when sorting numbers:
<br>
> [200, 3, 10].sort()
<br>
[ 10, 200, 3 ]
<br>

<br>
31.11 .sort(): sorting Arrays
<br>

<br>
333
<br>

<br>
When sorting human-language strings, you need to be aware that they are compared
<br>
according to their code unit values (char codes):
<br>
> ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()
<br>
[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]
<br>

<br>
As you can see, all unaccented uppercase letters come before all unaccented lowercase letters, which come before all accented letters. Use Intl, the JavaScript internationalization
<br>
API, if you want proper sorting for human languages.
<br>
Note that .sort() sorts in place; it changes and returns its receiver:
<br>
> const arr = ['a', 'c', 'b'];
<br>
> arr.sort() === arr
<br>
true
<br>
> arr
<br>
[ 'a', 'b', 'c' ]
<br>

<br>
31.11.1 Customizing the sort order
<br>
You can customize the sort order via the parameter compareFunc, which must return a
<br>
number that is:
<br>
• negative if a < b
<br>
• zero if a === b
<br>
• positive if a > b
<br>

<br>
Tip for remembering these rules
<br>
A negative number is less than zero (etc.).
<br>

<br>
31.11.2 Sorting numbers
<br>
You can use this helper function to sort numbers:
<br>
function compareNumbers(a, b) {
<br>
if (a < b) {
<br>
return -1;
<br>
} else if (a === b) {
<br>
return 0;
<br>
} else {
<br>
return 1;
<br>
}
<br>
}
<br>
assert.deepEqual(
<br>
[200, 3, 10].sort(compareNumbers),
<br>
[3, 10, 200]);
<br>

<br>
The following is a quick and dirty alternative.
<br>

<br>
334
<br>

<br>
31 Arrays (Array)
<br>

<br>
> [200, 3, 10].sort((a,b) => a - b)
<br>
[ 3, 10, 200 ]
<br>

<br>
The downsides of this approach are:
<br>
• It is cryptic.
<br>
• There is a risk of numeric overﬂow or underﬂow, if a-b becomes a large positive
<br>
or negative number.
<br>

<br>
31.11.3 Sorting objects
<br>
You also need to use a compare function if you want to sort objects. As an example, the
<br>
following code shows how to sort objects by age.
<br>
const arr = [ {age: 200}, {age: 3}, {age: 10} ];
<br>
assert.deepEqual(
<br>
arr.sort((obj1, obj2) => obj1.age - obj2.age),
<br>
[{ age: 3 }, { age: 10 }, { age: 200 }] );
<br>

<br>
Exercise: Sorting objects by name
<br>
exercises/arrays/sort_objects_test.mjs
<br>

<br>
31.12 Quick reference: Array<T>
<br>
Legend:
<br>
• R: method does not change the Array (non-destructive).
<br>
• W: method changes the Array (destructive).
<br>

<br>
31.12.1
<br>

<br>
new Array()
<br>

<br>
new Array(n) creates an Array of length n that contains n holes:
<br>
// Trailing commas are always ignored.
<br>
// Therefore: number of commas = number of holes
<br>
assert.deepEqual(new Array(3), [,,,]);
<br>
new Array() creates an empty Array. However, I recommend to always use [] instead.
<br>

<br>
31.12.2 Static methods of Array
<br>
• Array.from<T>(iterable: Iterable<T> | ArrayLike<T>): T[] [ES6]
<br>
• Array.from<T,U>(iterable: Iterable<T> | ArrayLike<T>, mapFunc: (v: T,
<br>
k: number) => U, thisArg?: any): U[] [ES6]
<br>

<br>
Converts an iterable or an Array-like object to an Array. Optionally, the input values can be translated via mapFunc before they are added to the output Array.
<br>
Examples:
<br>

<br>
31.12 Quick reference: Array<T>
<br>

<br>
335
<br>

<br>
> Array.from(new Set(['a', 'b'])) // iterable
<br>
[ 'a', 'b' ]
<br>
> Array.from({length: 2, 0:'a', 1:'b'}) // Array-like object
<br>
[ 'a', 'b' ]
<br>

<br>
• Array.of<T>(...items: T[]): T[] [ES6]
<br>
This static method is mainly useful for subclasses of Array, where it serves as a
<br>
custom Array literal:
<br>
class MyArray extends Array {}
<br>
assert.equal(
<br>
MyArray.of('a', 'b') instanceof MyArray, true);
<br>

<br>
31.12.3 Methods of Array<T>.prototype
<br>
• .concat(...items: Array<T[] | T>): T[] [R, ES3]
<br>
Returns a new Array that is the concatenation of the receiver and all items. NonArray parameters (such as 'b' in the following example) are treated as if they were
<br>
Arrays with single elements.
<br>
> ['a'].concat('b', ['c', 'd'])
<br>
[ 'a', 'b', 'c', 'd' ]
<br>

<br>
• .copyWithin(target: number, start: number, end=this.length): this [W, ES6]
<br>
Copies the elements whose indices range from (including) start to (excluding) end
<br>
to indices starting with target. Overlapping is handled correctly.
<br>
> ['a', 'b', 'c', 'd'].copyWithin(0, 2, 4)
<br>
[ 'c', 'd', 'c', 'd' ]
<br>

<br>
If start or end is negative, then .length is added to it.
<br>
• .entries(): Iterable<[number, T]> [R, ES6]
<br>
Returns an iterable over [index, element] pairs.
<br>
> Array.from(['a', 'b'].entries())
<br>
[ [ 0, 'a' ], [ 1, 'b' ] ]
<br>

<br>
• .every(callback: (value: T, index: number, array: Array<T>) => boolean,
<br>
thisArg?: any): boolean [R, ES5]
<br>

<br>
Returns true if callback returns a truthy value for every element. Otherwise, it
<br>
returns false. It stops as soon as it receives a falsy value. This method corresponds
<br>
to universal quantiﬁcation (“for all”, ∀) in mathematics.
<br>
> [1, 2, 3].every(x => x > 0)
<br>
true
<br>
> [1, -2, 3].every(x => x > 0)
<br>
false
<br>

<br>
Related method: .some() (“exists”).
<br>

<br>
336
<br>

<br>
31 Arrays (Array)
<br>

<br>
• .fill(value: T, start=0, end=this.length): this [W, ES6]
<br>
Assigns value to every index between (including) start and (excluding) end.
<br>
> [0, 1, 2].fill('a')
<br>
[ 'a', 'a', 'a' ]
<br>

<br>
Caveat: Don’t use this method to ﬁll an Array with an object obj; then each element
<br>
will refer to obj (sharing it). In this case, it’s better to use Array.from().
<br>
• .filter(callback: (value: T, index: number, array: Array<T>) => any,
<br>
thisArg?: any): T[] [R, ES5]
<br>

<br>
Returns an Array with only those elements for which callback returns a truthy
<br>
value.
<br>
> [1, -2, 3].filter(x => x > 0)
<br>
[ 1, 3 ]
<br>

<br>
• .find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined [R, ES6]
<br>

<br>
The result is the ﬁrst element for which predicate returns a truthy value. If there
<br>
is no such element, the result is undefined.
<br>
> [1, -2, 3].find(x => x < 0)
<br>
-2
<br>
> [1, 2, 3].find(x => x < 0)
<br>
undefined
<br>

<br>
• .findIndex(predicate: (value: T, index: number, obj: T[]) => boolean,
<br>
thisArg?: any): number [R, ES6]
<br>

<br>
The result is the index of the ﬁrst element for which predicate returns a truthy
<br>
value. If there is no such element, the result is -1.
<br>
> [1, -2, 3].findIndex(x => x < 0)
<br>
1
<br>
> [1, 2, 3].findIndex(x => x < 0)
<br>
-1
<br>

<br>
• .flat(depth = 1): any[] [R, ES2019]
<br>
“Flattens” an Array: It descends into the Arrays that are nested inside the input
<br>
Array and creates a copy where all values it ﬁnds at level depth or lower are moved
<br>
to the top level.
<br>
> [ 1,2, [3,4], [[5,6]] ].flat(0) // no change
<br>
[ 1, 2, [3,4], [[5,6]] ]
<br>
> [ 1,2, [3,4], [[5,6]] ].flat(1)
<br>
[1, 2, 3, 4, [5,6]]
<br>
> [ 1,2, [3,4], [[5,6]] ].flat(2)
<br>
[1, 2, 3, 4, 5, 6]
<br>

<br>
337
<br>

<br>
31.12 Quick reference: Array<T>
<br>

<br>
• .flatMap<U>(callback:
<br>

<br>
(value:
<br>

<br>
T,
<br>

<br>
index:
<br>

<br>
number,
<br>

<br>
array:
<br>

<br>
T[])
<br>

<br>
=>
<br>

<br>
U|Array<U>, thisValue?: any): U[] [R, ES2019]
<br>

<br>
The result is produced by invoking callback() for each element of the original
<br>
Array and concatenating the Arrays it returns.
<br>
> ['a', 'b', 'c'].flatMap(x => [x,x])
<br>
[ 'a', 'a', 'b', 'b', 'c', 'c' ]
<br>
> ['a', 'b', 'c'].flatMap(x => [x])
<br>
[ 'a', 'b', 'c' ]
<br>
> ['a', 'b', 'c'].flatMap(x => [])
<br>
[]
<br>

<br>
• .forEach(callback: (value: T, index: number, array: Array<T>) => void,
<br>
thisArg?: any): void [R, ES5]
<br>

<br>
Calls callback for each element.
<br>
['a', 'b'].forEach((x, i) => console.log(x, i))
<br>
// Output:
<br>
// 'a', 0
<br>
// 'b', 1
<br>

<br>
A for-of loop is usually a better choice: it’s faster, supports break and can iterate
<br>
over arbitrary iterables.
<br>
• .includes(searchElement: T, fromIndex=0): boolean [R, ES2016]
<br>
Returns true if the receiver has an element whose value is searchElement and
<br>
false, otherwise. Searching starts at index fromIndex.
<br>
> [0, 1, 2].includes(1)
<br>
true
<br>
> [0, 1, 2].includes(5)
<br>
false
<br>

<br>
• .indexOf(searchElement: T, fromIndex=0): number [R, ES5]
<br>
Returns the index of the ﬁrst element that is strictly equal to searchElement. Returns -1 if there is no such element. Starts searching at index fromIndex, visiting
<br>
higher indices next.
<br>
> ['a', 'b', 'a'].indexOf('a')
<br>
0
<br>
> ['a', 'b', 'a'].indexOf('a', 1)
<br>
2
<br>
> ['a', 'b', 'a'].indexOf('c')
<br>
-1
<br>

<br>
• .join(separator = ','): string [R, ES1]
<br>
Creates a string by concatenating string representations of all elements, separating
<br>
them with separator.
<br>

<br>
338
<br>

<br>
31 Arrays (Array)
<br>
> ['a', 'b', 'c'].join('##')
<br>
'a##b##c'
<br>
> ['a', 'b', 'c'].join()
<br>
'a,b,c'
<br>

<br>
• .keys(): Iterable<number> [R, ES6]
<br>
Returns an iterable over the keys of the receiver.
<br>
> [...['a', 'b'].keys()]
<br>
[ 0, 1 ]
<br>

<br>
• .lastIndexOf(searchElement: T, fromIndex=this.length-1): number [R, ES5]
<br>
Returns the index of the last element that is strictly equal to searchElement. Returns -1 if there is no such element. Starts searching at index fromIndex, visiting
<br>
lower indices next.
<br>
> ['a', 'b', 'a'].lastIndexOf('a')
<br>
2
<br>
> ['a', 'b', 'a'].lastIndexOf('a', 1)
<br>
0
<br>
> ['a', 'b', 'a'].lastIndexOf('c')
<br>
-1
<br>

<br>
• .map<U>(mapFunc: (value: T, index: number, array: Array<T>) => U, thisArg?: any): U[] [R, ES5]
<br>

<br>
Returns a new Array, in which every element is the result of mapFunc being applied
<br>
to the corresponding element of the receiver.
<br>
> [1, 2, 3].map(x => x * 2)
<br>
[ 2, 4, 6 ]
<br>
> ['a', 'b', 'c'].map((x, i) => i)
<br>
[ 0, 1, 2 ]
<br>

<br>
• .pop(): T | undefined [W, ES3]
<br>
Removes and returns the last element of the receiver. That is, it treats the end of
<br>
the receiver as a stack. The opposite of .push().
<br>
> const arr = ['a', 'b', 'c'];
<br>
> arr.pop()
<br>
'c'
<br>
> arr
<br>
[ 'a', 'b' ]
<br>

<br>
• .push(...items: T[]): number [W, ES3]
<br>
Adds zero or more items to the end of the receiver. That is, it treats the end of the
<br>
receiver as a stack. The return value is the length of the receiver after the change.
<br>
The opposite of .pop().
<br>
> const arr = ['a', 'b'];
<br>
> arr.push('c', 'd')
<br>

<br>
31.12 Quick reference: Array<T>
<br>

<br>
339
<br>

<br>
4
<br>
> arr
<br>
[ 'a', 'b', 'c', 'd' ]
<br>

<br>
• .reduce<U>(callback: (accumulator: U, element: T, index: number, array:
<br>
T[]) => U, init?: U): U [R, ES5]
<br>

<br>
This method produces a summary of the receiver: it feeds all Array elements to
<br>
callback, which combines a current summary (in parameter accumulator) with
<br>
the current Array element and returns the next accumulator:
<br>
const accumulator_0 = callback(init, arr[0]);
<br>
const accumulator_1 = callback(accumulator_0, arr[1]);
<br>
const accumulator_2 = callback(accumulator_1, arr[2]);
<br>
// Etc.
<br>

<br>
The result of .reduce() is the last result of callback after it has visited all Array
<br>
elements.
<br>
> [1, 2, 3].reduce((accu, x) => accu + x, 0)
<br>
6
<br>
> [1, 2, 3].reduce((accu, x) => accu + String(x), '')
<br>
'123'
<br>

<br>
If no init is provided, the Array element at index 0 is used and the element at
<br>
index 1 is visited ﬁrst. Therefore, the Array must have at least length 1.
<br>
• .reduceRight<U>(callback: (accumulator: U, element: T, index: number,
<br>
array: T[]) => U, init?: U): U [R, ES5]
<br>

<br>
Works like .reduce(), but visits the Array elements backward, starting with the
<br>
last element.
<br>
> [1, 2, 3].reduceRight((accu, x) => accu + String(x), '')
<br>
'321'
<br>

<br>
• .reverse(): this [W, ES1]
<br>
Rearranges the elements of the receiver so that they are in reverse order and then
<br>
returns the receiver.
<br>
> const arr = ['a', 'b', 'c'];
<br>
> arr.reverse()
<br>
[ 'c', 'b', 'a' ]
<br>
> arr
<br>
[ 'c', 'b', 'a' ]
<br>

<br>
• .shift(): T | undefined [W, ES3]
<br>
Removes and returns the ﬁrst element of the receiver. The opposite of .unshift().
<br>
> const arr = ['a', 'b', 'c'];
<br>
> arr.shift()
<br>
'a'
<br>

<br>
340
<br>

<br>
31 Arrays (Array)
<br>
> arr
<br>
[ 'b', 'c' ]
<br>

<br>
• .slice(start=0, end=this.length): T[] [R, ES3]
<br>
Returns a new Array containing the elements of the receiver whose indices are
<br>
between (including) start and (excluding) end.
<br>
> ['a', 'b', 'c', 'd'].slice(1, 3)
<br>
[ 'b', 'c' ]
<br>
> ['a', 'b'].slice() // shallow copy
<br>
[ 'a', 'b' ]
<br>

<br>
Negative indices are allowed and added to .length:
<br>
> ['a', 'b', 'c'].slice(-2)
<br>
[ 'b', 'c' ]
<br>

<br>
• .some(callback: (value: T, index: number, array: Array<T>) => boolean,
<br>
thisArg?: any): boolean [R, ES5]
<br>

<br>
Returns true if callback returns a truthy value for at least one element. Otherwise, it returns false. It stops as soon as it receives a truthy value. This method
<br>
corresponds to existential quantiﬁcation (“exists”, ∃) in mathematics.
<br>
> [1, 2, 3].some(x => x < 0)
<br>
false
<br>
> [1, -2, 3].some(x => x < 0)
<br>
true
<br>

<br>
Related method: .every() (“for all”).
<br>
• .sort(compareFunc?: (a: T, b: T) => number): this [W, ES1]
<br>
Sorts the receiver and returns it. By default, it sorts string representations of the
<br>
elements. It does so lexicographically and according to the code unit values (char
<br>
codes) of the characters:
<br>
> ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()
<br>
[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]
<br>
> [200, 3, 10].sort()
<br>
[ 10, 200, 3 ]
<br>

<br>
You can customize the sort order via compareFunc, which returns a number that is:
<br>
– negative if a < b
<br>
– zero if a === b
<br>
– positive if a > b
<br>
Trick for sorting numbers (with a risk of numeric overﬂow or underﬂow):
<br>
> [200, 3, 10].sort((a, b) => a - b)
<br>
[ 3, 10, 200 ]
<br>

<br>
31.12 Quick reference: Array<T>
<br>

<br>
341
<br>

<br>
.sort() is stable
<br>

<br>
Since ECMAScript 2019, sorting is guaranteed to be stable: if elements are
<br>
considered equal by sorting, then sorting does not change the order of those
<br>
elements (relative to each other).
<br>
• .splice(start: number, deleteCount=this.length-start, ...items: T[]):
<br>
T[] [W, ES3]
<br>

<br>
At index start, it removes deleteCount elements and inserts the items. It returns
<br>
the deleted elements.
<br>
> const arr = ['a', 'b', 'c', 'd'];
<br>
> arr.splice(1, 2, 'x', 'y')
<br>
[ 'b', 'c' ]
<br>
> arr
<br>
[ 'a', 'x', 'y', 'd' ]
<br>
start can be negative and is added to .length if it is:
<br>
> ['a', 'b', 'c'].splice(-2, 2)
<br>
[ 'b', 'c' ]
<br>

<br>
• .toString(): string [R, ES1]
<br>
Converts all elements to strings via String(), concatenates them while separating
<br>
them with commas, and returns the result.
<br>
> [1, 2, 3].toString()
<br>
'1,2,3'
<br>
> ['1', '2', '3'].toString()
<br>
'1,2,3'
<br>
> [].toString()
<br>
''
<br>

<br>
• .unshift(...items: T[]): number [W, ES3]
<br>
Inserts the items at the beginning of the receiver and returns its length after this
<br>
modiﬁcation.
<br>
> const arr = ['c', 'd'];
<br>
> arr.unshift('e', 'f')
<br>
4
<br>
> arr
<br>
[ 'e', 'f', 'c', 'd' ]
<br>

<br>
• .values(): Iterable<T> [R, ES6]
<br>
Returns an iterable over the values of the receiver.
<br>
> [...['a', 'b'].values()]
<br>
[ 'a', 'b' ]
<br>

<br>
342
<br>

<br>
31 Arrays (Array)
<br>

<br>
31.12.4 Sources
<br>
• TypeScript’s built-in typings
<br>
• MDN web docs for JavaScript
<br>
• ECMAScript language speciﬁcation
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 32
<br>

<br>
Typed Arrays: handling binary
<br>
data (Advanced)
<br>
Contents
<br>
32.1 The basics of the API . . . . . . . . . . . . . . . . . . . . . . . . . . . 344
<br>
32.1.1 Use cases for Typed Arrays . . . . . . . . . . . . . . . . . . . . 344
<br>
32.1.2 The core classes: ArrayBuffer, Typed Arrays, DataView . . . . 344
<br>
32.1.3 Using Typed Arrays
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . 345
<br>

<br>
32.1.4 Using DataViews . . . . . . . . . . . . . . . . . . . . . . . . . 346
<br>
32.2 Element types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346
<br>
32.2.1 Handling overﬂow and underﬂow
<br>

<br>
. . . . . . . . . . . . . . . 347
<br>

<br>
32.2.2 Endianness . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348
<br>
32.3 More information on Typed Arrays . . . . . . . . . . . . . . . . . . . 348
<br>
32.3.1 The static method «ElementType»Array.from() . . . . . . . . 349
<br>
32.3.2 Typed Arrays are iterable . . . . . . . . . . . . . . . . . . . . . 350
<br>
32.3.3 Typed Arrays vs. normal Arrays . . . . . . . . . . . . . . . . . 350
<br>
32.3.4 Converting Typed Arrays to and from normal Arrays . . . . . 351
<br>
32.3.5 Concatenating Typed Arrays . . . . . . . . . . . . . . . . . . . 351
<br>
32.4 Quick references: indices vs. offsets . . . . . . . . . . . . . . . . . . 352
<br>
32.5 Quick reference: ArrayBuffers . . . . . . . . . . . . . . . . . . . . . 353
<br>
32.5.1 new ArrayBuffer() . . . . . . . . . . . . . . . . . . . . . . . . 353
<br>
32.5.2 Static methods of ArrayBuffer . . . . . . . . . . . . . . . . . . 353
<br>
32.5.3 Properties of ArrayBuffer.prototype . . . . . . . . . . . . . . 353
<br>
32.6 Quick reference: Typed Arrays . . . . . . . . . . . . . . . . . . . . . 354
<br>
32.6.1 Static methods of TypedArray<T> . . . . . . . . . . . . . . . . 354
<br>
32.6.2 Properties of TypedArray<T>.prototype . . . . . . . . . . . . 354
<br>
32.6.3 new «ElementType»Array() . . . . . . . . . . . . . . . . . . . 356
<br>
32.6.4 Static properties of «ElementType»Array . . . . . . . . . . . . 357
<br>
32.6.5 Properties of «ElementType»Array.prototype . . . . . . . . . 357
<br>
32.7 Quick reference: DataViews . . . . . . . . . . . . . . . . . . . . . . . 357
<br>

<br>
343
<br>

<br>
344
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>
32.7.1 new DataView() . . . . . . . . . . . . . . . . . . . . . . . . . . 357
<br>
32.7.2 Properties of DataView.prototype . . . . . . . . . . . . . . . . 357
<br>

<br>
32.1 The basics of the API
<br>
Much data on the web is text: JSON ﬁles, HTML ﬁles, CSS ﬁles, JavaScript code, etc.
<br>
JavaScript handles such data well via its built-in strings.
<br>
However, before 2011, it did not handle binary data well. The Typed Array Speciﬁcation
<br>
1.0 was introduced on February 8, 2011 and provides tools for working with binary data.
<br>
With ECMAScript 6, Typed Arrays were added to the core language and gained methods
<br>
that were previously only available for normal Arrays (.map(), .filter(), etc.).
<br>

<br>
32.1.1 Use cases for Typed Arrays
<br>
The main uses cases for Typed Arrays, are:
<br>
• Processing binary data: managing image data, manipulating binary ﬁles, handling
<br>
binary network protocols, etc.
<br>
• Interacting with native APIs: Native APIs often receive and return data in a binary
<br>
format, which you could neither store nor manipulate well in pre-ES6 JavaScript.
<br>
That meant that whenever you were communicating with such an API, data had to
<br>
be converted from JavaScript to binary and back for every call. Typed Arrays eliminate this bottleneck. One example of communicating with native APIs is WebGL,
<br>
for which Typed Arrays were initially created. Section “History of Typed Arrays”
<br>
of the article “Typed Arrays: Binary Data in the Browser” (by Ilmari Heikkinen for
<br>
HTML5 Rocks) has more information.
<br>

<br>
32.1.2 The core classes: ArrayBuffer, Typed Arrays, DataView
<br>
The Typed Array API stores binary data in instances of ArrayBuffer:
<br>
const buf = new ArrayBuffer(4); // length in bytes
<br>
// buf is initialized with zeros
<br>

<br>
An ArrayBuffer itself is a black box: if you want to access its data, you must wrap it in
<br>
another object – a view object. Two kinds of view objects are available:
<br>
• Typed Arrays: let you access the data as an indexed sequence of elements that all
<br>
have the same type. Examples include:
<br>
– Uint8Array: Elements are unsigned 8-bit integers. Unsigned means that their
<br>
ranges start at zero.
<br>
– Int16Array: Elements are signed 16-bit integers. Signed means that they have
<br>
a sign and can be negative, zero, or positive.
<br>
– Float32Array: Elements are 32-bit ﬂoating point numbers.
<br>
• DataViews: let you interpret the data as various types (Uint8, Int16, Float32, etc.)
<br>
that you can read and write at any byte offset.
<br>
Fig. 32.1 shows a class diagram of the API.
<br>

<br>
32.1 The basics of the API
<br>

<br>
345
<br>

<br>
Figure 32.1: The classes of the Typed Array API.
<br>

<br>
32.1.3 Using Typed Arrays
<br>
Typed Arrays are used much like normal Arrays with a few notable differences:
<br>
• Typed Arrays store their data in ArrayBuffers.
<br>
• All elements are initialized with zeros.
<br>
• All elements have the same type. Writing values to a Typed Array coerces them to
<br>
that type. Reading values produces normal numbers.
<br>
• The length of a Typed Array is immutable; it can’t be changed.
<br>
• Typed Arrays can’t have holes.
<br>
32.1.3.1 Creating Typed Arrays
<br>
The following code shows three different ways of creating the same Typed Array:
<br>
// Argument: Typed Array or Array-like object
<br>
const ta1 = new Uint8Array([0, 1, 2]);
<br>
const ta2 = Uint8Array.of(0, 1, 2);
<br>
const ta3 = new Uint8Array(3); // length of Typed Array
<br>
ta3[0] = 0;
<br>
ta3[1] = 1;
<br>
ta3[2] = 2;
<br>
assert.deepEqual(ta1, ta2);
<br>
assert.deepEqual(ta1, ta3);
<br>

<br>
346
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>

<br>
32.1.3.2 The wrapped ArrayBuffer
<br>
const typedArray = new Int16Array(2); // 2 elements
<br>
assert.equal(typedArray.length, 2);
<br>
assert.deepEqual(
<br>
typedArray.buffer, new ArrayBuffer(4)); // 4 bytes
<br>

<br>
32.1.3.3 Getting and setting elements
<br>
const typedArray = new Int16Array(2);
<br>
assert.equal(typedArray[1], 0); // initialized with 0
<br>
typedArray[1] = 72;
<br>
assert.equal(typedArray[1], 72);
<br>

<br>
32.1.4 Using DataViews
<br>
This is how DataViews are used:
<br>
const dataView = new DataView(new ArrayBuffer(4));
<br>
assert.equal(dataView.getInt16(0), 0);
<br>
assert.equal(dataView.getUint8(0), 0);
<br>
dataView.setUint8(0, 5);
<br>

<br>
32.2 Element types
<br>
Table 32.1: Element types supported by the Typed Array API.
<br>
Element
<br>

<br>
Typed Array
<br>

<br>
Bytes
<br>

<br>
Description
<br>

<br>
Int8
<br>

<br>
Int8Array
<br>

<br>
Uint8
<br>

<br>
Uint8Array
<br>

<br>
Uint8C
<br>

<br>
Uint8ClampedArray
<br>

<br>
1
<br>
1
<br>
1
<br>

<br>
Int16
<br>

<br>
Int16Array
<br>

<br>
Uint16
<br>

<br>
Uint16Array
<br>

<br>
Int32
<br>

<br>
Int32Array
<br>

<br>
Uint32
<br>

<br>
Uint32Array
<br>

<br>
Float32
<br>

<br>
Float32Array
<br>

<br>
Float64
<br>

<br>
Float64Array
<br>

<br>
8-bit signed integer
<br>
8-bit unsigned integer
<br>
8-bit unsigned integer
<br>
(clamped conversion)
<br>
16-bit signed integer
<br>
16-bit unsigned integer
<br>
32-bit signed integer
<br>
32-bit unsigned integer
<br>
32-bit ﬂoating point
<br>
64-bit ﬂoating point
<br>

<br>
2
<br>
2
<br>
4
<br>
4
<br>
4
<br>
8
<br>

<br>
ES6
<br>
ES6
<br>
ES6
<br>
ES6
<br>
ES6
<br>
ES6
<br>
ES6
<br>
ES6
<br>
ES6
<br>
ES6
<br>

<br>
Tbl. 32.1 lists the available element types. These types (e.g., Int32) show up in two locations:
<br>
• They are the types of the elements of Typed Arrays. For example, all elements of
<br>
a Int32Array have the type Int32. The element type is the only aspect of Typed
<br>
Arrays that differs.
<br>

<br>
32.2 Element types
<br>

<br>
347
<br>

<br>
• They are the lenses through which an ArrayBuffer accesses its DataView when you
<br>
use methods such as .getInt32() and .setInt32().
<br>
The element type Uint8C is special: it is not supported by DataView and only exists to
<br>
enable Uint8ClampedArray. This Typed Array is used by the canvas element (where
<br>
it replaces CanvasPixelArray) and should otherwise be avoided. The only difference
<br>
between Uint8C and Uint8 is how overﬂow and underﬂow are handled (as explained in
<br>
the next subsection).
<br>

<br>
32.2.1 Handling overﬂow and underﬂow
<br>
Normally, when a value is out of the range of the element type, modulo arithmetic is used
<br>
to convert it to a value within range. For signed and unsigned integers that means that:
<br>
• The highest value plus one is converted to the lowest value (0 for unsigned integers).
<br>
• The lowest value minus one is converted to the highest value.
<br>
The following function helps illustrate how conversion works:
<br>
function setAndGet(typedArray, value) {
<br>
typedArray[0] = value;
<br>
return typedArray[0];
<br>
}
<br>

<br>
Modulo conversion for unsigned 8-bit integers:
<br>
const uint8 = new Uint8Array(1);
<br>
// Highest value of range
<br>
assert.equal(setAndGet(uint8, 255), 255);
<br>
// Overflow
<br>
assert.equal(setAndGet(uint8, 256), 0);
<br>
// Lowest value of range
<br>
assert.equal(setAndGet(uint8, 0), 0);
<br>
// Underflow
<br>
assert.equal(setAndGet(uint8, -1), 255);
<br>

<br>
Modulo conversion for signed 8-bit integers:
<br>
const int8 = new Int8Array(1);
<br>
// Highest value of range
<br>
assert.equal(setAndGet(int8, 127), 127);
<br>
// Overflow
<br>
assert.equal(setAndGet(int8, 128), -128);
<br>
// Lowest value of range
<br>
assert.equal(setAndGet(int8, -128), -128);
<br>
// Underflow
<br>
assert.equal(setAndGet(int8, -129), 127);
<br>

<br>
348
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>

<br>
Clamped conversion is different:
<br>
• All underﬂowing values are converted to the lowest value.
<br>
• All overﬂowing values are converted to the highest value.
<br>
const uint8c = new Uint8ClampedArray(1);
<br>
// Highest value of range
<br>
assert.equal(setAndGet(uint8c, 255), 255);
<br>
// Overflow
<br>
assert.equal(setAndGet(uint8c, 256), 255);
<br>
// Lowest value of range
<br>
assert.equal(setAndGet(uint8c, 0), 0);
<br>
// Underflow
<br>
assert.equal(setAndGet(uint8c, -1), 0);
<br>

<br>
32.2.2 Endianness
<br>
Whenever a type (such as Uint16) is stored as a sequence of multiple bytes, endianness
<br>
matters:
<br>
• Big endian: the most signiﬁcant byte comes ﬁrst. For example, the Uint16 value
<br>
0x4321 is stored as two bytes – ﬁrst 0x43, then 0x21.
<br>
• Little endian: the least signiﬁcant byte comes ﬁrst. For example, the Uint16 value
<br>
0x4321 is stored as two bytes – ﬁrst 0x21, then 0x43.
<br>
Endianness tends to be ﬁxed per CPU architecture and consistent across native APIs.
<br>
Typed Arrays are used to communicate with those APIs, which is why their endianness
<br>
follows the endianness of the platform and can’t be changed.
<br>
On the other hand, the endianness of protocols and binary ﬁles varies, but is ﬁxed per
<br>
format, across platforms. Therefore, we must be able to access data with either endianness. DataViews serve this use case and let you specify endianness when you get or set
<br>
a value.
<br>
Quoting Wikipedia on Endianness:
<br>
• Big-endian representation is the most common convention in data networking;
<br>
ﬁelds in the protocols of the Internet protocol suite, such as IPv4, IPv6, TCP, and
<br>
UDP, are transmitted in big-endian order. For this reason, big-endian byte order
<br>
is also referred to as network byte order.
<br>
• Little-endian storage is popular for microprocessors in part due to signiﬁcant historical inﬂuence on microprocessor designs by Intel Corporation.
<br>
Other orderings are also possible. Those are generically called middle-endian or mixedendian.
<br>

<br>
32.3 More information on Typed Arrays
<br>
In this section, «ElementType»Array stands for Int8Array, Uint8Array, etc. ElementType
<br>
is Int8, Uint8, etc.
<br>

<br>
32.3 More information on Typed Arrays
<br>

<br>
349
<br>

<br>
32.3.1 The static method «ElementType»Array.from()
<br>
This method has the type signature:
<br>
.from<S>(
<br>
source: Iterable<S>|ArrayLike<S>,
<br>
mapfn?: S => ElementType, thisArg?: any)
<br>
: «ElementType»Array
<br>
.from() converts source into an instance of this (a Typed Array).
<br>

<br>
For example, normal Arrays are iterable and can be converted with this method:
<br>
assert.deepEqual(
<br>
Uint16Array.from([0, 1, 2]),
<br>
Uint16Array.of(0, 1, 2));
<br>

<br>
Typed Arrays are also iterable:
<br>
assert.deepEqual(
<br>
Uint16Array.from(Uint8Array.of(0, 1, 2)),
<br>
Uint16Array.of(0, 1, 2));
<br>
source can also be an Array-like object:
<br>
assert.deepEqual(
<br>
Uint16Array.from({0:0, 1:1, 2:2, length: 3}),
<br>
Uint16Array.of(0, 1, 2));
<br>

<br>
The optional mapfn lets you transform the elements of source before they become elements of the result. Why perform the two steps mapping and conversion in one go? Compared to mapping separately via .map(), there are two advantages:
<br>
1. No intermediate Array or Typed Array is needed.
<br>
2. When converting between Typed Arrays with different precisions, less can go
<br>
wrong.
<br>
Read on for an explanation of the second advantage.
<br>
32.3.1.1 Pitfall: mapping while converting between Typed Array types
<br>
The static method .from() can optionally both map and convert between Typed Array
<br>
types. Less can go wrong if you use that method.
<br>
To see why that is, let us ﬁrst convert a Typed Array to a Typed Array with a higher
<br>
precision. If we use .from() to map, the result is automatically correct. Otherwise, you
<br>
must ﬁrst convert and then map.
<br>
const typedArray = Int8Array.of(127, 126, 125);
<br>
assert.deepEqual(
<br>
Int16Array.from(typedArray, x => x * 2),
<br>
Int16Array.of(254, 252, 250));
<br>
assert.deepEqual(
<br>
Int16Array.from(typedArray).map(x => x * 2),
<br>

<br>
350
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>
Int16Array.of(254, 252, 250)); // OK
<br>

<br>
assert.deepEqual(
<br>
Int16Array.from(typedArray.map(x => x * 2)),
<br>
Int16Array.of(-2, -4, -6)); // wrong
<br>

<br>
If we go from a Typed Array to a Typed Array with a lower precision, mapping via
<br>
.from() produces the correct result. Otherwise, we must ﬁrst map and then convert.
<br>
assert.deepEqual(
<br>
Int8Array.from(Int16Array.of(254, 252, 250), x => x / 2),
<br>
Int8Array.of(127, 126, 125));
<br>
assert.deepEqual(
<br>
Int8Array.from(Int16Array.of(254, 252, 250).map(x => x / 2)),
<br>
Int8Array.of(127, 126, 125)); // OK
<br>
assert.deepEqual(
<br>
Int8Array.from(Int16Array.of(254, 252, 250)).map(x => x / 2),
<br>
Int8Array.of(-1, -2, -3)); // wrong
<br>

<br>
The problem is that if we map via .map(), then input type and output type are the same.
<br>
In contrast, .from() goes from an arbitrary input type to an output type that you specify
<br>
via its receiver.
<br>

<br>
32.3.2 Typed Arrays are iterable
<br>
Typed Arrays are iterable. That means that you can use the for-of loop and other
<br>
iteration-based mechanisms:
<br>
const ui8 = Uint8Array.of(0, 1, 2);
<br>
for (const byte of ui8) {
<br>
console.log(byte);
<br>
}
<br>
// Output:
<br>
// 0
<br>
// 1
<br>
// 2
<br>

<br>
ArrayBuffers and DataViews are not iterable.
<br>

<br>
32.3.3 Typed Arrays vs. normal Arrays
<br>
Typed Arrays are much like normal Arrays: they have a .length, elements can be accessed via the bracket operator [], and they have most of the standard Array methods.
<br>
They differ from normal Arrays in the following ways:
<br>
• Typed Arrays have buffers. The elements of a Typed Array ta are not stored in ta,
<br>
they are stored in an associated ArrayBuffer that can be accessed via ta.buffer:
<br>
const ta = new Uint16Array(2); // 2 elements
<br>
assert.deepEqual(
<br>
ta.buffer, new ArrayBuffer(4)); // 4 bytes
<br>

<br>
32.3 More information on Typed Arrays
<br>

<br>
351
<br>

<br>
• Typed Arrays are initialized with zeros:
<br>
– new Array(4) creates a normal Array without any elements. It only has four
<br>
holes (indices less than the .length that have no associated elements).
<br>
– new Uint8Array(4) creates a Typed Array whose four elements are all 0.
<br>
assert.deepEqual(new Uint8Array(4), Uint8Array.of(0, 0, 0, 0));
<br>

<br>
• All of the elements of a Typed Array have the same type:
<br>
– Setting elements converts values to that type.
<br>
const ta = new Uint8Array(1);
<br>
ta[0] = 257;
<br>
assert.equal(ta[0], 1); // 257 % 256 (overflow)
<br>
ta[0] = '2';
<br>
assert.equal(ta[0], 2);
<br>

<br>
– Getting elements returns numbers.
<br>
const ta = new Uint8Array(1);
<br>
assert.equal(ta[0], 0);
<br>
assert.equal(typeof ta[0], 'number');
<br>

<br>
• The .length of a Typed Array is derived from its ArrayBuffer and never changes
<br>
(unless you switch to a different ArrayBuffer).
<br>
• Normal Arrays can have holes; Typed Arrays can’t.
<br>

<br>
32.3.4 Converting Typed Arrays to and from normal Arrays
<br>
To convert a normal Array to a Typed Array, you pass it to a Typed Array constructor
<br>
(which accepts Array-like objects and Typed Arrays) or to «ElementType»Array.from()
<br>
(which accepts iterables and Array-like objects). For example:
<br>
const ta1 = new Uint8Array([0, 1, 2]);
<br>
const ta2 = Uint8Array.from([0, 1, 2]);
<br>
assert.deepEqual(ta1, ta2);
<br>

<br>
To convert a Typed Array to a normal Array, you can use spreading or Array.from()
<br>
(because Typed Arrays are iterable):
<br>
assert.deepEqual(
<br>
[...Uint8Array.of(0, 1, 2)], [0, 1, 2] );
<br>
assert.deepEqual(
<br>
Array.from(Uint8Array.of(0, 1, 2)), [0, 1, 2] );
<br>

<br>
32.3.5 Concatenating Typed Arrays
<br>
Typed Arrays don’t have a method .concat(), like normal Arrays do. The workaround
<br>
is to use their overloaded method .set():
<br>

<br>
352
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>

<br>
.set(typedArray: TypedArray, offset=0): void
<br>
.set(arrayLike: ArrayLike<number>, offset=0): void
<br>

<br>
It copies the existing typedArray or arrayLike into the receiver, at index offset. TypedArray is a ﬁctitious abstract superclass of all concrete Typed Array classes.
<br>
The following function uses that method to copy zero or more Typed Arrays (or Arraylike objects) into an instance of resultConstructor:
<br>
function concatenate(resultConstructor, ...arrays) {
<br>
let totalLength = 0;
<br>
for (const arr of arrays) {
<br>
totalLength += arr.length;
<br>
}
<br>
const result = new resultConstructor(totalLength);
<br>
let offset = 0;
<br>
for (const arr of arrays) {
<br>
result.set(arr, offset);
<br>
offset += arr.length;
<br>
}
<br>
return result;
<br>
}
<br>
assert.deepEqual(
<br>
concatenate(Uint8Array, Uint8Array.of(1, 2), [3, 4]),
<br>
Uint8Array.of(1, 2, 3, 4));
<br>

<br>
32.4 Quick references: indices vs. offsets
<br>
In preparation for the quick references on ArrayBuffers, Typed Arrays, and DataViews,
<br>
we need learn the differences between indices and offsets:
<br>
• Indices for the bracket operator [ ]: You can only use non-negative indices (starting
<br>
at 0).
<br>
In normal Arrays, writing to negative indices creates properties:
<br>
const arr = [6, 7];
<br>
arr[-1] = 5;
<br>
assert.deepEqual(
<br>
Object.keys(arr), ['0', '1', '-1']);
<br>

<br>
In Typed Arrays, writing to negative indices is ignored:
<br>
const tarr = Uint8Array.of(6, 7);
<br>
tarr[-1] = 5;
<br>
assert.deepEqual(
<br>
Object.keys(tarr), ['0', '1']);
<br>

<br>
• Indices for methods of ArrayBuffers, Typed Arrays, and DataViews: Every index
<br>
can be negative. If it is, it is added to the length of the entity to produce the actual
<br>
index. Therefore, -1 refers to the last element, -2 to the second-last, etc. Methods
<br>
of normal Arrays work the same way.
<br>

<br>
32.5 Quick reference: ArrayBuffers
<br>

<br>
353
<br>

<br>
const ui8 = Uint8Array.of(0, 1, 2);
<br>
assert.deepEqual(ui8.slice(-1), Uint8Array.of(2));
<br>

<br>
• Offsets passed to methods of Typed Arrays and DataViews: must be non-negative
<br>
– for example:
<br>
const dataView = new DataView(new ArrayBuffer(4));
<br>
assert.throws(
<br>
() => dataView.getUint8(-1),
<br>
{
<br>
name: 'RangeError',
<br>
message: 'Offset is outside the bounds of the DataView',
<br>
});
<br>

<br>
Whether a parameter is an index or an offset can only be determined by looking at documentation; there is no simple rule.
<br>

<br>
32.5 Quick reference: ArrayBuffers
<br>
ArrayBuffers store binary data, which is meant to be accessed via Typed Arrays and
<br>
DataViews.
<br>

<br>
32.5.1
<br>

<br>
new ArrayBuffer()
<br>

<br>
The type signature of the constructor is:
<br>
new ArrayBuffer(length: number)
<br>

<br>
Invoking this constructor via new creates an instance whose capacity is length bytes. Each
<br>
of those bytes is initially 0.
<br>
You can’t change the length of an ArrayBuffer; you can only create a new one with a
<br>
different length.
<br>

<br>
32.5.2 Static methods of ArrayBuffer
<br>
• ArrayBuffer.isView(arg: any)
<br>
Returns true if arg is an object and a view for an ArrayBuffer (i.e., if it is a Typed
<br>
Array or a DataView).
<br>

<br>
32.5.3 Properties of ArrayBuffer.prototype
<br>
• get .byteLength(): number
<br>
Returns the capacity of this ArrayBuffer in bytes.
<br>
• .slice(startIndex: number, endIndex=this.byteLength)
<br>
Creates a new ArrayBuffer that contains the bytes of this ArrayBuffer whose indices are greater than or equal to startIndex and less than endIndex. start and
<br>
endIndex can be negative (see §32.4 “Quick references: indices vs. offsets”).
<br>

<br>
354
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>

<br>
32.6 Quick reference: Typed Arrays
<br>
The properties of the various Typed Array objects are introduced in two steps:
<br>
1. TypedArray: First, we look at the abstract superclass of all Typed Array classes
<br>
(which was shown in the class diagram at the beginning of this chapter). I’m calling that superclass TypedArray, but it is not directly accessible from JavaScript.
<br>
TypedArray.prototype houses all methods of Typed Arrays.
<br>
2. «ElementType»Array: The concrete Typed Array classes are called Uint8Array,
<br>
Int16Array, Float32Array, etc. These are the classes that you use via new, .of,
<br>
and .from().
<br>

<br>
32.6.1 Static methods of TypedArray<T>
<br>
Both static TypedArray methods are inherited by its subclasses (Uint8Array, etc.). TypedArray is abstract. Therefore, you always use these methods via the subclasses, which
<br>
are concrete and can have direct instances.
<br>
• .from<S>(source: Iterable<S>|ArrayLike<S>, mapfn?: S => T, thisArg?:
<br>
any) : instanceof this
<br>

<br>
Converts an iterable (including Arrays and Typed Arrays) or an Array-like object
<br>
to an instance of this (instanceof this is my invention to express that fact).
<br>
assert.deepEqual(
<br>
Uint16Array.from([0, 1, 2]),
<br>
Uint16Array.of(0, 1, 2));
<br>

<br>
The optional mapfn lets you transform the elements of source before they become
<br>
elements of the result.
<br>
assert.deepEqual(
<br>
Int16Array.from(Int8Array.of(127, 126, 125), x => x * 2),
<br>
Int16Array.of(254, 252, 250));
<br>

<br>
• .of(...items: number[]): instanceof this
<br>
Creates a new instance of this whose elements are items (coerced to the element
<br>
type).
<br>
assert.deepEqual(
<br>
Int16Array.of(-1234, 5, 67),
<br>
new Int16Array([-1234, 5, 67]) );
<br>

<br>
32.6.2 Properties of TypedArray<T>.prototype
<br>
Indices accepted by Typed Array methods can be negative (they work like traditional
<br>
Array methods that way). Offsets must be non-negative. For details, see §32.4 “Quick
<br>
references: indices vs. offsets”.
<br>
32.6.2.1 Properties speciﬁc to Typed Arrays
<br>
The following properties are speciﬁc to Typed Arrays; normal Arrays don’t have them:
<br>

<br>
32.6 Quick reference: Typed Arrays
<br>

<br>
355
<br>

<br>
• get .buffer(): ArrayBuffer
<br>
Returns the buffer backing this Typed Array.
<br>
• get .length(): number
<br>
Returns the length in elements of this Typed Array’s buffer.
<br>
• get .byteLength(): number
<br>
Returns the size in bytes of this Typed Array’s buffer.
<br>
• get .byteOffset(): number
<br>
Returns the offset where this Typed Array “starts” inside its ArrayBuffer.
<br>
• .set(typedArray: TypedArray, offset=0): void
<br>
• .set(arrayLike: ArrayLike<number>, offset=0): void
<br>
Copies all elements of the ﬁrst parameter to this Typed Array. The element at index
<br>
0 of the parameter is written to index offset of this Typed Array (etc.). For more
<br>
information on Array-like objects, consult §31.4 “Array-like objects”.
<br>
• .subarray(startIndex=0, endIndex=this.length): TypedArray<T>
<br>
Returns a new Typed Array that has the same buffer as this Typed Array, but a
<br>
(generally) smaller range. If startIndex is non-negative then the ﬁrst element of
<br>
the resulting Typed Array is this[startIndex], the second this[startIndex+1]
<br>
(etc.). If startIndex in negative, it is converted appropriately.
<br>
32.6.2.2 Array methods
<br>
The following methods are basically the same as the methods of normal Arrays:
<br>
• .copyWithin(target: number, start: number, end=this.length): this [W, ES6]
<br>
• .entries(): Iterable<[number, T]> [R, ES6]
<br>
• .every(callback: (value: T, index: number, array: TypedArray<T>) =>
<br>
boolean, thisArg?: any): boolean [R, ES5]
<br>

<br>
• .fill(value: T, start=0, end=this.length): this [W, ES6]
<br>
• .filter(callback: (value: T, index: number, array: TypedArray<T>) =>
<br>
any, thisArg?: any): T[] [R, ES5]
<br>

<br>
• .find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined [R, ES6]
<br>

<br>
• .findIndex(predicate: (value: T, index: number, obj: T[]) => boolean,
<br>
thisArg?: any): number [R, ES6]
<br>

<br>
• .forEach(callback: (value: T, index: number, array: TypedArray<T>) =>
<br>
void, thisArg?: any): void [R, ES5]
<br>

<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
.includes(searchElement: T, fromIndex=0): boolean [R, ES2016]
<br>
.indexOf(searchElement: T, fromIndex=0): number [R, ES5]
<br>
.join(separator = ','): string [R, ES1]
<br>
.keys(): Iterable<number> [R, ES6]
<br>
.lastIndexOf(searchElement: T, fromIndex=this.length-1): number [R, ES5]
<br>
.map<U>(mapFunc: (value: T, index: number, array: TypedArray<T>) => U,
<br>
thisArg?: any): U[] [R, ES5]
<br>

<br>
356
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>

<br>
• .reduce<U>(callback: (accumulator: U, element: T, index: number, array:
<br>
T[]) => U, init?: U): U [R, ES5]
<br>

<br>
• .reduceRight<U>(callback: (accumulator: U, element: T, index: number,
<br>
array: T[]) => U, init?: U): U [R, ES5]
<br>

<br>
• .reverse(): this [W, ES1]
<br>
• .slice(start=0, end=this.length): T[] [R, ES3]
<br>
• .some(callback: (value: T, index: number, array: TypedArray<T>) =>
<br>
boolean, thisArg?: any): boolean [R, ES5]
<br>

<br>
• .sort(compareFunc?: (a: T, b: T) => number): this [W, ES1]
<br>
• .toString(): string [R, ES1]
<br>
• .values(): Iterable<number> [R, ES6]
<br>
For details on how these methods work, please consult §31.12.3 “Methods of Array<T>.prototype”.
<br>

<br>
32.6.3
<br>

<br>
new «ElementType»Array()
<br>

<br>
Each Typed Array constructor has a name that follows the pattern «ElementType»Array,
<br>
where «ElementType» is one of the element types in the table at the beginning. That
<br>
means that there are nine constructors for Typed Arrays:
<br>
• Float32Array, Float64Array
<br>
• Int8Array, Int16Array, Int32Array
<br>
• Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array
<br>
Each constructor has four overloaded versions – it behaves differently depending on how
<br>
many arguments it receives and what their types are:
<br>
• new «ElementType»Array(buffer: ArrayBuffer, byteOffset=0, length=0)
<br>
Creates a new «ElementType»Array whose buffer is buffer. It starts accessing the
<br>
buffer at the given byteOffset and will have the given length. Note that length
<br>
counts elements of the Typed Array (with 1–8 bytes each), not bytes.
<br>
• new «ElementType»Array(length=0)
<br>
Creates a new «ElementType»Array with the given length and the appropriate
<br>
buffer. The buffer’s size in bytes is:
<br>
length * «ElementType»Array.BYTES_PER_ELEMENT
<br>

<br>
• new «ElementType»Array(source: TypedArray)
<br>
Creates a new instance of «ElementType»Array whose elements have the same values as the elements of source, but coerced to ElementType.
<br>
• new «ElementType»Array(source: ArrayLike<number>)
<br>
Creates a new instance of «ElementType»Array whose elements have the same values as the elements of source, but coerced to ElementType. For more information
<br>
on Array-like objects, consult §31.4 “Array-like objects”.
<br>

<br>
32.7 Quick reference: DataViews
<br>

<br>
357
<br>

<br>
32.6.4 Static properties of «ElementType»Array
<br>
• «ElementType»Array.BYTES_PER_ELEMENT: number
<br>
Counts how many bytes are needed to store a single element:
<br>
> Uint8Array.BYTES_PER_ELEMENT
<br>
1
<br>
> Int16Array.BYTES_PER_ELEMENT
<br>
2
<br>
> Float64Array.BYTES_PER_ELEMENT
<br>
8
<br>

<br>
32.6.5 Properties of «ElementType»Array.prototype
<br>
• .BYTES_PER_ELEMENT: number
<br>
The same as «ElementType»Array.BYTES_PER_ELEMENT.
<br>

<br>
32.7 Quick reference: DataViews
<br>
32.7.1
<br>

<br>
new DataView()
<br>

<br>
• newDataView(buffer:ArrayBuffer,byteOffset=0,byteLength=buffer.
<br>
byteLength-byteOffset)
<br>

<br>
Creates a new DataView whose data is stored in the ArrayBuffer buffer. By default, the new DataView can access all of buffer. The last two parameters allow
<br>
you to change that.
<br>

<br>
32.7.2 Properties of DataView.prototype
<br>
In the remainder of this section, «ElementType» refers to either:
<br>
• Float32, Float64
<br>
• Int8, Int16, Int32
<br>
• Uint8, Uint16, Uint32
<br>
These are the properties of DataView.prototype:
<br>
• get .buffer()
<br>
Returns the ArrayBuffer of this DataView.
<br>
• get .byteLength()
<br>
Returns how many bytes can be accessed by this DataView.
<br>
• get .byteOffset()
<br>
Returns at which offset this DataView starts accessing the bytes in its buffer.
<br>
• .get«ElementType»(byteOffset: number, littleEndian=false)
<br>
Reads a value from the buffer of this DataView.
<br>

<br>
358
<br>

<br>
32 Typed Arrays: handling binary data (Advanced)
<br>

<br>
• .set«ElementType»(byteOffset:number,value:number,littleEndian=false)
<br>
Writes value to the buffer of this DataView.
<br>

<br>
Chapter 33
<br>

<br>
Maps (Map)
<br>
Contents
<br>
33.1 Using Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.1.1 Creating Maps . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.1.2 Copying Maps . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.1.3 Working with single entries . . . . . . . . . . . . . . . . . .
<br>
33.1.4 Determining the size of a Map and clearing it . . . . . . . . .
<br>
33.1.5 Getting the keys and values of a Map . . . . . . . . . . . . .
<br>
33.1.6 Getting the entries of a Map . . . . . . . . . . . . . . . . . .
<br>
33.1.7 Listed in insertion order: entries, keys, values . . . . . . . .
<br>
33.1.8 Converting between Maps and Objects . . . . . . . . . . . .
<br>
33.2 Example: Counting characters . . . . . . . . . . . . . . . . . . . . .
<br>
33.3 A few more details about the keys of Maps (advanced) . . . . . . .
<br>
33.3.1 What keys are considered equal? . . . . . . . . . . . . . . . .
<br>
33.4 Missing Map operations . . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.4.1 Mapping and ﬁltering Maps . . . . . . . . . . . . . . . . . .
<br>
33.4.2 Combining Maps . . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.5 Quick reference: Map<K,V> . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.5.1 Constructor . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.5.2 Map<K,V>.prototype: handling single entries . . . . . . . . .
<br>
33.5.3 Map<K,V>.prototype: handling all entries . . . . . . . . . . .
<br>
33.5.4 Map<K,V>.prototype: iterating and looping . . . . . . . . . .
<br>
33.5.5 Sources of this section . . . . . . . . . . . . . . . . . . . . .
<br>
33.6 FAQ: Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
<br>
33.6.1 When should I use a Map, and when should I use an object?
<br>
33.6.2 When would I use an object as a key in a Map? . . . . . . . .
<br>
33.6.3 Why do Maps preserve the insertion order of entries? . . . .
<br>
33.6.4 Why do Maps have a .size, while Arrays have a .length? .
<br>

<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>
.
<br>

<br>
360
<br>
360
<br>
360
<br>
360
<br>
361
<br>
361
<br>
361
<br>
362
<br>
362
<br>
363
<br>
363
<br>
364
<br>
364
<br>
364
<br>
365
<br>
366
<br>
366
<br>
366
<br>
367
<br>
367
<br>
368
<br>
368
<br>
368
<br>
369
<br>
369
<br>
369
<br>

<br>
Before ES6, JavaScript didn’t have a data structure for dictionaries and (ab)used objects
<br>
as dictionaries from strings to arbitrary values. ES6 brought Maps, which are dictionaries
<br>
from arbitrary values to arbitrary values.
<br>
359
<br>

<br>
360
<br>

<br>
33 Maps (Map)
<br>

<br>
33.1 Using Maps
<br>
An instance of Map maps keys to values. A single key-value mapping is called an entry.
<br>

<br>
33.1.1 Creating Maps
<br>
There are three common ways of creating Maps.
<br>
First, you can use the constructor without any parameters to create an empty Map:
<br>
const emptyMap = new Map();
<br>
assert.equal(emptyMap.size, 0);
<br>

<br>
Second, you can pass an iterable (e.g., an Array) over key-value “pairs” (Arrays with two
<br>
elements) to the constructor:
<br>
const map = new Map([
<br>
[1, 'one'],
<br>
[2, 'two'],
<br>
[3, 'three'], // trailing comma is ignored
<br>
]);
<br>

<br>
Third, the .set() method adds entries to a Map and is chainable:
<br>
const map = new Map()
<br>
.set(1, 'one')
<br>
.set(2, 'two')
<br>
.set(3, 'three');
<br>

<br>
33.1.2 Copying Maps
<br>
As we’ll see later, Maps are also iterables over key-value pairs. Therefore, you can use
<br>
the constructor to create a copy of a Map. That copy is shallow: keys and values are the
<br>
same; they are not duplicated.
<br>
const original = new Map()
<br>
.set(false, 'no')
<br>
.set(true, 'yes');
<br>
const copy = new Map(original);
<br>
assert.deepEqual(original, copy);
<br>

<br>
33.1.3 Working with single entries
<br>
.set() and .get() are for writing and reading values (given keys).
<br>
const map = new Map();
<br>
map.set('foo', 123);
<br>
assert.equal(map.get('foo'), 123);
<br>
// Unknown key:
<br>

<br>
33.1 Using Maps
<br>

<br>
361
<br>

<br>
assert.equal(map.get('bar'), undefined);
<br>
// Use the default value '' if an entry is missing:
<br>
assert.equal(map.get('bar') || '', '');
<br>
.has() checks if a Map has an entry with a given key. .delete() removes entries.
<br>
const map = new Map([['foo', 123]]);
<br>
assert.equal(map.has('foo'), true);
<br>
assert.equal(map.delete('foo'), true)
<br>
assert.equal(map.has('foo'), false)
<br>

<br>
33.1.4 Determining the size of a Map and clearing it
<br>
.size contains the number of entries in a Map. .clear() removes all entries of a Map.
<br>
const map = new Map()
<br>
.set('foo', true)
<br>
.set('bar', false)
<br>
;
<br>
assert.equal(map.size, 2)
<br>
map.clear();
<br>
assert.equal(map.size, 0)
<br>

<br>
33.1.5 Getting the keys and values of a Map
<br>
.keys() returns an iterable over the keys of a Map:
<br>
const map = new Map()
<br>
.set(false, 'no')
<br>
.set(true, 'yes')
<br>
;
<br>
for (const key of map.keys()) {
<br>
console.log(key);
<br>
}
<br>
// Output:
<br>
// false
<br>
// true
<br>

<br>
We can use spreading (...) to convert the iterable returned by .keys() to an Array:
<br>
assert.deepEqual(
<br>
[...map.keys()],
<br>
[false, true]);
<br>
.values() works like .keys(), but for values instead of keys.
<br>

<br>
33.1.6 Getting the entries of a Map
<br>
.entries() returns an iterable over the entries of a Map:
<br>

<br>
362
<br>

<br>
33 Maps (Map)
<br>

<br>
const map = new Map()
<br>
.set(false, 'no')
<br>
.set(true, 'yes')
<br>
;
<br>
for (const entry of map.entries()) {
<br>
console.log(entry);
<br>
}
<br>
// Output:
<br>
// [false, 'no']
<br>
// [true, 'yes']
<br>

<br>
Spreading (...) converts the iterable returned by .entries() to an Array:
<br>
assert.deepEqual(
<br>
[...map.entries()],
<br>
[[false, 'no'], [true, 'yes']]);
<br>

<br>
Map instances are also iterables over entries. In the following code, we use destructuring
<br>
to access the keys and values of map:
<br>
for (const [key, value] of map) {
<br>
console.log(key, value);
<br>
}
<br>
// Output:
<br>
// false, 'no'
<br>
// true, 'yes'
<br>

<br>
33.1.7 Listed in insertion order: entries, keys, values
<br>
Maps record in which order entries were created and honor that order when listing entries, keys, or values:
<br>
const map1 = new Map([
<br>
['a', 1],
<br>
['b', 2],
<br>
]);
<br>
assert.deepEqual(
<br>
[...map1.keys()], ['a', 'b']);
<br>
const map2 = new Map([
<br>
['b', 2],
<br>
['a', 1],
<br>
]);
<br>
assert.deepEqual(
<br>
[...map2.keys()], ['b', 'a']);
<br>

<br>
33.1.8 Converting between Maps and Objects
<br>
As long as a Map only uses strings and symbols as keys, you can convert it to an object
<br>
(via Object.fromEntries()):
<br>

<br>
33.2 Example: Counting characters
<br>

<br>
363
<br>

<br>
const map = new Map([
<br>
['a', 1],
<br>
['b', 2],
<br>
]);
<br>
const obj = Object.fromEntries(map);
<br>
assert.deepEqual(
<br>
obj, {a: 1, b: 2});
<br>

<br>
You can also convert an object to a Map with string or symbol keys (via Object.entries()):
<br>
const obj = {
<br>
a: 1,
<br>
b: 2,
<br>
};
<br>
const map = new Map(Object.entries(obj));
<br>
assert.deepEqual(
<br>
map, new Map([['a', 1], ['b', 2]]));
<br>

<br>
33.2 Example: Counting characters
<br>
countChars() returns a Map that maps characters to numbers of occurrences.
<br>
function countChars(chars) {
<br>
const charCounts = new Map();
<br>
for (let ch of chars) {
<br>
ch = ch.toLowerCase();
<br>
const prevCount = charCounts.get(ch) || 0;
<br>
charCounts.set(ch, prevCount+1);
<br>
}
<br>
return charCounts;
<br>
}
<br>
const result = countChars('AaBccc');
<br>
assert.deepEqual(
<br>
[...result],
<br>
[
<br>
['a', 2],
<br>
['b', 1],
<br>
['c', 3],
<br>
]
<br>
);
<br>

<br>
33.3 A few more details about the keys of Maps (advanced)
<br>
Any value can be a key, even an object:
<br>
const map = new Map();
<br>

<br>
364
<br>

<br>
33 Maps (Map)
<br>

<br>
const KEY1 = {};
<br>
const KEY2 = {};
<br>
map.set(KEY1, 'hello');
<br>
map.set(KEY2, 'world');
<br>
assert.equal(map.get(KEY1), 'hello');
<br>
assert.equal(map.get(KEY2), 'world');
<br>

<br>
33.3.1 What keys are considered equal?
<br>
Most Map operations need to check whether a value is equal to one of the keys. They do
<br>
so via the internal operation SameValueZero, which works like === but considers NaN to
<br>
be equal to itself.
<br>
As a consequence, you can use NaN as a key in Maps, just like any other value:
<br>
> const map = new Map();
<br>
> map.set(NaN, 123);
<br>
> map.get(NaN)
<br>
123
<br>

<br>
Different objects are always considered to be different. That is something that can’t be
<br>
changed (yet – conﬁguring key equality is on TC39’s long-term roadmap).
<br>
> new Map().set({}, 1).set({}, 2).size
<br>
2
<br>

<br>
33.4 Missing Map operations
<br>
33.4.1 Mapping and ﬁltering Maps
<br>
You can .map() and .filter() an Array, but there are no such operations for a Map. The
<br>
solution is:
<br>
1. Convert the Map into an Array of [key, value] pairs.
<br>
2. Map or ﬁlter the Array.
<br>
3. Convert the result back to a Map.
<br>
I’ll use the following Map to demonstrate how that works.
<br>
const originalMap = new Map()
<br>
.set(1, 'a')
<br>
.set(2, 'b')
<br>
.set(3, 'c');
<br>

<br>
Mapping originalMap:
<br>
const mappedMap = new Map( // step 3
<br>
[...originalMap] // step 1
<br>
.map(([k, v]) => [k * 2, '_' + v]) // step 2
<br>

<br>
33.4 Missing Map operations
<br>

<br>
365
<br>

<br>
);
<br>
assert.deepEqual([...mappedMap],
<br>
[[2,'_a'], [4,'_b'], [6,'_c']]);
<br>

<br>
Filtering originalMap:
<br>
const filteredMap = new Map( // step 3
<br>
[...originalMap] // step 1
<br>
.filter(([k, v]) => k < 3) // step 2
<br>
);
<br>
assert.deepEqual([...filteredMap],
<br>
[[1,'a'], [2,'b']]);
<br>

<br>
Step 1 is performed by spreading (...) in the Array literal.
<br>

<br>
33.4.2 Combining Maps
<br>
There are no methods for combining Maps, which is why we must use a workaround
<br>
that is similar to the one from the previous section.
<br>
Let’s combine the following two Maps:
<br>
const map1 = new Map()
<br>
.set(1, '1a')
<br>
.set(2, '1b')
<br>
.set(3, '1c')
<br>
;
<br>
const map2 = new Map()
<br>
.set(2, '2b')
<br>
.set(3, '2c')
<br>
.set(4, '2d')
<br>
;
<br>

<br>
To combine map1 and map2, we turn them into Arrays via spreading (...) and concatenate
<br>
those Arrays. Afterward, we convert the result back to a Map. All of that is done in line
<br>
A.
<br>
const combinedMap = new Map([...map1, ...map2]); // (A)
<br>
assert.deepEqual(
<br>
[...combinedMap], // convert to Array for comparison
<br>
[ [ 1, '1a' ],
<br>
[ 2, '2b' ],
<br>
[ 3, '2c' ],
<br>
[ 4, '2d' ] ]
<br>
);
<br>

<br>
Exercise: Combining two Maps
<br>
exercises/maps/combine_maps_test.mjs
<br>

<br>
366
<br>

<br>
33 Maps (Map)
<br>

<br>
33.5 Quick reference: Map<K,V>
<br>
Note: For the sake of conciseness, I’m pretending that all keys have the same type K and
<br>
that all values have the same type V.
<br>

<br>
33.5.1 Constructor
<br>
• new Map<K, V>(entries?: Iterable<[K, V]>) [ES6]
<br>
If you don’t provide the parameter entries, then an empty Map is created. If you
<br>
do provide an iterable over [key, value] pairs, then those pairs are added as entries
<br>
to the Map. For example:
<br>
const map = new Map([
<br>
[ 1, 'one' ],
<br>
[ 2, 'two' ],
<br>
[ 3, 'three' ], // trailing comma is ignored
<br>
]);
<br>

<br>
33.5.2
<br>

<br>
Map<K,V>.prototype: handling single entries
<br>

<br>
• .get(key: K): V [ES6]
<br>
Returns the value that key is mapped to in this Map. If there is no key key in this
<br>
Map, undefined is returned.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
assert.equal(map.get(1), 'one');
<br>
assert.equal(map.get(5), undefined);
<br>

<br>
• .set(key: K, value: V): this [ES6]
<br>
Maps the given key to the given value. If there is already an entry whose key is
<br>
key, it is updated. Otherwise, a new entry is created. This method returns this,
<br>
which means that you can chain it.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
map.set(1, 'ONE!')
<br>
.set(3, 'THREE!');
<br>
assert.deepEqual(
<br>
[...map.entries()],
<br>
[[1, 'ONE!'], [2, 'two'], [3, 'THREE!']]);
<br>

<br>
• .has(key: K): boolean [ES6]
<br>
Returns whether the given key exists in this Map.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
assert.equal(map.has(1), true); // key exists
<br>
assert.equal(map.has(5), false); // key does not exist
<br>

<br>
• .delete(key: K): boolean [ES6]
<br>

<br>
33.5 Quick reference: Map<K,V>
<br>

<br>
367
<br>

<br>
If there is an entry whose key is key, it is removed and true is returned. Otherwise,
<br>
nothing happens and false is returned.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
assert.equal(map.delete(1), true);
<br>
assert.equal(map.delete(5), false); // nothing happens
<br>
assert.deepEqual(
<br>
[...map.entries()],
<br>
[[2, 'two']]);
<br>

<br>
33.5.3
<br>

<br>
Map<K,V>.prototype: handling all entries
<br>

<br>
• get .size: number [ES6]
<br>
Returns how many entries this Map has.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
assert.equal(map.size, 2);
<br>

<br>
• .clear(): void [ES6]
<br>
Removes all entries from this Map.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
assert.equal(map.size, 2);
<br>
map.clear();
<br>
assert.equal(map.size, 0);
<br>

<br>
33.5.4
<br>

<br>
Map<K,V>.prototype: iterating and looping
<br>

<br>
Both iterating and looping happen in the order in which entries were added to a Map.
<br>
• .entries(): Iterable<[K,V]> [ES6]
<br>
Returns an iterable with one [key, value] pair for each entry in this Map. The pairs
<br>
are Arrays of length 2.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
for (const entry of map.entries()) {
<br>
console.log(entry);
<br>
}
<br>
// Output:
<br>
// [1, 'one']
<br>
// [2, 'two']
<br>

<br>
• .forEach(callback: (value: V, key: K, theMap: Map<K,V>) => void, thisArg?: any): void [ES6]
<br>

<br>
The ﬁrst parameter is a callback that is invoked once for each entry in this Map. If
<br>
thisArg is provided, this is set to it for each invocation. Otherwise, this is set to
<br>
undefined.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
map.forEach((value, key) => console.log(value, key));
<br>

<br>
368
<br>

<br>
33 Maps (Map)
<br>
// Output:
<br>
// 'one', 1
<br>
// 'two', 2
<br>

<br>
• .keys(): Iterable<K> [ES6]
<br>
Returns an iterable over all keys in this Map.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
for (const key of map.keys()) {
<br>
console.log(key);
<br>
}
<br>
// Output:
<br>
// 1
<br>
// 2
<br>

<br>
• .values(): Iterable<V> [ES6]
<br>
Returns an iterable over all values in this Map.
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
for (const value of map.values()) {
<br>
console.log(value);
<br>
}
<br>
// Output:
<br>
// 'one'
<br>
// 'two'
<br>

<br>
• [Symbol.iterator](): Iterable<[K,V]> [ES6]
<br>
The default way of iterating over Maps. Same as .entries().
<br>
const map = new Map([[1, 'one'], [2, 'two']]);
<br>
for (const [key, value] of map) {
<br>
console.log(key, value);
<br>
}
<br>
// Output:
<br>
// 1, 'one'
<br>
// 2, 'two'
<br>

<br>
33.5.5 Sources of this section
<br>
• TypeScript’s built-in typings
<br>

<br>
33.6 FAQ: Maps
<br>
33.6.1 When should I use a Map, and when should I use an object?
<br>
If you need a dictionary-like data structure with keys that are neither strings nor symbols,
<br>
you have no choice: you must use a Map.
<br>
If, however, your keys are either strings or symbols, you must decide whether or not to
<br>
use an object. A rough general guideline is:
<br>

<br>
33.6 FAQ: Maps
<br>

<br>
369
<br>

<br>
• Is there a ﬁxed set of keys (known at development time)?
<br>
Then use an object obj and access the values via ﬁxed keys:
<br>
const value = obj.key;
<br>

<br>
• Can the set of keys change at runtime?
<br>
Then use a Map map and access the values via keys stored in variables:
<br>
const theKey = 123;
<br>
map.get(theKey);
<br>

<br>
33.6.2 When would I use an object as a key in a Map?
<br>
You normally want Map keys to be compared by value (two keys are considered equal
<br>
if they have the same content). That excludes objects. However, there is one use case for
<br>
objects as keys: externally attaching data to objects. But that use case is served better by
<br>
WeakMaps, where entries don’t prevent keys from being garbage-collected (for details,
<br>
consult the next chapter).
<br>

<br>
33.6.3 Why do Maps preserve the insertion order of entries?
<br>
In principle, Maps are unordered. The main reason for ordering entries is so that operations that list entries, keys, or values are deterministic. That helps, for example, with
<br>
testing.
<br>

<br>
33.6.4 Why do Maps have a .size, while Arrays have a .length?
<br>
In JavaScript, indexable sequences (such as Arrays and strings) have a .length, while
<br>
unindexed collections (such as Maps and Sets) have a .size:
<br>
• .length is based on indices; it is always the highest index plus one.
<br>
• .size counts the number of elements in a collection.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
370
<br>

<br>
33 Maps (Map)
<br>

<br>
Chapter 34
<br>

<br>
WeakMaps (WeakMap)
<br>
Contents
<br>
34.1 WeakMaps are black boxes . . . . . . . . . . . . . . . . . . . . . . . 371
<br>
34.2 The keys of a WeakMap are weakly held . . . . . . . . . . . . . . . . 372
<br>
34.2.1 All WeakMap keys must be objects . . . . . . . . . . . . . . . 372
<br>
34.2.2 Use case: attaching values to objects . . . . . . . . . . . . . . . 372
<br>
34.3 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
<br>
34.3.1 Caching computed results via WeakMaps . . . . . . . . . . . . 373
<br>
34.3.2 Keeping private data in WeakMaps . . . . . . . . . . . . . . . 373
<br>
34.4 WeakMap API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374
<br>

<br>
WeakMaps are similar to Maps, with the following differences:
<br>
• They are black boxes, where a value can only be accessed if you have both the
<br>
WeakMap and the key.
<br>
• The keys of a WeakMap are weakly held: if an object is a key in a WeakMap, it can
<br>
still be garbage-collected. That lets us use WeakMaps to attach data to objects.
<br>
The next two sections examine in more detail what that means.
<br>

<br>
34.1 WeakMaps are black boxes
<br>
It is impossible to inspect what’s inside a WeakMap:
<br>
• For example, you can’t iterate or loop over keys, values or entries. And you can’t
<br>
compute the size.
<br>
• Additionally, you can’t clear a WeakMap either – you have to create a fresh instance.
<br>
These restrictions enable a security property. Quoting Mark Miller:
<br>
The mapping from weakmap/key pair value can only be observed or affected by someone who has both the weakmap and the key. With clear(),
<br>
371
<br>

<br>
372
<br>

<br>
34 WeakMaps (WeakMap)
<br>

<br>
someone with only the WeakMap would’ve been able to affect the WeakMapand-key-to-value mapping.
<br>

<br>
34.2 The keys of a WeakMap are weakly held
<br>
The keys of a WeakMap are said to be weakly held: Normally if one object refers to another
<br>
one, then the latter object can’t be garbage-collected as long as the former exists. With a
<br>
WeakMap, that is different: If an object is a key and not referred to elsewhere, it can be
<br>
garbage-collected while the WeakMap still exists. That also leads to the corresponding
<br>
entry being removed (but there is no way to observe that).
<br>

<br>
34.2.1 All WeakMap keys must be objects
<br>
All WeakMap keys must be objects. You get an error if you use a primitive value:
<br>
> const wm = new WeakMap();
<br>
> wm.set(123, 'test')
<br>
TypeError: Invalid value used as weak map key
<br>

<br>
With primitive values as keys, WeakMaps wouldn’t be black boxes anymore. But given
<br>
that primitive values are never garbage-collected, you don’t proﬁt from weakly held keys
<br>
anyway, and can just as well use a normal Map.
<br>

<br>
34.2.2 Use case: attaching values to objects
<br>
This is the main use case for WeakMaps: you can use them to externally attach values to
<br>
objects – for example:
<br>
const wm = new WeakMap();
<br>
{
<br>
const obj = {};
<br>
wm.set(obj, 'attachedValue'); // (A)
<br>
}
<br>
// (B)
<br>

<br>
In line A, we attach a value to obj. In line B, obj can already be garbage-collected, even
<br>
though wm still exists. This technique of attaching a value to an object is equivalent to a
<br>
property of that object being stored externally. If wm were a property, the previous code
<br>
would look as follows:
<br>
{
<br>
const obj = {};
<br>
obj.wm = 'attachedValue';
<br>
}
<br>

<br>
34.3 Examples
<br>

<br>
373
<br>

<br>
34.3 Examples
<br>
34.3.1 Caching computed results via WeakMaps
<br>
With WeakMaps, you can associate previously computed results with objects without
<br>
having to worry about memory management. The following function countOwnKeys()
<br>
is an example: it caches previous results in the WeakMap cache.
<br>
const cache = new WeakMap();
<br>
function countOwnKeys(obj) {
<br>
if (cache.has(obj)) {
<br>
return [cache.get(obj), 'cached'];
<br>
} else {
<br>
const count = Object.keys(obj).length;
<br>
cache.set(obj, count);
<br>
return [count, 'computed'];
<br>
}
<br>
}
<br>

<br>
If we use this function with an object obj, you can see that the result is only computed
<br>
for the ﬁrst invocation, while a cached value is used for the second invocation:
<br>
> const obj = { foo: 1, bar: 2};
<br>
> countOwnKeys(obj)
<br>
[2, 'computed']
<br>
> countOwnKeys(obj)
<br>
[2, 'cached']
<br>

<br>
34.3.2 Keeping private data in WeakMaps
<br>
In the following code, the WeakMaps _counter and _action are used to store the values
<br>
of virtual properties of instances of Countdown:
<br>
const _counter = new WeakMap();
<br>
const _action = new WeakMap();
<br>
class Countdown {
<br>
constructor(counter, action) {
<br>
_counter.set(this, counter);
<br>
_action.set(this, action);
<br>
}
<br>
dec() {
<br>
let counter = _counter.get(this);
<br>
counter--;
<br>
_counter.set(this, counter);
<br>
if (counter === 0) {
<br>
_action.get(this)();
<br>
}
<br>
}
<br>
}
<br>

<br>
374
<br>

<br>
34 WeakMaps (WeakMap)
<br>

<br>
// The two pseudo-properties are truly private:
<br>
assert.deepEqual(
<br>
Object.keys(new Countdown()),
<br>
[]);
<br>

<br>
This is how Countdown is used:
<br>
let invoked = false;
<br>
const cd = new Countdown(3, () => invoked = true);
<br>
cd.dec(); assert.equal(invoked, false);
<br>
cd.dec(); assert.equal(invoked, false);
<br>
cd.dec(); assert.equal(invoked, true);
<br>

<br>
Exercise: WeakMaps for private data
<br>
exercises/weakmaps/weakmaps_private_data_test.mjs
<br>

<br>
34.4 WeakMap API
<br>
The constructor and the four methods of WeakMap work the same as their Map equivalents:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
new WeakMap<K, V>(entries?: Iterable<[K, V]>) [ES6]
<br>
.delete(key: K) : boolean [ES6]
<br>
.get(key: K) : V [ES6]
<br>
.has(key: K) : boolean [ES6]
<br>
.set(key: K, value: V) : this [ES6]
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
Chapter 35
<br>

<br>
Sets (Set)
<br>
Contents
<br>
35.1 Using Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376
<br>
35.1.1 Creating Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 376
<br>
35.1.2 Adding, removing, checking membership . . . . . . . . . . . . 376
<br>
35.1.3 Determining the size of a Set and clearing it . . . . . . . . . . . 376
<br>
35.1.4 Iterating over Sets . . . . . . . . . . . . . . . . . . . . . . . . . 377
<br>
35.2 Examples of using Sets . . . . . . . . . . . . . . . . . . . . . . . . . . 377
<br>
35.2.1 Removing duplicates from an Array . . . . . . . . . . . . . . . 377
<br>
35.2.2 Creating a set of Unicode characters (code points) . . . . . . . 377
<br>
35.3 What Set elements are considered equal? . . . . . . . . . . . . . . . 377
<br>
35.4 Missing Set operations . . . . . . . . . . . . . . . . . . . . . . . . . . 378
<br>
35.4.1 Union (a ∪ b) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378
<br>
35.4.2 Intersection (a ∩ b)
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . 378
<br>

<br>
35.4.3 Difference (a \ b) . . . . . . . . . . . . . . . . . . . . . . . . . 379
<br>
35.4.4 Mapping over Sets . . . . . . . . . . . . . . . . . . . . . . . . 379
<br>
35.4.5 Filtering Sets
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . 379
<br>

<br>
35.5 Quick reference: Set<T> . . . . . . . . . . . . . . . . . . . . . . . . . 379
<br>
35.5.1 Constructor . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
<br>
35.5.2 Set<T>.prototype: single Set elements . . . . . . . . . . . . . 379
<br>
35.5.3 Set<T>.prototype: all Set elements . . . . . . . . . . . . . . . 380
<br>
35.5.4 Set<T>.prototype: iterating and looping . . . . . . . . . . . . 380
<br>
35.5.5 Symmetry with Map . . . . . . . . . . . . . . . . . . . . . . . . 381
<br>
35.6 FAQ: Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381
<br>
35.6.1 Why do Sets have a .size, while Arrays have a .length? . . . 381
<br>

<br>
Before ES6, JavaScript didn’t have a data structure for sets. Instead, two workarounds
<br>
were used:
<br>
• The keys of an object were used as a set of strings.
<br>
375
<br>

<br>
376
<br>

<br>
35 Sets (Set)
<br>

<br>
• Arrays were used as sets of arbitrary values. The downside is that checking membership (if an Array contains a value) is slower.
<br>
Since ES6, JavaScript has the data structure Set, which can contain arbitrary values and
<br>
performs membership checks quickly.
<br>

<br>
35.1 Using Sets
<br>
35.1.1 Creating Sets
<br>
There are three common ways of creating Sets.
<br>
First, you can use the constructor without any parameters to create an empty Set:
<br>
const emptySet = new Set();
<br>
assert.equal(emptySet.size, 0);
<br>

<br>
Second, you can pass an iterable (e.g., an Array) to the constructor. The iterated values
<br>
become elements of the new Set:
<br>
const set = new Set(['red', 'green', 'blue']);
<br>

<br>
Third, the .add() method adds elements to a Set and is chainable:
<br>
const set = new Set()
<br>
.add('red')
<br>
.add('green')
<br>
.add('blue');
<br>

<br>
35.1.2 Adding, removing, checking membership
<br>
.add() adds an element to a Set.
<br>
const set = new Set();
<br>
set.add('red');
<br>
.has() checks if an element is a member of a Set.
<br>
assert.equal(set.has('red'), true);
<br>
.delete() removes an element from a Set.
<br>
assert.equal(set.delete('red'), true); // there was a deletion
<br>
assert.equal(set.has('red'), false);
<br>

<br>
35.1.3 Determining the size of a Set and clearing it
<br>
.size contains the number of elements in a Set.
<br>
const set = new Set()
<br>
.add('foo')
<br>
.add('bar');
<br>
assert.equal(set.size, 2)
<br>
.clear() removes all elements of a Set.
<br>

<br>
35.2 Examples of using Sets
<br>

<br>
377
<br>

<br>
set.clear();
<br>
assert.equal(set.size, 0)
<br>

<br>
35.1.4 Iterating over Sets
<br>
Sets are iterable and the for-of loop works as you’d expect:
<br>
const set = new Set(['red', 'green', 'blue']);
<br>
for (const x of set) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'red'
<br>
// 'green'
<br>
// 'blue'
<br>

<br>
As you can see, Sets preserve insertion order. That is, elements are always iterated over in
<br>
the order in which they were added.
<br>
Given that Sets are iterable, you can use spreading (...) to convert them to Arrays:
<br>
const set = new Set(['red', 'green', 'blue']);
<br>
const arr = [...set]; // ['red', 'green', 'blue']
<br>

<br>
35.2 Examples of using Sets
<br>
35.2.1 Removing duplicates from an Array
<br>
Converting an Array to a Set and back, removes duplicates from the Array:
<br>
assert.deepEqual(
<br>
[...new Set([1, 2, 1, 2, 3, 3, 3])],
<br>
[1, 2, 3]);
<br>

<br>
35.2.2 Creating a set of Unicode characters (code points)
<br>
Strings are iterable and can therefore be used as parameters for new Set():
<br>
assert.deepEqual(
<br>
new Set('abc'),
<br>
new Set(['a', 'b', 'c']));
<br>

<br>
35.3 What Set elements are considered equal?
<br>
As with Map keys, Set elements are compared similarly to ===, with the exception of NaN
<br>
being equal to itself.
<br>
> const set = new Set([NaN, NaN, NaN]);
<br>
> set.size
<br>
1
<br>

<br>
378
<br>

<br>
35 Sets (Set)
<br>

<br>
> set.has(NaN)
<br>
true
<br>

<br>
As with ===, two different objects are never considered equal (and there is no way to
<br>
change that at the moment):
<br>
> const set = new Set();
<br>
> set.add({});
<br>
> set.size
<br>
1
<br>
> set.add({});
<br>
> set.size
<br>
2
<br>

<br>
35.4 Missing Set operations
<br>
Sets are missing several common operations. Such an operation can usually be implemented by:
<br>
• Converting the input Sets to Arrays by spreading into Array literals.
<br>
• Performing the operation on Arrays.
<br>
• Converting the result to a Set and returning it.
<br>

<br>
35.4.1 Union (a ∪ b)
<br>
Computing the union of two Sets a and b means creating a Set that contains the elements
<br>
of both a and b.
<br>
const a = new Set([1,2,3]);
<br>
const b = new Set([4,3,2]);
<br>
// Use spreading to concatenate two iterables
<br>
const union = new Set([...a, ...b]);
<br>
assert.deepEqual([...union], [1, 2, 3, 4]);
<br>

<br>
35.4.2 Intersection (a ∩ b)
<br>
Computing the intersection of two Sets a and b means creating a Set that contains those
<br>
elements of a that are also in b.
<br>
const a = new Set([1,2,3]);
<br>
const b = new Set([4,3,2]);
<br>
const intersection = new Set(
<br>
[...a].filter(x => b.has(x)));
<br>
assert.deepEqual([...intersection], [2, 3]);
<br>

<br>
35.5 Quick reference: Set<T>
<br>

<br>
379
<br>

<br>
35.4.3 Difference (a \ b)
<br>
Computing the difference between two Sets a and b means creating a Set that contains
<br>
those elements of a that are not in b. This operation is also sometimes called minus (−).
<br>
const a = new Set([1,2,3]);
<br>
const b = new Set([4,3,2]);
<br>
const difference = new Set(
<br>
[...a].filter(x => !b.has(x)));
<br>
assert.deepEqual([...difference], [1]);
<br>

<br>
35.4.4 Mapping over Sets
<br>
Sets don’t have a method .map(). But we can borrow the one that Arrays have:
<br>
const set = new Set([1, 2, 3]);
<br>
const mappedSet = new Set([...set].map(x => x * 2));
<br>
// Convert mappedSet to an Array to check what’s inside it
<br>
assert.deepEqual([...mappedSet], [2, 4, 6]);
<br>

<br>
35.4.5 Filtering Sets
<br>
We can’t directly .filter() Sets, so we need to use the corresponding Array method:
<br>
const set = new Set([1, 2, 3, 4, 5]);
<br>
const filteredSet = new Set([...set].filter(x => (x % 2) === 0));
<br>
assert.deepEqual([...filteredSet], [2, 4]);
<br>

<br>
35.5 Quick reference: Set<T>
<br>
35.5.1 Constructor
<br>
• new Set<T>(values?: Iterable<T>) [ES6]
<br>
If you don’t provide the parameter values, then an empty Set is created. If you do,
<br>
then the iterated values are added as elements to the Set. For example:
<br>
const set = new Set(['red', 'green', 'blue']);
<br>

<br>
35.5.2
<br>

<br>
Set<T>.prototype: single Set elements
<br>

<br>
• .add(value: T): this [ES6]
<br>
Adds value to this Set. This method returns this, which means that it can be
<br>
chained.
<br>
const set = new Set(['red']);
<br>
set.add('green').add('blue');
<br>
assert.deepEqual([...set], ['red', 'green', 'blue']);
<br>

<br>
380
<br>

<br>
35 Sets (Set)
<br>

<br>
• .delete(value: T): boolean [ES6]
<br>
Removes value from this Set. Returns true if something was deleted and false,
<br>
otherwise.
<br>
const set = new Set(['red', 'green', 'blue']);
<br>
assert.equal(set.delete('red'), true); // there was a deletion
<br>
assert.deepEqual([...set], ['green', 'blue']);
<br>

<br>
• .has(value: T): boolean [ES6]
<br>
Checks whether value is in this Set.
<br>
const set = new Set(['red', 'green']);
<br>
assert.equal(set.has('red'), true);
<br>
assert.equal(set.has('blue'), false);
<br>

<br>
35.5.3
<br>

<br>
Set<T>.prototype: all Set elements
<br>

<br>
• get .size: number [ES6]
<br>
Returns how many elements there are in this Set.
<br>
const set = new Set(['red', 'green', 'blue']);
<br>
assert.equal(set.size, 3);
<br>

<br>
• .clear(): void [ES6]
<br>
Removes all elements from this Set.
<br>
const set = new Set(['red', 'green', 'blue']);
<br>
assert.equal(set.size, 3);
<br>
set.clear();
<br>
assert.equal(set.size, 0);
<br>

<br>
35.5.4
<br>

<br>
Set<T>.prototype: iterating and looping
<br>

<br>
• .values(): Iterable<T> [ES6]
<br>
Returns an iterable over all elements of this Set.
<br>
const set = new Set(['red', 'green']);
<br>
for (const x of set.values()) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'red'
<br>
// 'green'
<br>

<br>
• [Symbol.iterator](): Iterable<T> [ES6]
<br>
Default way of iterating over Sets. Same as .values().
<br>
const set = new Set(['red', 'green']);
<br>
for (const x of set) {
<br>
console.log(x);
<br>

<br>
35.6 FAQ: Sets
<br>

<br>
381
<br>

<br>
}
<br>
// Output:
<br>
// 'red'
<br>
// 'green'
<br>

<br>
• .forEach(callback: (value: T, key: T, theSet: Set<T>) => void, thisArg?:
<br>
any): void [ES6]
<br>

<br>
Feeds each element of this Set to callback(). value and key both contain the current element. This redundancy was introduced so that this callback has the same
<br>
type signature as the callback of Map.prototype.forEach().
<br>
You can specify the this of callback via thisArg. If you omit it, this is undefined.
<br>
const set = new Set(['red', 'green']);
<br>
set.forEach(x => console.log(x));
<br>
// Output:
<br>
// 'red'
<br>
// 'green'
<br>

<br>
35.5.5 Symmetry with Map
<br>
The following two methods mainly exist so that Sets and Maps have similar interfaces.
<br>
Each Set element is handled as if it were a Map entry whose key and value are both the
<br>
element.
<br>
• Set.prototype.entries(): Iterable<[T,T]> [ES6]
<br>
• Set.prototype.keys(): Iterable<T> [ES6]
<br>
.entries() enables you to convert a Set to a Map:
<br>
const set = new Set(['a', 'b', 'c']);
<br>
const map = new Map(set.entries());
<br>
assert.deepEqual(
<br>
[...map.entries()],
<br>
[['a','a'], ['b','b'], ['c','c']]);
<br>

<br>
35.6 FAQ: Sets
<br>
35.6.1 Why do Sets have a .size, while Arrays have a .length?
<br>
The answer to this question is given in §33.6.4 “Why do Maps have a .size, while Arrays
<br>
have a .length?”.
<br>

<br>
Quiz
<br>
See quiz app.
<br>

<br>
382
<br>

<br>
35 Sets (Set)
<br>

<br>
Chapter 36
<br>

<br>
WeakSets (WeakSet)
<br>
Contents
<br>
36.1 Example: Marking objects as safe to use with a method . . . . . . . 383
<br>
36.2 WeakSet API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384
<br>

<br>
WeakSets are similar to Sets, with the following differences:
<br>
• They can hold objects without preventing those objects from being garbagecollected.
<br>
• They are black boxes: we only get any data out of a WeakSet if we have both the
<br>
WeakSet and a value. The only methods that are supported are .add(), .delete(),
<br>
.has(). Consult the section on WeakMaps as black boxes for an explanation of
<br>
why WeakSets don’t allow iteration, looping, and clearing.
<br>
Given that we can’t iterate over their elements, there are not that many use cases for
<br>
WeakSets. They do enable us to mark objects.
<br>

<br>
36.1 Example: Marking objects as safe to use with a
<br>
method
<br>
Domenic Denicola shows how a class Foo can ensure that its methods are only applied
<br>
to instances that were created by it:
<br>
const foos = new WeakSet();
<br>
class Foo {
<br>
constructor() {
<br>
foos.add(this);
<br>
}
<br>
method() {
<br>
if (!foos.has(this)) {
<br>

<br>
383
<br>

<br>
384
<br>

<br>
36 WeakSets (WeakSet)
<br>
throw new TypeError('Incompatible object!');
<br>
}
<br>
}
<br>

<br>
}
<br>
const foo = new Foo();
<br>
foo.method(); // works
<br>
assert.throws(
<br>
() => {
<br>
const obj = {};
<br>
Foo.prototype.method.call(obj); // throws an exception
<br>
},
<br>
TypeError
<br>
);
<br>

<br>
36.2 WeakSet API
<br>
The constructor and the three methods of WeakSet work the same as their Set equivalents:
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
new WeakSet<T>(values?: Iterable<T>) [ES6]
<br>
.add(value: T): this [ES6]
<br>
.delete(value: T): boolean [ES6]
<br>
.has(value: T): boolean [ES6]
<br>

<br>
Chapter 37
<br>

<br>
Destructuring
<br>
Contents
<br>
37.1 A ﬁrst taste of destructuring . . . . . . . . . . . . . . . . . . . . . . . 386
<br>
37.2 Constructing vs. extracting
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . 386
<br>

<br>
37.3 Where can we destructure? . . . . . . . . . . . . . . . . . . . . . . . 387
<br>
37.4 Object-destructuring . . . . . . . . . . . . . . . . . . . . . . . . . . . 388
<br>
37.4.1 Property value shorthands . . . . . . . . . . . . . . . . . . . . 388
<br>
37.4.2 Rest properties . . . . . . . . . . . . . . . . . . . . . . . . . . 389
<br>
37.4.3 Syntax pitfall: assigning via object destructuring . . . . . . . . 389
<br>
37.5 Array-destructuring . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
<br>
37.5.1 Array-destructuring works with any iterable . . . . . . . . . . 390
<br>
37.5.2 Rest elements . . . . . . . . . . . . . . . . . . . . . . . . . . . 390
<br>
37.6 Examples of destructuring . . . . . . . . . . . . . . . . . . . . . . . . 390
<br>
37.6.1 Array-destructuring: swapping variable values
<br>

<br>
. . . . . . . . 390
<br>

<br>
37.6.2 Array-destructuring: operations that return Arrays . . . . . . 391
<br>
37.6.3 Object-destructuring: multiple return values . . . . . . . . . . 391
<br>
37.7 What happens if a pattern part does not match anything? . . . . . . 392
<br>
37.7.1 Object-destructuring and missing properties . . . . . . . . . . 392
<br>
37.7.2 Array-destructuring and missing elements . . . . . . . . . . . 392
<br>
37.8 What values can’t be destructured? . . . . . . . . . . . . . . . . . . . 392
<br>
37.8.1 You can’t object-destructure undefined and null . . . . . . . . 392
<br>
37.8.2 You can’t Array-destructure non-iterable values . . . . . . . . 393
<br>
37.9 (Advanced) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
<br>
37.10Default values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
<br>
37.10.1 Default values in Array-destructuring . . . . . . . . . . . . . . 394
<br>
37.10.2 Default values in object-destructuring . . . . . . . . . . . . . . 394
<br>
37.11Parameter deﬁnitions are similar to destructuring . . . . . . . . . . . 394
<br>
37.12Nested destructuring . . . . . . . . . . . . . . . . . . . . . . . . . . . 395
<br>

<br>
385
<br>

<br>
386
<br>

<br>
37 Destructuring
<br>

<br>
37.1 A ﬁrst taste of destructuring
<br>
With normal assignment, you extract one piece of data at a time – for example:
<br>
const arr = ['a', 'b', 'c'];
<br>
const x = arr[0]; // extract
<br>
const y = arr[1]; // extract
<br>

<br>
With destructuring, you can extract multiple pieces of data at the same time via patterns
<br>
in locations that receive data. The left-hand side of = in the previous code is one such
<br>
location. In the following code, the square brackets in line A are a destructuring pattern:
<br>
const arr = ['a', 'b', 'c'];
<br>
const [x, y] = arr; // (A)
<br>
assert.equal(x, 'a');
<br>
assert.equal(y, 'b');
<br>

<br>
This code does the same as the previous code.
<br>
Note that the pattern is “smaller” than the data: we are only extracting what we need.
<br>

<br>
37.2 Constructing vs. extracting
<br>
In order to understand what destructuring is, consider that JavaScript has two kinds of
<br>
operations that are opposites:
<br>
• You can construct compound data, for example, by setting properties and via object
<br>
literals.
<br>
• You can extract data out of compound data, for example, by getting properties.
<br>
Constructing data looks as follows:
<br>
// Constructing: one property at a time
<br>
const jane1 = {};
<br>
jane1.first = 'Jane';
<br>
jane1.last = 'Doe';
<br>
// Constructing: multiple properties
<br>
const jane2 = {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
};
<br>
assert.deepEqual(jane1, jane2);
<br>

<br>
Extracting data looks as follows:
<br>
const jane = {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
};
<br>

<br>
37.3 Where can we destructure?
<br>

<br>
387
<br>

<br>
// Extracting: one property at a time
<br>
const f1 = jane.first;
<br>
const l1 = jane.last;
<br>
assert.equal(f1, 'Jane');
<br>
assert.equal(l1, 'Doe');
<br>
// Extracting: multiple properties (NEW!)
<br>
const {first: f2, last: l2} = jane; // (A)
<br>
assert.equal(f2, 'Jane');
<br>
assert.equal(l2, 'Doe');
<br>

<br>
The operation in line A is new: we declare two variables f2 and l2 and initialize them
<br>
via destructuring (multivalue extraction).
<br>
The following part of line A is a destructuring pattern:
<br>
{first: f2, last: l2}
<br>

<br>
Destructuring patterns are syntactically similar to the literals that are used for multivalue
<br>
construction. But they appear where data is received (e.g., at the left-hand side of assignments), not where data is created (e.g., at the right-hand side of assignments).
<br>

<br>
37.3 Where can we destructure?
<br>
Destructuring patterns can be used at “data sink locations” such as:
<br>
• Variable declarations:
<br>
const [a] = ['x'];
<br>
assert.equal(a, 'x');
<br>
let [b] = ['y'];
<br>
assert.equal(b, 'y');
<br>

<br>
• Assignments:
<br>
let b;
<br>
[b] = ['z'];
<br>
assert.equal(b, 'z');
<br>

<br>
• Parameter deﬁnitions:
<br>
const f = ([x]) => x;
<br>
assert.equal(f(['a']), 'a');
<br>

<br>
Note that variable declarations include const and let declarations in for-of loops:
<br>
const arr = ['a', 'b'];
<br>
for (const [index, element] of arr.entries()) {
<br>
console.log(index, element);
<br>
}
<br>
// Output:
<br>

<br>
388
<br>

<br>
37 Destructuring
<br>

<br>
// 0, 'a'
<br>
// 1, 'b'
<br>

<br>
In the next two sections, we’ll look deeper into the two kinds of destructuring: objectdestructuring and Array-destructuring.
<br>

<br>
37.4 Object-destructuring
<br>
Object-destructuring lets you batch-extract values of properties via patterns that look like
<br>
object literals:
<br>
const address = {
<br>
street: 'Evergreen Terrace',
<br>
number: '742',
<br>
city: 'Springfield',
<br>
state: 'NT',
<br>
zip: '49007',
<br>
};
<br>
const { street: s, city: c } = address;
<br>
assert.equal(s, 'Evergreen Terrace');
<br>
assert.equal(c, 'Springfield');
<br>

<br>
You can think of the pattern as a transparent sheet that you place over the data: the pattern
<br>
key 'street' has a match in the data. Therefore, the data value 'Evergreen Terrace'
<br>
is assigned to the pattern variable s.
<br>
You can also object-destructure primitive values:
<br>
const {length: len} = 'abc';
<br>
assert.equal(len, 3);
<br>

<br>
And you can object-destructure Arrays:
<br>
const {0:x, 2:y} = ['a', 'b', 'c'];
<br>
assert.equal(x, 'a');
<br>
assert.equal(y, 'c');
<br>

<br>
Why does that work? Array indices are also properties.
<br>

<br>
37.4.1 Property value shorthands
<br>
Object literals support property value shorthands and so do object patterns:
<br>
const { street, city } = address;
<br>
assert.equal(street, 'Evergreen Terrace');
<br>
assert.equal(city, 'Springfield');
<br>

<br>
Exercise: Object-destructuring
<br>
exercises/destructuring/object_destructuring_exrc.mjs
<br>

<br>
37.5 Array-destructuring
<br>

<br>
389
<br>

<br>
37.4.2 Rest properties
<br>
In object literals, you can have spread properties. In object patterns, you can have rest
<br>
properties (which must come last):
<br>
const obj = { a: 1, b: 2, c: 3 };
<br>
const { a: propValue, ...remaining } = obj; // (A)
<br>
assert.equal(propValue, 1);
<br>
assert.deepEqual(remaining, {b:2, c:3});
<br>

<br>
A rest property variable, such as remaining (line A), is assigned an object with all data
<br>
properties whose keys are not mentioned in the pattern.
<br>
remaining can also be viewed as the result of non-destructively removing property a
<br>

<br>
from obj.
<br>

<br>
37.4.3 Syntax pitfall: assigning via object destructuring
<br>
If we object-destructure in an assignment, we are facing a pitfall caused by syntactic ambiguity – you can’t start a statement with a curly brace because then JavaScript thinks
<br>
you are starting a block:
<br>
let prop;
<br>
assert.throws(
<br>
() => eval("{prop} = { prop: 'hello' };"),
<br>
{
<br>
name: 'SyntaxError',
<br>
message: 'Unexpected token =',
<br>
});
<br>

<br>
Why eval()?
<br>
eval() delays parsing (and therefore the SyntaxError) until the callback of assert.throws() is executed. If we didn’t use it, we’d already get an error when this
<br>

<br>
code is parsed and assert.throws() wouldn’t even be executed.
<br>
The workaround is to put the whole assignment in parentheses:
<br>
let prop;
<br>
({prop} = { prop: 'hello' });
<br>
assert.equal(prop, 'hello');
<br>

<br>
37.5 Array-destructuring
<br>
Array-destructuring lets you batch-extract values of Array elements via patterns that look
<br>
like Array literals:
<br>
const [x, y] = ['a', 'b'];
<br>
assert.equal(x, 'a');
<br>

<br>
390
<br>

<br>
37 Destructuring
<br>

<br>
assert.equal(y, 'b');
<br>

<br>
You can skip elements by mentioning holes inside Array patterns:
<br>
const [, x, y] = ['a', 'b', 'c']; // (A)
<br>
assert.equal(x, 'b');
<br>
assert.equal(y, 'c');
<br>

<br>
The ﬁrst element of the Array pattern in line A is a hole, which is why the Array element
<br>
at index 0 is ignored.
<br>

<br>
37.5.1 Array-destructuring works with any iterable
<br>
Array-destructuring can be applied to any value that is iterable, not just to Arrays:
<br>
// Sets are iterable
<br>
const mySet = new Set().add('a').add('b').add('c');
<br>
const [first, second] = mySet;
<br>
assert.equal(first, 'a');
<br>
assert.equal(second, 'b');
<br>
// Strings are iterable
<br>
const [a, b] = 'xyz';
<br>
assert.equal(a, 'x');
<br>
assert.equal(b, 'y');
<br>

<br>
37.5.2 Rest elements
<br>
In Array literals, you can have spread elements. In Array patterns, you can have rest
<br>
elements (which must come last):
<br>
const [x, y, ...remaining] = ['a', 'b', 'c', 'd']; // (A)
<br>
assert.equal(x, 'a');
<br>
assert.equal(y, 'b');
<br>
assert.deepEqual(remaining, ['c', 'd']);
<br>

<br>
A rest element variable, such as remaining (line A), is assigned an Array with all elements
<br>
of the destructured value that were not mentioned yet.
<br>

<br>
37.6 Examples of destructuring
<br>
37.6.1 Array-destructuring: swapping variable values
<br>
You can use Array-destructuring to swap the values of two variables without needing a
<br>
temporary variable:
<br>
let x = 'a';
<br>
let y = 'b';
<br>
[x,y] = [y,x]; // swap
<br>

<br>
37.6 Examples of destructuring
<br>

<br>
391
<br>

<br>
assert.equal(x, 'b');
<br>
assert.equal(y, 'a');
<br>

<br>
37.6.2 Array-destructuring: operations that return Arrays
<br>
Array-destructuring is useful when operations return Arrays, as does, for example, the
<br>
regular expression method .exec():
<br>
// Skip the element at index 0 (the whole match):
<br>
const [, year, month, day] =
<br>
/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/
<br>
.exec('2999-12-31');
<br>
assert.equal(year, '2999');
<br>
assert.equal(month, '12');
<br>
assert.equal(day, '31');
<br>

<br>
37.6.3 Object-destructuring: multiple return values
<br>
Destructuring is very useful if a function returns multiple values – either packaged as an
<br>
Array or packaged as an object.
<br>
Consider a function findElement() that ﬁnds elements in an Array:
<br>
findElement(array, (value, index) => «boolean expression»)
<br>

<br>
Its second parameter is a function that receives the value and index of an element and
<br>
returns a boolean indicating if this is the element the caller is looking for.
<br>
We are now faced with a dilemma: Should findElement() return the value of the element
<br>
it found or the index? One solution would be to create two separate functions, but that
<br>
would result in duplicated code because both functions would be very similar.
<br>
The following implementation avoids duplication by returning an object that contains
<br>
both index and value of the element that is found:
<br>
function findElement(arr, predicate) {
<br>
for (let index=0; index < arr.length; index++) {
<br>
const value = arr[index];
<br>
if (predicate(value)) {
<br>
// We found something:
<br>
return { value, index };
<br>
}
<br>
}
<br>
// We didn’t find anything:
<br>
return { value: undefined, index: -1 };
<br>
}
<br>

<br>
Destructuring helps us with processing the result of findElement():
<br>
const arr = [7, 8, 6];
<br>

<br>
392
<br>

<br>
37 Destructuring
<br>

<br>
const {value, index} = findElement(arr, x => x % 2 === 0);
<br>
assert.equal(value, 8);
<br>
assert.equal(index, 1);
<br>

<br>
As we are working with property keys, the order in which we mention value and index
<br>
doesn’t matter:
<br>
const {index, value} = findElement(arr, x => x % 2 === 0);
<br>

<br>
The kicker is that destructuring also serves us well if we are only interested in one of the
<br>
two results:
<br>
const arr = [7, 8, 6];
<br>
const {value} = findElement(arr, x => x % 2 === 0);
<br>
assert.equal(value, 8);
<br>
const {index} = findElement(arr, x => x % 2 === 0);
<br>
assert.equal(index, 1);
<br>

<br>
All of these conveniences combined make this way of handling multiple return values
<br>
quite versatile.
<br>

<br>
37.7 What happens if a pattern part does not match anything?
<br>
What happens if there is no match for part of a pattern? The same thing that happens if
<br>
you use non-batch operators: you get undefined.
<br>

<br>
37.7.1 Object-destructuring and missing properties
<br>
If a property in an object pattern has no match on the right-hand side, you get undefined:
<br>
const {prop: p} = {};
<br>
assert.equal(p, undefined);
<br>

<br>
37.7.2 Array-destructuring and missing elements
<br>
If an element in an Array pattern has no match on the right-hand side, you get undefined:
<br>
const [x] = [];
<br>
assert.equal(x, undefined);
<br>

<br>
37.8 What values can’t be destructured?
<br>
37.8.1 You can’t object-destructure undefined and null
<br>
Object-destructuring only fails if the value to be destructured is either undefined or null.
<br>
That is, it fails whenever accessing a property via the dot operator would fail too.
<br>

<br>
37.9 (Advanced)
<br>

<br>
393
<br>

<br>
assert.throws(
<br>
() => { const {prop} = undefined; },
<br>
{
<br>
name: 'TypeError',
<br>
message: "Cannot destructure property `prop` of " +
<br>
"'undefined' or 'null'.",
<br>
}
<br>
);
<br>
assert.throws(
<br>
() => { const {prop} = null; },
<br>
{
<br>
name: 'TypeError',
<br>
message: "Cannot destructure property `prop` of " +
<br>
"'undefined' or 'null'.",
<br>
}
<br>
);
<br>

<br>
37.8.2 You can’t Array-destructure non-iterable values
<br>
Array-destructuring demands that the destructured value be iterable. Therefore,
<br>
you can’t Array-destructure undefined and null. But you can’t Array-destructure
<br>
non-iterable objects either:
<br>
assert.throws(
<br>
() => { const [x] = {}; },
<br>
{
<br>
name: 'TypeError',
<br>
message: '{} is not iterable',
<br>
}
<br>
);
<br>

<br>
Quiz: basic
<br>
See quiz app.
<br>

<br>
37.9 (Advanced)
<br>
All of the remaining sections are advanced.
<br>

<br>
37.10 Default values
<br>
Normally, if a pattern has no match, the corresponding variable is set to undefined:
<br>
const {prop: p} = {};
<br>
assert.equal(p, undefined);
<br>

<br>
If you want a different value to be used, you need to specify a default value (via =):
<br>

<br>
394
<br>

<br>
37 Destructuring
<br>

<br>
const {prop: p = 123} = {}; // (A)
<br>
assert.equal(p, 123);
<br>

<br>
In line A, we specify the default value for p to be 123. That default is used because the
<br>
data that we are destructuring has no property named prop.
<br>

<br>
37.10.1 Default values in Array-destructuring
<br>
Here, we have two default values that are assigned to the variables x and y because the
<br>
corresponding elements don’t exist in the Array that is destructured.
<br>
const [x=1, y=2] = [];
<br>
assert.equal(x, 1);
<br>
assert.equal(y, 2);
<br>

<br>
The default value for the ﬁrst element of the Array pattern is 1; the default value for the
<br>
second element is 2.
<br>

<br>
37.10.2 Default values in object-destructuring
<br>
You can also specify default values for object-destructuring:
<br>
const {first: f='', last: l=''} = {};
<br>
assert.equal(f, '');
<br>
assert.equal(l, '');
<br>

<br>
Neither property key first nor property key last exist in the object that is destructured.
<br>
Therefore, the default values are used.
<br>
With property value shorthands, this code becomes simpler:
<br>
const {first='', last=''} = {};
<br>
assert.equal(first, '');
<br>
assert.equal(last, '');
<br>

<br>
37.11 Parameter deﬁnitions are similar to destructuring
<br>
Considering what we have learned in this chapter, parameter deﬁnitions have much in
<br>
common with an Array pattern (rest elements, default values, etc.). In fact, the following
<br>
two function declarations are equivalent:
<br>
function f1(«pattern1», «pattern2») {
<br>
// ···
<br>
}
<br>
function f2(...args) {
<br>
const [«pattern1», «pattern2»] = args;
<br>
// ···
<br>
}
<br>

<br>
37.12 Nested destructuring
<br>

<br>
395
<br>

<br>
37.12 Nested destructuring
<br>
Until now, we have only used variables as assignment targets (data sinks) inside destructuring patterns. But you can also use patterns as assignment targets, which enables you
<br>
to nest patterns to arbitrary depths:
<br>
const arr = [
<br>
{ first: 'Jane', last: 'Bond' },
<br>
{ first: 'Lars', last: 'Croft' },
<br>
];
<br>
const [, {first}] = arr;
<br>
assert.equal(first, 'Lars');
<br>

<br>
Inside the Array pattern in line A, there is a nested object pattern at index 1.
<br>
Nested patterns can become difﬁcult to understand, so they are best used in moderation.
<br>

<br>
Quiz: advanced
<br>
See quiz app.
<br>

<br>
396
<br>

<br>
37 Destructuring
<br>

<br>
Chapter 38
<br>

<br>
Synchronous generators
<br>
(advanced)
<br>
Contents
<br>
38.1 What are synchronous generators? . . . . . . . . . . . . . . . . . . . 397
<br>
38.1.1 Generator functions return iterables and ﬁll them via yield . . 398
<br>
38.1.2 yield pauses a generator function . . . . . . . . . . . . . . . . 398
<br>
38.1.3 Why does yield pause execution? . . . . . . . . . . . . . . . . 400
<br>
38.1.4 Example: Mapping over iterables . . . . . . . . . . . . . . . . 401
<br>
38.2 Calling generators from generators (advanced) . . . . . . . . . . . . 401
<br>
38.2.1 Calling generators via yield* . . . . . . . . . . . . . . . . . . 401
<br>
38.2.2 Example: Iterating over a tree . . . . . . . . . . . . . . . . . . 402
<br>
38.3 Background: external iteration vs. internal iteration . . . . . . . . . 403
<br>
38.4 Use case for generators: reusing traversals . . . . . . . . . . . . . . . 404
<br>
38.4.1 The traversal to reuse . . . . . . . . . . . . . . . . . . . . . . . 404
<br>
38.4.2 Internal iteration (push) . . . . . . . . . . . . . . . . . . . . . 404
<br>
38.4.3 External iteration (pull) . . . . . . . . . . . . . . . . . . . . . . 405
<br>
38.5 Advanced features of generators . . . . . . . . . . . . . . . . . . . . 405
<br>

<br>
38.1 What are synchronous generators?
<br>
Synchronous generators are special versions of function deﬁnitions and method deﬁnitions that always return synchronous iterables:
<br>
// Generator function declaration
<br>
function* genFunc1() { /*···*/ }
<br>
// Generator function expression
<br>
const genFunc2 = function* () { /*···*/ };
<br>

<br>
397
<br>

<br>
398
<br>

<br>
38 Synchronous generators (advanced)
<br>

<br>
// Generator method definition in an object literal
<br>
const obj = {
<br>
* generatorMethod() {
<br>
// ···
<br>
}
<br>
};
<br>
// Generator method definition in a class definition
<br>
// (class declaration or class expression)
<br>
class MyClass {
<br>
* generatorMethod() {
<br>
// ···
<br>
}
<br>
}
<br>

<br>
Asterisks (*) mark functions and methods as generators:
<br>
• Functions: The pseudo-keyword function* is a combination of the keyword function and an asterisk.
<br>
• Methods: The * is a modiﬁer (similar to static and get).
<br>

<br>
38.1.1 Generator functions return iterables and ﬁll them via yield
<br>
If you call a generator function, it returns an iterable (actually, an iterator that is also
<br>
iterable). The generator ﬁlls that iterable via the yield operator:
<br>
function* genFunc1() {
<br>
yield 'a';
<br>
yield 'b';
<br>
}
<br>
const iterable = genFunc1();
<br>
// Convert the iterable to an Array, to check what’s inside:
<br>
assert.deepEqual([...iterable], ['a', 'b']);
<br>
// You can also use a for-of loop
<br>
for (const x of genFunc1()) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
38.1.2
<br>

<br>
yield pauses a generator function
<br>

<br>
Using a generator function involves the following steps:
<br>
• Function-calling it returns an iterator iter (that is also an iterable).
<br>
• Iterating over iter repeatedly invokes iter.next(). Each time, we jump into the
<br>
body of the generator function until there is a yield that returns a value.
<br>

<br>
38.1 What are synchronous generators?
<br>

<br>
399
<br>

<br>
Therefore, yield does more than just add values to iterables – it also pauses and exits the
<br>
generator function:
<br>
• Like return, a yield exits the body of the function and returns a value (via
<br>
.next()).
<br>
• Unlike return, if you repeat the invocation (of .next()), execution resumes directly after the yield.
<br>
Let’s examine what that means via the following generator function.
<br>
let location = 0;
<br>
function* genFunc2() {
<br>
location = 1; yield 'a';
<br>
location = 2; yield 'b';
<br>
location = 3;
<br>
}
<br>

<br>
In order to use genFunc2(), we must ﬁrst create the iterator/iterable iter. genFunc2()
<br>
is now paused “before” its body.
<br>
const iter = genFunc2();
<br>
// genFunc2() is now paused “before” its body:
<br>
assert.equal(location, 0);
<br>
iter implements the iteration protocol. Therefore, we control the execution of genFunc2() via iter.next(). Calling that method resumes the paused genFunc2() and ex-
<br>

<br>
ecutes it until there is a yield. Then execution pauses and .next() returns the operand
<br>
of the yield:
<br>
assert.deepEqual(
<br>
iter.next(), {value: 'a', done: false});
<br>
// genFunc2() is now paused directly after the first `yield`:
<br>
assert.equal(location, 1);
<br>

<br>
Note that the yielded value 'a' is wrapped in an object, which is how iterators always
<br>
deliver their values.
<br>
We call iter.next() again and execution continues where we previously paused. Once
<br>
we encounter the second yield, genFunc2() is paused and .next() returns the yielded
<br>
value 'b'.
<br>
assert.deepEqual(
<br>
iter.next(), {value: 'b', done: false});
<br>
// genFunc2() is now paused directly after the second `yield`:
<br>
assert.equal(location, 2);
<br>

<br>
We call iter.next() one more time and execution continues until it leaves the body of
<br>
genFunc2():
<br>
assert.deepEqual(
<br>
iter.next(), {value: undefined, done: true});
<br>
// We have reached the end of genFunc2():
<br>
assert.equal(location, 3);
<br>

<br>
400
<br>

<br>
38 Synchronous generators (advanced)
<br>

<br>
This time, property .done of the result of .next() is true, which means that the iterator
<br>
is ﬁnished.
<br>

<br>
38.1.3 Why does yield pause execution?
<br>
What are the beneﬁts of yield pausing execution? Why doesn’t it simply work like the
<br>
Array method .push() and ﬁll the iterable with values without pausing?
<br>
Due to pausing, generators provide many of the features of coroutines (think processes
<br>
that are multitasked cooperatively). For example, when you ask for the next value of an
<br>
iterable, that value is computed lazily (on demand). The following two generator functions demonstrate what that means.
<br>
/**
<br>
* Returns an iterable over lines
<br>
*/
<br>
function* genLines() {
<br>
yield 'A line';
<br>
yield 'Another line';
<br>
yield 'Last line';
<br>
}
<br>
/**
<br>
* Input: iterable over lines
<br>
* Output: iterable over numbered lines
<br>
*/
<br>
function* numberLines(lineIterable) {
<br>
let lineNumber = 1;
<br>
for (const line of lineIterable) { // input
<br>
yield lineNumber + ': ' + line; // output
<br>
lineNumber++;
<br>
}
<br>
}
<br>

<br>
Note that the yield in numberLines() appears inside a for-of loop. yield can be used
<br>
inside loops, but not inside callbacks (more on that later).
<br>
Let’s combine both generators to produce the iterable numberedLines:
<br>
const numberedLines = numberLines(genLines());
<br>
assert.deepEqual(
<br>
numberedLines.next(), {value: '1: A line', done: false});
<br>
assert.deepEqual(
<br>
numberedLines.next(), {value: '2: Another line', done: false});
<br>

<br>
The key beneﬁt of using generators here is that everything works incrementally: via numberedLines.next(), we ask numberLines() for only a single numbered line. In turn, it
<br>
asks genLines() for only a single unnumbered line.
<br>
This incrementalism continues to work if, for example, genLines() reads its lines from
<br>
a large text ﬁle: If we ask numberLines() for a numbered line, we get one as soon as
<br>
genLines() has read its ﬁrst line from the text ﬁle.
<br>

<br>
38.2 Calling generators from generators (advanced)
<br>

<br>
401
<br>

<br>
Without generators, genLines() would ﬁrst read all lines and return them. Then numberLines() would number all lines and return them. We therefore have to wait much
<br>
longer until we get the ﬁrst numbered line.
<br>

<br>
Exercise: Turning a normal function into a generator
<br>
exercises/sync-generators/fib_seq_test.mjs
<br>

<br>
38.1.4 Example: Mapping over iterables
<br>
The following function mapIter() is similar to the Array method .map(), but it returns
<br>
an iterable, not an Array, and produces its results on demand.
<br>
function* mapIter(iterable, func) {
<br>
let index = 0;
<br>
for (const x of iterable) {
<br>
yield func(x, index);
<br>
index++;
<br>
}
<br>
}
<br>
const iterable = mapIter(['a', 'b'], x => x + x);
<br>
assert.deepEqual([...iterable], ['aa', 'bb']);
<br>

<br>
Exercise: Filtering iterables
<br>
exercises/sync-generators/filter_iter_gen_test.mjs
<br>

<br>
38.2 Calling generators from generators (advanced)
<br>
38.2.1 Calling generators via yield*
<br>
yield only works directly inside generators – so far we haven’t seen a way of delegating
<br>
yielding to another function or method.
<br>

<br>
Let’s ﬁrst examine what does not work: in the following example, we’d like foo() to call
<br>
bar(), so that the latter yields two values for the former. Alas, a naive approach fails:
<br>
function* bar() {
<br>
yield 'a';
<br>
yield 'b';
<br>
}
<br>
function* foo() {
<br>
// Nothing happens if we call `bar()`:
<br>
bar();
<br>
}
<br>
assert.deepEqual(
<br>
[...foo()], []);
<br>

<br>
402
<br>

<br>
38 Synchronous generators (advanced)
<br>

<br>
Why doesn’t this work? The function call bar() returns an iterable, which we ignore.
<br>
What we want is for foo() to yield everything that is yielded by bar(). That’s what the
<br>
yield* operator does:
<br>
function* bar() {
<br>
yield 'a';
<br>
yield 'b';
<br>
}
<br>
function* foo() {
<br>
yield* bar();
<br>
}
<br>
assert.deepEqual(
<br>
[...foo()], ['a', 'b']);
<br>

<br>
In other words, the previous foo() is roughly equivalent to:
<br>
function* foo() {
<br>
for (const x of bar()) {
<br>
yield x;
<br>
}
<br>
}
<br>

<br>
Note that yield* works with any iterable:
<br>
function* gen() {
<br>
yield* [1, 2];
<br>
}
<br>
assert.deepEqual(
<br>
[...gen()], [1, 2]);
<br>

<br>
38.2.2 Example: Iterating over a tree
<br>
yield* lets us make recursive calls in generators, which is useful when iterating over
<br>

<br>
recursive data structures such as trees. Take, for example, the following data structure
<br>
for binary trees.
<br>
class BinaryTree {
<br>
constructor(value, left=null, right=null) {
<br>
this.value = value;
<br>
this.left = left;
<br>
this.right = right;
<br>
}
<br>
/** Prefix iteration: parent before children */
<br>
* [Symbol.iterator]() {
<br>
yield this.value;
<br>
if (this.left) {
<br>
// Same as yield* this.left[Symbol.iterator]()
<br>
yield* this.left;
<br>
}
<br>
if (this.right) {
<br>

<br>
38.3 Background: external iteration vs. internal iteration
<br>

<br>
403
<br>

<br>
yield* this.right;
<br>
}
<br>
}
<br>
}
<br>

<br>
Method [Symbol.iterator]() adds support for the iteration protocol, which means that
<br>
we can use a for-of loop to iterate over an instance of BinaryTree:
<br>
const tree = new BinaryTree('a',
<br>
new BinaryTree('b',
<br>
new BinaryTree('c'),
<br>
new BinaryTree('d')),
<br>
new BinaryTree('e'));
<br>
for (const x of tree) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>
// 'c'
<br>
// 'd'
<br>
// 'e'
<br>

<br>
Exercise: Iterating over a nested Array
<br>
exercises/sync-generators/iter_nested_arrays_test.mjs
<br>

<br>
38.3 Background: external iteration vs. internal iteration
<br>
In preparation for the next section, we need to learn about two different styles of iterating
<br>
over the values “inside” an object:
<br>
• External iteration (pull): Your code asks the object for the values via an iteration
<br>
protocol. For example, the for-of loop is based on JavaScript’s iteration protocol:
<br>
for (const x of ['a', 'b']) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
• Internal iteration (push): You pass a callback function to a method of the object and
<br>
the method feeds the values to the callback. For example, Arrays have the method
<br>
.forEach():
<br>
['a', 'b'].forEach((x) => {
<br>
console.log(x);
<br>
});
<br>

<br>
404
<br>

<br>
38 Synchronous generators (advanced)
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
The next section has examples for both styles of iteration.
<br>

<br>
38.4 Use case for generators: reusing traversals
<br>
One important use case for generators is extracting and reusing traversals.
<br>

<br>
38.4.1 The traversal to reuse
<br>
As an example, consider the following function that traverses a tree of ﬁles and logs their
<br>
paths (it uses the Node.js API for doing so):
<br>
function logPaths(dir) {
<br>
for (const fileName of fs.readdirSync(dir)) {
<br>
const filePath = path.resolve(dir, fileName);
<br>
console.log(filePath);
<br>
const stats = fs.statSync(filePath);
<br>
if (stats.isDirectory()) {
<br>
logPaths(filePath); // recursive call
<br>
}
<br>
}
<br>
}
<br>

<br>
Consider the following directory:
<br>
mydir/
<br>
a.txt
<br>
b.txt
<br>
subdir/
<br>
c.txt
<br>

<br>
Let’s log the paths inside mydir/:
<br>
logPaths('mydir');
<br>
// Output:
<br>
// 'mydir/a.txt'
<br>
// 'mydir/b.txt'
<br>
// 'mydir/subdir'
<br>
// 'mydir/subdir/c.txt'
<br>

<br>
How can we reuse this traversal and do something other than logging the paths?
<br>

<br>
38.4.2 Internal iteration (push)
<br>
One way of reusing traversal code is via internal iteration: Each traversed value is passsed
<br>
to a callback (line A).
<br>

<br>
38.5 Advanced features of generators
<br>

<br>
405
<br>

<br>
function visitPaths(dir, callback) {
<br>
for (const fileName of fs.readdirSync(dir)) {
<br>
const filePath = path.resolve(dir, fileName);
<br>
callback(filePath); // (A)
<br>
const stats = fs.statSync(filePath);
<br>
if (stats.isDirectory()) {
<br>
visitPaths(filePath, callback);
<br>
}
<br>
}
<br>
}
<br>
const paths = [];
<br>
visitPaths('mydir', p => paths.push(p));
<br>
assert.deepEqual(
<br>
paths,
<br>
[
<br>
'mydir/a.txt',
<br>
'mydir/b.txt',
<br>
'mydir/subdir',
<br>
'mydir/subdir/c.txt',
<br>
]);
<br>

<br>
38.4.3 External iteration (pull)
<br>
Another way of reusing traversal code is via external iteration: We can write a generator
<br>
that yields all traversed values (line A).
<br>
function* iterPaths(dir) {
<br>
for (const fileName of fs.readdirSync(dir)) {
<br>
const filePath = path.resolve(dir, fileName);
<br>
yield filePath; // (A)
<br>
const stats = fs.statSync(filePath);
<br>
if (stats.isDirectory()) {
<br>
yield* iterPaths(filePath);
<br>
}
<br>
}
<br>
}
<br>
const paths = [...iterPaths('mydir')];
<br>

<br>
38.5 Advanced features of generators
<br>
The chapter on generators in Exploring ES6 covers two features that are beyond the scope
<br>
of this book:
<br>
• yield can also receive data, via an argument of .next().
<br>
• Generators can also return values (not just yield them). Such values do not become iteration values, but can be retrieved via yield*.
<br>

<br>
406
<br>

<br>
38 Synchronous generators (advanced)
<br>

<br>
Part VIII
<br>

<br>
Asynchronicity
<br>

<br>
407
<br>

<br>
Chapter 39
<br>

<br>
Asynchronous programming in
<br>
JavaScript
<br>
Contents
<br>
39.1 A roadmap for asynchronous programming in JavaScript . . . . . . 410
<br>
39.1.1 Synchronous functions . . . . . . . . . . . . . . . . . . . . . . 410
<br>
39.1.2 JavaScript executes tasks sequentially in a single process
<br>

<br>
. . . 410
<br>

<br>
39.1.3 Callback-based asynchronous functions . . . . . . . . . . . . . 410
<br>
39.1.4 Promise-based asynchronous functions . . . . . . . . . . . . . 411
<br>
39.1.5 Async functions . . . . . . . . . . . . . . . . . . . . . . . . . . 411
<br>
39.1.6 Next steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
<br>
39.2 The call stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
<br>
39.3 The event loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
<br>
39.4 How to avoid blocking the JavaScript process . . . . . . . . . . . . . 414
<br>
39.4.1 The user interface of the browser can be blocked . . . . . . . . 414
<br>
39.4.2 How can we avoid blocking the browser? . . . . . . . . . . . . 415
<br>
39.4.3 Taking breaks . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
<br>
39.4.4 Run-to-completion semantics
<br>

<br>
. . . . . . . . . . . . . . . . . . 416
<br>

<br>
39.5 Patterns for delivering asynchronous results
<br>

<br>
. . . . . . . . . . . . . 416
<br>

<br>
39.5.1 Delivering asynchronous results via events . . . . . . . . . . . 417
<br>
39.5.2 Delivering asynchronous results via callbacks
<br>

<br>
. . . . . . . . . 419
<br>

<br>
39.6 Asynchronous code: the downsides . . . . . . . . . . . . . . . . . . 419
<br>
39.7 Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
<br>

<br>
This chapter explains the foundations of asynchronous programming in JavaScript.
<br>
409
<br>

<br>
410
<br>

<br>
39 Asynchronous programming in JavaScript
<br>

<br>
39.1 A roadmap for asynchronous programming in
<br>
JavaScript
<br>
This section provides a roadmap for the content on asynchronous programming in
<br>
JavaScript.
<br>

<br>
Don’t worry about the details!
<br>
Don’t worry if you don’t understand everything yet. This is just a quick peek at
<br>
what’s coming up.
<br>

<br>
39.1.1 Synchronous functions
<br>
Normal functions are synchronous: the caller waits until the callee is ﬁnished with its
<br>
computation. divideSync() in line A is a synchronous function call:
<br>
function main() {
<br>
try {
<br>
const result = divideSync(12, 3); // (A)
<br>
assert.equal(result, 4);
<br>
} catch (err) {
<br>
assert.fail(err);
<br>
}
<br>
}
<br>

<br>
39.1.2 JavaScript executes tasks sequentially in a single process
<br>
By default, JavaScript tasks are functions that are executed sequentially in a single process.
<br>
That looks like this:
<br>
while (true) {
<br>
const task = taskQueue.dequeue();
<br>
task(); // run task
<br>
}
<br>

<br>
This loop is also called the event loop because events, such as clicking a mouse, add tasks
<br>
to the queue.
<br>
Due to this style of cooperative multitasking, we don’t want a task to block other tasks
<br>
from being executed while, for example, it waits for results coming from a server. The
<br>
next subsection explores how to handle this case.
<br>

<br>
39.1.3 Callback-based asynchronous functions
<br>
What if divide() needs a server to compute its result? Then the result should be delivered in a different manner: The caller shouldn’t have to wait (synchronously) until the
<br>
result is ready; it should be notiﬁed (asynchronously) when it is. One way of delivering
<br>
the result asynchronously is by giving divide() a callback function that it uses to notify
<br>
the caller.
<br>

<br>
39.1 A roadmap for asynchronous programming in JavaScript
<br>

<br>
411
<br>

<br>
function main() {
<br>
divideCallback(12, 3,
<br>
(err, result) => {
<br>
if (err) {
<br>
assert.fail(err);
<br>
} else {
<br>
assert.equal(result, 4);
<br>
}
<br>
});
<br>
}
<br>

<br>
When there is an asynchronous function call:
<br>
divideCallback(x, y, callback)
<br>

<br>
Then the following steps happen:
<br>
• divideCallback() sends a request to a server.
<br>
• Then the current task main() is ﬁnished and other tasks can be executed.
<br>
• When a response from the server arrives, it is either:
<br>
– An error err: Then the following task is added to the queue.
<br>
taskQueue.enqueue(() => callback(err));
<br>

<br>
– A result r: Then the following task is added to the queue.
<br>
taskQueue.enqueue(() => callback(null, r));
<br>

<br>
39.1.4 Promise-based asynchronous functions
<br>
Promises are two things:
<br>
• A standard pattern that makes working with callbacks easier.
<br>
• The mechanism on which async functions (the topic of the next subsection) are built.
<br>
Invoking a Promise-based function looks as follows.
<br>
function main() {
<br>
dividePromise(12, 3)
<br>
.then(result => assert.equal(result, 4))
<br>
.catch(err => assert.fail(err));
<br>
}
<br>

<br>
39.1.5 Async functions
<br>
One way of looking at async functions is as better syntax for Promise-based code:
<br>
async function main() {
<br>
try {
<br>
const result = await dividePromise(12, 3); // (A)
<br>
assert.equal(result, 4);
<br>
} catch (err) {
<br>
assert.fail(err);
<br>
}
<br>
}
<br>

<br>
412
<br>

<br>
39 Asynchronous programming in JavaScript
<br>

<br>
The dividePromise() we are calling in line A is the same Promise-based function as in
<br>
the previous section. But we now have synchronous-looking syntax for handling the
<br>
call. await can only be used inside a special kind of function, an async function (note the
<br>
keyword async in front of the keyword function). await pauses the current async function and returns from it. Once the awaited result is ready, the execution of the function
<br>
continues where it left off.
<br>

<br>
39.1.6 Next steps
<br>
• In this chapter, we’ll see how synchronous function calls work. We’ll also explore
<br>
JavaScript’s way of executing code in a single process, via its event loop.
<br>
• Asynchronicity via callbacks is also described in this chapter.
<br>
• The following chapters cover Promises and async functions.
<br>
• This series of chapters on asynchronous programming concludes with the chapter
<br>
on asynchronous iteration, which is similar to synchronous iteration, but iterated
<br>
values are delivered asynchronously.
<br>

<br>
39.2 The call stack
<br>
Whenever a function calls another function, we need to remember where to return to
<br>
after the latter function is ﬁnished. That is typically done via a stack – the call stack: the
<br>
caller pushes onto it the location to return to, and the callee jumps to that location after
<br>
it is done.
<br>
This is an example where several calls happen:
<br>
1
<br>

<br>
function h(z) {
<br>
const error = new Error();
<br>

<br>
2
<br>

<br>
console.log(error.stack);
<br>

<br>
3
<br>
4
<br>

<br>
}
<br>

<br>
5
<br>

<br>
function g(y) {
<br>
h(y + 1);
<br>

<br>
6
<br>
7
<br>

<br>
}
<br>

<br>
8
<br>

<br>
function f(x) {
<br>
g(x + 1);
<br>

<br>
9
<br>
10
<br>

<br>
}
<br>

<br>
11
<br>

<br>
f(3);
<br>

<br>
12
<br>

<br>
// done
<br>

<br>
Initially, before running this piece of code, the call stack is empty. After the function call
<br>
f(3) in line 11, the stack has one entry:
<br>
• Line 12 (location in top-level scope)
<br>
After the function call g(x + 1) in line 9, the stack has two entries:
<br>
• Line 10 (location in f())
<br>
• Line 12 (location in top-level scope)
<br>
After the function call h(y + 1) in line 6, the stack has three entries:
<br>

<br>
413
<br>

<br>
39.3 The event loop
<br>

<br>
• Line 7 (location in g())
<br>
• Line 10 (location in f())
<br>
• Line 12 (location in top-level scope)
<br>
Logging error in line 3, produces the following output:
<br>
Error:
<br>
at h (demos/async-js/stack_trace.mjs:2:17)
<br>
at g (demos/async-js/stack_trace.mjs:6:3)
<br>
at f (demos/async-js/stack_trace.mjs:9:3)
<br>
at demos/async-js/stack_trace.mjs:11:1
<br>

<br>
This is a so-called stack trace of where the Error object was created. Note that it records
<br>
where calls were made, not return locations. Creating the exception in line 2 is yet another
<br>
call. That’s why the stack trace includes a location inside h().
<br>
After line 3, each of the functions terminates and each time, the top entry is removed from
<br>
the call stack. After function f is done, we are back in top-level scope and the stack is
<br>
empty. When the code fragment ends then that is like an implicit return. If we consider
<br>
the code fragment to be a task that is executed, then returning with an empty call stack
<br>
ends the task.
<br>

<br>
39.3 The event loop
<br>
By default, JavaScript runs in a single process – in both web browsers and Node.js. The
<br>
so-called event loop sequentially executes tasks (pieces of code) inside that process. The
<br>
event loop is depicted in ﬁg. 39.1.
<br>

<br>
func3
<br>

<br>
running
<br>

<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
func2
<br>
func1
<br>
onTimeout
<br>

<br>
Task sources:
<br>
DOM manipulation
<br>
User interaction
<br>
Networking
<br>
History traversal
<br>
…
<br>

<br>
Call stack
<br>

<br>
Event loop ↺
<br>

<br>
onClick
<br>

<br>
onDone
<br>

<br>
onClick
<br>

<br>
Task queue
<br>
Figure 39.1: Task sources add code to run to the task queue, which is emptied by the event
<br>
loop.
<br>
Two parties access the task queue:
<br>

<br>
414
<br>

<br>
39 Asynchronous programming in JavaScript
<br>

<br>
• Task sources add tasks to the queue. Some of those sources run concurrently to the
<br>
JavaScript process. For example, one task source takes care of user interface events:
<br>
if a user clicks somewhere and a click listener was registered, then an invocation
<br>
of that listener is added to the task queue.
<br>
• The event loop runs continuously inside the JavaScript process. During each loop
<br>
iteration, it takes one task out of the queue (if the queue is empty, it waits until it
<br>
isn’t) and executes it. That task is ﬁnished when the call stack is empty and there
<br>
is a return. Control goes back to the event loop, which then retrieves the next task
<br>
from the queue and executes it. And so on.
<br>
The following JavaScript code is an approximation of the event loop:
<br>
while (true) {
<br>
const task = taskQueue.dequeue();
<br>
task(); // run task
<br>
}
<br>

<br>
39.4 How to avoid blocking the JavaScript process
<br>
39.4.1 The user interface of the browser can be blocked
<br>
Many of the user interface mechanisms of browsers also run in the JavaScript process (as
<br>
tasks). Therefore, long-running JavaScript code can block the user interface. Let’s look
<br>
at a web page that demonstrates that. There are two ways in which you can try out that
<br>
page:
<br>
• You can run it online.
<br>
• You can open the following ﬁle inside the repository with the exercises: demos/
<br>
async-js/blocking.html
<br>

<br>
The following HTML is the page’s user interface:
<br>
<a id="block" href="">Block</a>
<br>
<div id="statusMessage"></div>
<br>
<button>Click me!</button>
<br>

<br>
The idea is that you click “Block” and a long-running loop is executed via JavaScript.
<br>
During that loop, you can’t click the button because the browser/JavaScript process is
<br>
blocked.
<br>
A simpliﬁed version of the JavaScript code looks like this:
<br>
document.getElementById('block')
<br>
.addEventListener('click', doBlock); // (A)
<br>
function doBlock(event) {
<br>
// ···
<br>
displayStatus('Blocking...');
<br>
// ···
<br>
sleep(5000); // (B)
<br>
displayStatus('Done');
<br>

<br>
39.4 How to avoid blocking the JavaScript process
<br>

<br>
415
<br>

<br>
}
<br>
function sleep(milliseconds) {
<br>
const start = Date.now();
<br>
while ((Date.now() - start) < milliseconds);
<br>
}
<br>
function displayStatus(status) {
<br>
document.getElementById('statusMessage')
<br>
.textContent = status;
<br>
}
<br>

<br>
These are the key parts of the code:
<br>
• Line A: We tell the browser to call doBlock() whenever the HTML element is
<br>
clicked whose ID is block.
<br>
• doBlock() displays status information and then calls sleep() to block the
<br>
JavaScript process for 5000 milliseconds (line B).
<br>
• sleep() blocks the JavaScript process by looping until enough time has passed.
<br>
• displayStatus() displays status messages inside the <div> whose ID is statusMessage.
<br>

<br>
39.4.2 How can we avoid blocking the browser?
<br>
There are several ways in which you can prevent a long-running operation from blocking
<br>
the browser:
<br>
• The operation can deliver its result asynchronously: Some operations, such as downloads, can be performed concurrently to the JavaScript process. The JavaScript
<br>
code triggering such an operation registers a callback, which is invoked with the
<br>
result once the operation is ﬁnished. The invocation is handled via the task queue.
<br>
This style of delivering a result is called asynchronous because the caller doesn’t
<br>
wait until the results are ready. Normal function calls deliver their results synchronously.
<br>
• Perform long computations in separate processes: This can be done via so-called
<br>
Web Workers. Web Workers are heavyweight processes that run concurrently to the
<br>
main process. Each one of them has its own runtime environment (global variables,
<br>
etc.). They are completely isolated and must be communicated with via message
<br>
passing. Consult MDN web docs for more information.
<br>
• Take breaks during long computations. The next subsection explains how.
<br>

<br>
39.4.3 Taking breaks
<br>
The following global function executes its parameter callback after a delay of ms milliseconds (the type signature is simpliﬁed – setTimeout() has more features):
<br>
function setTimeout(callback: () => void, ms: number): any
<br>

<br>
The function returns a handle (an ID) that can be used to clear the timeout (cancel the
<br>
execution of the callback) via the following global function:
<br>

<br>
416
<br>

<br>
39 Asynchronous programming in JavaScript
<br>

<br>
function clearTimeout(handle?: any): void
<br>
setTimeout() is available on both browsers and Node.js. The next subsection shows it
<br>

<br>
in action.
<br>

<br>
setTimeout() lets tasks take breaks
<br>

<br>
Another way of looking at setTimeout() is that the current task takes a break and
<br>
continues later via the callback.
<br>

<br>
39.4.4 Run-to-completion semantics
<br>
JavaScript makes a guarantee for tasks:
<br>
Each task is always ﬁnished (“run to completion”) before the next task is
<br>
executed.
<br>
As a consequence, tasks don’t have to worry about their data being changed while they
<br>
are working on it (concurrent modiﬁcation). That simpliﬁes programming in JavaScript.
<br>
The following example demonstrates this guarantee:
<br>
console.log('start');
<br>
setTimeout(() => {
<br>
console.log('callback');
<br>
}, 0);
<br>
console.log('end');
<br>
// Output:
<br>
// 'start'
<br>
// 'end'
<br>
// 'callback'
<br>
setTimeout() puts its parameter into the task queue. The parameter is therefore executed
<br>

<br>
sometime after the current piece of code (task) is completely ﬁnished.
<br>
The parameter ms only speciﬁes when the task is put into the queue, not when exactly it
<br>
runs. It may even never run – for example, if there is a task before it in the queue that
<br>
never terminates. That explains why the previous code logs 'end' before 'callback',
<br>
even though the parameter ms is 0.
<br>

<br>
39.5 Patterns for delivering asynchronous results
<br>
In order to avoid blocking the main process while waiting for a long-running operation to
<br>
ﬁnish, results are often delivered asynchronously in JavaScript. These are three popular
<br>
patterns for doing so:
<br>
• Events
<br>
• Callbacks
<br>
• Promises
<br>

<br>
39.5 Patterns for delivering asynchronous results
<br>

<br>
417
<br>

<br>
The ﬁrst two patterns are explained in the next two subsections. Promises are explained
<br>
in the next chapter.
<br>

<br>
39.5.1 Delivering asynchronous results via events
<br>
Events as a pattern work as follows:
<br>
• They are used to deliver values asynchronously.
<br>
• They do so zero or more times.
<br>
• There are three roles in this pattern:
<br>
– The event (an object) carries the data to be delivered.
<br>
– The event listener is a function that receives events via a parameter.
<br>
– The event source sends events and lets you register event listeners.
<br>
Multiple variations of this pattern exist in the world of JavaScript. We’ll look at three
<br>
examples next.
<br>
39.5.1.1 Events: IndexedDB
<br>
IndexedDB is a database that is built into web browsers. This is an example of using it:
<br>
const openRequest = indexedDB.open('MyDatabase', 1); // (A)
<br>
openRequest.onsuccess = (event) => {
<br>
const db = event.target.result;
<br>
// ···
<br>
};
<br>
openRequest.onerror = (error) => {
<br>
console.error(error);
<br>
};
<br>
indexedDB has an unusual way of invoking operations:
<br>

<br>
• Each operation has an associated method for creating request objects. For example,
<br>
in line A, the operation is “open”, the method is .open(), and the request object is
<br>
openRequest.
<br>
• The parameters for the operation are provided via the request object, not via parameters of the method. For example, the event listeners (functions) are stored in
<br>
the properties .onsuccess and .onerror.
<br>
• The invocation of the operation is added to the task queue via the method (in line
<br>
A). That is, we conﬁgure the operation after its invocation has already been added
<br>
to the queue. Only run-to-completion semantics saves us from race conditions here
<br>
and ensures that the operation runs after the current code fragment is ﬁnished.
<br>
39.5.1.2 Events: XMLHttpRequest
<br>
The XMLHttpRequest API lets us make downloads from within a web browser. This is
<br>
how we download the ﬁle http://example.com/textfile.txt:
<br>

<br>
418
<br>

<br>
39 Asynchronous programming in JavaScript
<br>

<br>
const xhr = new XMLHttpRequest(); // (A)
<br>
xhr.open('GET', 'http://example.com/textfile.txt'); // (B)
<br>
xhr.onload = () => { // (C)
<br>
if (xhr.status == 200) {
<br>
processData(xhr.responseText);
<br>
} else {
<br>
assert.fail(new Error(xhr.statusText));
<br>
}
<br>
};
<br>
xhr.onerror = () => { // (D)
<br>
assert.fail(new Error('Network error'));
<br>
};
<br>
xhr.send(); // (E)
<br>
function processData(str) {
<br>
assert.equal(str, 'Content of textfile.txt\n');
<br>
}
<br>

<br>
With this API, we ﬁrst create a request object (line A), then conﬁgure it, then activate it
<br>
(line E). The conﬁguration consists of:
<br>
• Specifying which HTTP request method to use (line B): GET, POST, PUT, etc.
<br>
• Registering a listener (line C) that is notiﬁed if something could be downloaded.
<br>
Inside the listener, we still need to determine if the download contains what we
<br>
requested or informs us of an error. Note that some of the result data is delivered
<br>
via the request object xhr. (I’m not a fan of this kind of mixing of input and output
<br>
data.)
<br>
• Registering a listener (line D) that is notiﬁed if there was a network error.
<br>

<br>
39.5.1.3 Events: DOM
<br>
We have already seen DOM events in action in §39.4.1 “The user interface of the browser
<br>
can be blocked”. The following code also handles click events:
<br>
const element = document.getElementById('my-link'); // (A)
<br>
element.addEventListener('click', clickListener); // (B)
<br>
function clickListener(event) {
<br>
event.preventDefault(); // (C)
<br>
console.log(event.shiftKey); // (D)
<br>
}
<br>

<br>
We ﬁrst ask the browser to retrieve the HTML element whose ID is 'my-link' (line A).
<br>
Then we add a listener for all click events (line B). In the listener, we ﬁrst tell the browser
<br>
not to perform its default action (line C) – going to the target of the link. Then we log to
<br>
the console if the shift key is currently pressed (line D).
<br>

<br>
419
<br>

<br>
39.6 Asynchronous code: the downsides
<br>

<br>
39.5.2 Delivering asynchronous results via callbacks
<br>
Callbacks are another pattern for handling asynchronous results. They are only used for
<br>
one-off results and have the advantage of being less verbose than events.
<br>
As an example, consider a function readFile() that reads a text ﬁle and returns its contents asynchronously. This is how you call readFile() if it uses Node.js-style callbacks:
<br>
readFile('some-file.txt', {encoding: 'utf8'},
<br>
(error, data) => {
<br>
if (error) {
<br>
assert.fail(error);
<br>
return;
<br>
}
<br>
assert.equal(data, 'The content of some-file.txt\n');
<br>
});
<br>

<br>
There is a single callback that handles both success and failure. If the ﬁrst parameter
<br>
is not null then an error happened. Otherwise, the result can be found in the second
<br>
parameter.
<br>

<br>
Exercises: Callback-based code
<br>
The following exercises use tests for asynchronous code, which are different from
<br>
tests for synchronous code. Consult §11.3.2 “Asynchronous tests in AVA” for more
<br>
information.
<br>
• From synchronous to callback-based code:
<br>

<br>
exercises/async-js/read_
<br>

<br>
file_cb_exrc.mjs
<br>

<br>
• Implementing a callback-based version of .map():
<br>

<br>
exercises/async-
<br>

<br>
js/map_cb_test.mjs
<br>

<br>
39.6 Asynchronous code: the downsides
<br>
In many situations, on either browsers or Node.js, you have no choice, you must use
<br>
asynchronous code. In this chapter, we have seen several patterns that such code can
<br>
use. All of them have two disadvantages:
<br>
• Asynchronous code is more verbose than synchronous code.
<br>
• If you call asynchronous code, your code must become asynchronous too. That’s
<br>
because you can’t wait synchronously for an asynchronous result. Asynchronous
<br>
code has an infectious quality.
<br>
The ﬁrst disadvantage becomes less severe with Promises (covered in the next chapter)
<br>
and mostly disappears with async functions (covered in the chapter after next).
<br>
Alas, the infectiousness of async code does not go away. But it is mitigated by the fact
<br>
that switching between sync and async is easy with async functions.
<br>

<br>
420
<br>

<br>
39 Asynchronous programming in JavaScript
<br>

<br>
39.7 Resources
<br>
• “Help, I’m stuck in an event-loop” by Philip Roberts (video).
<br>
• “Event loops”, section in HTML5 spec.
<br>

<br>
Chapter 40
<br>

<br>
Promises for asynchronous
<br>
programming
<br>
Contents
<br>
40.1 The basics of using Promises . . . . . . . . . . . . . . . . . . . . . . 422
<br>
40.1.1 Using a Promise-based function . . . . . . . . . . . . . . . . . 422
<br>
40.1.2 What is a Promise? . . . . . . . . . . . . . . . . . . . . . . . . 422
<br>
40.1.3 Implementing a Promise-based function
<br>

<br>
. . . . . . . . . . . . 423
<br>

<br>
40.1.4 States of Promises . . . . . . . . . . . . . . . . . . . . . . . . . 423
<br>
40.1.5 Promise.resolve(): create a Promise fulﬁlled with a given value424
<br>
40.1.6 Promise.reject(): create a Promise rejected with a given value 424
<br>
40.1.7 Returning and throwing in .then() callbacks . . . . . . . . . . 424
<br>
40.1.8 .catch() and its callback . . . . . . . . . . . . . . . . . . . . . 426
<br>
40.1.9 Chaining method calls . . . . . . . . . . . . . . . . . . . . . . 426
<br>
40.1.10 Advantages of promises . . . . . . . . . . . . . . . . . . . . . 427
<br>
40.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
<br>
40.2.1 Node.js: Reading a ﬁle asynchronously . . . . . . . . . . . . . 427
<br>
40.2.2 Browsers: Promisifying XMLHttpRequest . . . . . . . . . . . . 429
<br>
40.2.3 Node.js: util.promisify() . . . . . . . . . . . . . . . . . . . 430
<br>
40.2.4 Browsers: Fetch API . . . . . . . . . . . . . . . . . . . . . . . 431
<br>
40.3 Error handling: don’t mix rejections and exceptions . . . . . . . . . 431
<br>
40.4 Promise-based functions start synchronously, settle asynchronously
<br>

<br>
433
<br>

<br>
40.5 Promise.all(): concurrency and Arrays of Promises . . . . . . . . . 434
<br>
40.5.1 Sequential execution vs. concurrent execution . . . . . . . . . 434
<br>
40.5.2 Concurrency tip: focus on when operations start . . . . . . . . 434
<br>
40.5.3 Promise.all() is fork-join . . . . . . . . . . . . . . . . . . . . 435
<br>
40.5.4 Asynchronous .map() via Promise.all() . . . . . . . . . . . . 435
<br>
40.6 Tips for chaining Promises . . . . . . . . . . . . . . . . . . . . . . . 437
<br>
40.6.1 Chaining mistake: losing the tail . . . . . . . . . . . . . . . . . 437
<br>
40.6.2 Chaining mistake: nesting . . . . . . . . . . . . . . . . . . . . 437
<br>

<br>
421
<br>

<br>
422
<br>

<br>
40 Promises for asynchronous programming
<br>
40.6.3 Chaining mistake: more nesting than necessary
<br>

<br>
. . . . . . . . 438
<br>

<br>
40.6.4 Not all nesting is bad . . . . . . . . . . . . . . . . . . . . . . . 438
<br>
40.6.5 Chaining mistake: creating Promises instead of chaining
<br>

<br>
. . . 439
<br>

<br>
40.7 Advanced topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
<br>

<br>
In this chapter, we explore Promises, yet another pattern for delivering asynchronous
<br>
results.
<br>

<br>
Recommended reading
<br>
This chapter builds on the previous chapter with background on asynchronous programming in JavaScript.
<br>

<br>
40.1 The basics of using Promises
<br>
Promises are a pattern for delivering results asynchronously.
<br>

<br>
40.1.1 Using a Promise-based function
<br>
The following code is an example of using the Promise-based function addAsync()
<br>
(whose implementation is shown soon):
<br>
addAsync(3, 4)
<br>
.then(result => { // success
<br>
assert.equal(result, 7);
<br>
})
<br>
.catch(error => { // failure
<br>
assert.fail(error);
<br>
});
<br>

<br>
Promises are similar to the event pattern: There is an object (a Promise), where we register
<br>
callbacks:
<br>
• Method .then() registers callbacks that handle results.
<br>
• Method .catch() registers callbacks that handle errors.
<br>
A Promise-based function returns a Promise and sends it a result or an error (if and when
<br>
it is done). The Promise passes it on to the relevant callbacks.
<br>
In contrast to the event pattern, Promises are optimized for one-off results:
<br>
• A result (or an error) is cached so that it doesn’t matter if we register a callback
<br>
before or after the result (or error) was sent.
<br>
• We can chain the Promise methods .then() and .catch() because they both return
<br>
Promises. That helps with sequentially invoking multiple asynchronous functions.
<br>
More on that later.
<br>

<br>
40.1.2 What is a Promise?
<br>
What is a Promise? There are two ways of looking at it:
<br>

<br>
423
<br>

<br>
40.1 The basics of using Promises
<br>

<br>
• On one hand, it is a placeholder or container for the ﬁnal result that will eventually
<br>
be delivered.
<br>
• On the other hand, it is an object with which we can register listeners.
<br>

<br>
40.1.3 Implementing a Promise-based function
<br>
This is an implementation of a Promise-based function that adds two numbers x and y:
<br>
function addAsync(x, y) {
<br>
return new Promise(
<br>
(resolve, reject) => { // (A)
<br>
if (x === undefined || y === undefined) {
<br>
reject(new Error('Must provide two parameters'));
<br>
} else {
<br>
resolve(x + y);
<br>
}
<br>
});
<br>
}
<br>
addAsync() immediately invokes the Promise constructor. The actual implementation
<br>
of that function resides in the callback that is passed to that constructor (line A). That
<br>
callback is provided with two functions:
<br>

<br>
• resolve is used for delivering a result (in case of success).
<br>
• reject is used for delivering an error (in case of failure).
<br>

<br>
40.1.4 States of Promises
<br>
Settled
<br>
Pending
<br>

<br>
Fulfilled
<br>

<br>
Rejected
<br>

<br>
Figure 40.1: A Promise can be in either one of three states: pending, fulﬁlled, or rejected.
<br>
If a Promise is in a ﬁnal (non-pending) state, it is called settled.
<br>
Fig. 40.1 depicts the three states a Promise can be in. Promises specialize in one-off results
<br>
and protect us against race conditions (registering too early or too late):
<br>
• If we register a .then() callback or a .catch() callback too early, it is notiﬁed once
<br>
a Promise is settled.
<br>
• Once a Promise is settled, the settlement value (result or error) is cached. Thus, if
<br>
.then() or .catch() are called after the settlement, they receive the cached value.
<br>
Additionally, once a Promise is settled, its state and settlement value can’t change anymore. That helps make code predictable and enforces the one-off nature of Promises.
<br>

<br>
424
<br>

<br>
40 Promises for asynchronous programming
<br>

<br>
Some Promises are never settled
<br>
It is possible that a Promise is never settled. For example:
<br>
new Promise(() => {})
<br>

<br>
40.1.5
<br>

<br>
Promise.resolve(): create a Promise fulﬁlled with a given
<br>

<br>
value
<br>
Promise.resolve(x) creates a Promise that is fulﬁlled with the value x:
<br>
Promise.resolve(123)
<br>
.then(x => {
<br>
assert.equal(x, 123);
<br>
});
<br>

<br>
If the parameter is already a Promise, it is returned unchanged:
<br>
const abcPromise = Promise.resolve('abc');
<br>
assert.equal(
<br>
Promise.resolve(abcPromise),
<br>
abcPromise);
<br>

<br>
Therefore, given an arbitrary value x, we can use Promise.resolve(x) to ensure we have
<br>
a Promise.
<br>
Note that the name is resolve, not fulfill, because .resolve() returns a rejected
<br>
Promise if its Parameter is a rejected Promise.
<br>

<br>
40.1.6
<br>

<br>
Promise.reject(): create a Promise rejected with a given value
<br>

<br>
Promise.reject(err) creates a Promise that is rejected with the value err:
<br>
const myError = new Error('My error!');
<br>
Promise.reject(myError)
<br>
.catch(err => {
<br>
assert.equal(err, myError);
<br>
});
<br>

<br>
40.1.7 Returning and throwing in .then() callbacks
<br>
.then() handles Promise fulﬁllments. It also returns a fresh Promise. How that Promise
<br>

<br>
is settled depends on what happens inside the callback. Let’s look at three common cases.
<br>
40.1.7.1 Returning a non-Promise value
<br>
First, the callback can return a non-Promise value (line A). Consequently, the Promise
<br>
returned by .then() is fulﬁlled with that value (as checked in line B):
<br>
Promise.resolve('abc')
<br>
.then(str => {
<br>
return str + str; // (A)
<br>

<br>
40.1 The basics of using Promises
<br>

<br>
425
<br>

<br>
})
<br>
.then(str2 => {
<br>
assert.equal(str2, 'abcabc'); // (B)
<br>
});
<br>

<br>
40.1.7.2 Returning a Promise
<br>
Second, the callback can return a Promise p (line A). Consequently, p “becomes” what
<br>
.then() returns. In other words: the Promise that .then() has already returned is effec-
<br>

<br>
tively replaced by p.
<br>
Promise.resolve('abc')
<br>
.then(str => {
<br>
return Promise.resolve(123); // (A)
<br>
})
<br>
.then(num => {
<br>
assert.equal(num, 123);
<br>
});
<br>

<br>
Why is that useful? We can return the result of a Promise-based operation and process
<br>
its fulﬁllment value via a “ﬂat” (non-nested) .then(). Compare:
<br>
// Flat
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
/*···*/
<br>
return asyncFunc2();
<br>
})
<br>
.then(result2 => {
<br>
/*···*/
<br>
});
<br>
// Nested
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
/*···*/
<br>
asyncFunc2()
<br>
.then(result2 => {
<br>
/*···*/
<br>
});
<br>
});
<br>

<br>
40.1.7.3 Throwing an exception
<br>
Third, the callback can throw an exception. Consequently, the Promise returned by
<br>
.then() is rejected with that exception. That is, a synchronous error is converted into an
<br>
asynchronous error.
<br>
const myError = new Error('My error!');
<br>
Promise.resolve('abc')
<br>
.then(str => {
<br>

<br>
426
<br>

<br>
40 Promises for asynchronous programming
<br>
throw myError;
<br>
})
<br>
.catch(err => {
<br>
assert.equal(err, myError);
<br>
});
<br>

<br>
40.1.8
<br>

<br>
.catch() and its callback
<br>

<br>
The only difference between .then() and .catch() is that the latter is triggered by rejections, not fulﬁllments. However, both methods turn the actions of their callbacks into
<br>
Promises in the same manner. For example, in the following code, the value returned by
<br>
the .catch() callback in line A becomes a fulﬁllment value:
<br>
const err = new Error();
<br>
Promise.reject(err)
<br>
.catch(e => {
<br>
assert.equal(e, err);
<br>
// Something went wrong, use a default value
<br>
return 'default value'; // (A)
<br>
})
<br>
.then(str => {
<br>
assert.equal(str, 'default value');
<br>
});
<br>

<br>
40.1.9 Chaining method calls
<br>
.then() and .catch() always return Promises. That enables us to create arbitrary long
<br>
chains of method calls:
<br>
function myAsyncFunc() {
<br>
return asyncFunc1() // (A)
<br>
.then(result1 => {
<br>
// ···
<br>
return asyncFunc2(); // a Promise
<br>
})
<br>
.then(result2 => {
<br>
// ···
<br>
return result2 || '(Empty)'; // not a Promise
<br>
})
<br>
.then(result3 => {
<br>
// ···
<br>
return asyncFunc4(); // a Promise
<br>
});
<br>
}
<br>

<br>
Due to chaining, the return in line A returns the result of the last .then().
<br>
In a way, .then() is the asynchronous version of the synchronous semicolon:
<br>
• .then() executes two asynchronous operations sequentially.
<br>

<br>
40.2 Examples
<br>

<br>
427
<br>

<br>
• The semicolon executes two synchronous operations sequentially.
<br>
We can also add .catch() into the mix and let it handle multiple error sources at the
<br>
same time:
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
// ···
<br>
return asyncFunction2();
<br>
})
<br>
.then(result2 => {
<br>
// ···
<br>
})
<br>
.catch(error => {
<br>
// Failure: handle errors of asyncFunc1(), asyncFunc2()
<br>
// and any (sync) exceptions thrown in previous callbacks
<br>
});
<br>

<br>
40.1.10 Advantages of promises
<br>
These are some of the advantages of Promises over plain callbacks when it comes to handling one-off results:
<br>
• The type signatures of Promise-based functions and methods are cleaner: if a function is callback-based, some parameters are about input, while the one or two callbacks at the end are about output. With Promises, everything output-related is
<br>
handled via the returned value.
<br>
• Chaining asynchronous processing steps is more convenient.
<br>
• Promises handle both asynchronous errors (via rejections) and synchronous errors:
<br>
Inside the callbacks for new Promise(), .then(), and .catch(), exceptions are converted to rejections. In contrast, if we use callbacks for asynchronicity, exceptions
<br>
are normally not handled for us; we have to do it ourselves.
<br>
• Promises are a single standard that is slowly replacing several, mutually incompatible alternatives. For example, in Node.js, many functions are now available
<br>
in Promise-based versions. And new asynchronous browser APIs are usually
<br>
Promise-based.
<br>
One of the biggest advantages of Promises involves not working with them directly: they
<br>
are the foundation of async functions, a synchronous-looking syntax for performing asynchronous computations. Asynchronous functions are covered in the next chapter.
<br>

<br>
40.2 Examples
<br>
Seeing Promises in action helps with understanding them. Let’s look at examples.
<br>

<br>
40.2.1 Node.js: Reading a ﬁle asynchronously
<br>
Consider the following text ﬁle person.json with JSON data in it:
<br>

<br>
428
<br>

<br>
40 Promises for asynchronous programming
<br>

<br>
{
<br>
"first": "Jane",
<br>
"last": "Doe"
<br>
}
<br>

<br>
Let’s look at two versions of code that reads this ﬁle and parses it into an object. First, a
<br>
callback-based version. Second, a Promise-based version.
<br>
40.2.1.1 The callback-based version
<br>
The following code reads the contents of this ﬁle and converts it to a JavaScript object. It
<br>
is based on Node.js-style callbacks:
<br>
import * as fs from 'fs';
<br>
fs.readFile('person.json',
<br>
(error, text) => {
<br>
if (error) { // (A)
<br>
// Failure
<br>
assert.fail(error);
<br>
} else {
<br>
// Success
<br>
try { // (B)
<br>
const obj = JSON.parse(text); // (C)
<br>
assert.deepEqual(obj, {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
});
<br>
} catch (e) {
<br>
// Invalid JSON
<br>
assert.fail(e);
<br>
}
<br>
}
<br>
});
<br>
fs is a built-in Node.js module for ﬁle system operations. We use the callback-based
<br>

<br>
function fs.readFile() to read a ﬁle whose name is person.json. If we succeed, the
<br>
content is delivered via the parameter text as a string. In line C, we convert that string
<br>
from the text-based data format JSON into a JavaScript object. JSON is an object with
<br>
methods for consuming and producing JSON. It is part of JavaScript’s standard library
<br>
and documented later in this book.
<br>
Note that there are two error-handling mechanisms: the if in line A takes care of asynchronous errors reported by fs.readFile(), while the try in line B takes care of synchronous errors reported by JSON.parse().
<br>
40.2.1.2 The Promise-based version
<br>
The following code uses readFileAsync(), a Promise-based version of fs.readFile()
<br>
(created via util.promisify(), which is explained later):
<br>

<br>
429
<br>

<br>
40.2 Examples
<br>
readFileAsync('person.json')
<br>
.then(text => { // (A)
<br>
// Success
<br>
const obj = JSON.parse(text);
<br>
assert.deepEqual(obj, {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
});
<br>
})
<br>
.catch(err => { // (B)
<br>
// Failure: file I/O error or JSON syntax error
<br>
assert.fail(err);
<br>
});
<br>

<br>
Function readFileAsync() returns a Promise. In line A, we specify a success callback via
<br>
method .then() of that Promise. The remaining code in then’s callback is synchronous.
<br>
.then() returns a Promise, which enables the invocation of the Promise method
<br>
.catch() in line B. We use it to specify a failure callback.
<br>

<br>
Note that .catch() lets us handle both the asynchronous errors of readFileAsync() and
<br>
the synchronous errors of JSON.parse() because exceptions inside a .then() callback
<br>
become rejections.
<br>

<br>
40.2.2 Browsers: Promisifying XMLHttpRequest
<br>
We have previously seen the event-based XMLHttpRequest API for downloading data in
<br>
web browsers. The following function promisiﬁes that API:
<br>
function httpGet(url) {
<br>
return new Promise(
<br>
(resolve, reject) => {
<br>
const xhr = new XMLHttpRequest();
<br>
xhr.onload = () => {
<br>
if (xhr.status === 200) {
<br>
resolve(xhr.responseText); // (A)
<br>
} else {
<br>
// Something went wrong (404, etc.)
<br>
reject(new Error(xhr.statusText)); // (B)
<br>
}
<br>
}
<br>
xhr.onerror = () => {
<br>
reject(new Error('Network error')); // (C)
<br>
};
<br>
xhr.open('GET', url);
<br>
xhr.send();
<br>
});
<br>
}
<br>

<br>
Note how the results and errors of XMLHttpRequest are handled via resolve() and reject():
<br>

<br>
430
<br>

<br>
40 Promises for asynchronous programming
<br>

<br>
• A successful outcome leads to the returned Promise being fullﬁlled with it (line A).
<br>
• An error leads to the Promise being rejected (lines B and C).
<br>
This is how to use httpGet():
<br>
httpGet('http://example.com/textfile.txt')
<br>
.then(content => {
<br>
assert.equal(content, 'Content of textfile.txt\n');
<br>
})
<br>
.catch(error => {
<br>
assert.fail(error);
<br>
});
<br>

<br>
Exercise: Timing out a Promise
<br>
exercises/promises/promise_timeout_test.mjs
<br>

<br>
40.2.3 Node.js: util.promisify()
<br>
util.promisify() is a utility function that converts a callback-based function f into a
<br>

<br>
Promise-based one. That is, we are going from this type signature:
<br>
f(arg_1, ···, arg_n, (err: Error, result: T) => void) : void
<br>

<br>
To this type signature:
<br>
f(arg_1, ···, arg_n) : Promise<T>
<br>

<br>
The following code promisiﬁes the callback-based fs.readFile() (line A) and uses it:
<br>
import * as fs from 'fs';
<br>
import {promisify} from 'util';
<br>
const readFileAsync = promisify(fs.readFile); // (A)
<br>
readFileAsync('some-file.txt', {encoding: 'utf8'})
<br>
.then(text => {
<br>
assert.equal(text, 'The content of some-file.txt\n');
<br>
})
<br>
.catch(err => {
<br>
assert.fail(err);
<br>
});
<br>

<br>
Exercises: util.promisify()
<br>
• Using util.promisify():
<br>

<br>
exercises/promises/read_file_async_exrc.
<br>

<br>
mjs
<br>

<br>
• Implementing util.promisify() yourself:
<br>
promisify_test.mjs
<br>

<br>
exercises/promises/my_
<br>

<br>
40.3 Error handling: don’t mix rejections and exceptions
<br>

<br>
431
<br>

<br>
40.2.4 Browsers: Fetch API
<br>
All modern browsers support Fetch, a new Promise-based API for downloading data.
<br>
Think of it as a Promise-based version of XMLHttpRequest. The following is an excerpt of
<br>
the API:
<br>
interface Body {
<br>
text() : Promise<string>;
<br>
···
<br>
}
<br>
interface Response extends Body {
<br>
···
<br>
}
<br>
declare function fetch(str) : Promise<Response>;
<br>

<br>
That means we can use fetch() as follows:
<br>
fetch('http://example.com/textfile.txt')
<br>
.then(response => response.text())
<br>
.then(text => {
<br>
assert.equal(text, 'Content of textfile.txt\n');
<br>
});
<br>

<br>
Exercise: Using the fetch API
<br>
exercises/promises/fetch_json_test.mjs
<br>

<br>
40.3 Error handling: don’t mix rejections and exceptions
<br>
Rule for implementing functions and methods:
<br>
Don’t mix (asynchronous) rejections and (synchronous) exceptions.
<br>
This makes our synchronous and asynchronous code more predictable and simpler because we can always focus on a single error-handling mechanism.
<br>
For Promise-based functions and methods, the rule means that they should never throw
<br>
exceptions. Alas, it is easy to accidentally get this wrong – for example:
<br>
// Don’t do this
<br>
function asyncFunc() {
<br>
doSomethingSync(); // (A)
<br>
return doSomethingAsync()
<br>
.then(result => {
<br>
// ···
<br>
});
<br>
}
<br>

<br>
The problem is that if an exception is thrown in line A, then asyncFunc() will throw an
<br>
exception. Callers of that function only expect rejections and are not prepared for an
<br>
exception. There are three ways in which we can ﬁx this issue.
<br>

<br>
432
<br>

<br>
40 Promises for asynchronous programming
<br>

<br>
We can wrap the whole body of the function in a try-catch statement and return a rejected Promise if an exception is thrown:
<br>

<br>
// Solution 1
<br>
function asyncFunc() {
<br>
try {
<br>
doSomethingSync();
<br>
return doSomethingAsync()
<br>
.then(result => {
<br>
// ···
<br>
});
<br>
} catch (err) {
<br>
return Promise.reject(err);
<br>
}
<br>
}
<br>

<br>
Given that .then() converts exceptions to rejections, we can execute doSomethingSync()
<br>
inside a .then() callback. To do so, we start a Promise chain via Promise.resolve(). We
<br>
ignore the fulﬁllment value undefined of that initial Promise.
<br>

<br>
// Solution 2
<br>
function asyncFunc() {
<br>
return Promise.resolve()
<br>
.then(() => {
<br>
doSomethingSync();
<br>
return doSomethingAsync();
<br>
})
<br>
.then(result => {
<br>
// ···
<br>
});
<br>
}
<br>

<br>
Lastly, new Promise() also converts exceptions to rejections. Using this constructor is
<br>
therefore similar to the previous solution:
<br>

<br>
// Solution 3
<br>
function asyncFunc() {
<br>
return new Promise((resolve, reject) => {
<br>
doSomethingSync();
<br>
resolve(doSomethingAsync());
<br>
})
<br>
.then(result => {
<br>
// ···
<br>
});
<br>
}
<br>

<br>
40.4 Promise-based functions start synchronously, settle asynchronously
<br>

<br>
433
<br>

<br>
40.4 Promise-based functions start synchronously, settle
<br>
asynchronously
<br>
Most Promise-based functions are executed as follows:
<br>
• Their execution starts right away, synchronously (in the current task).
<br>
• But the Promise they return is guaranteed to be settled asynchronously (in a later
<br>
task) – if ever.
<br>
The following code demonstrates that:
<br>
function asyncFunc() {
<br>
console.log('asyncFunc');
<br>
return new Promise(
<br>
(resolve, _reject) => {
<br>
console.log('new Promise()');
<br>
resolve();
<br>
});
<br>
}
<br>
console.log('START');
<br>
asyncFunc()
<br>
.then(() => {
<br>
console.log('.then()'); // (A)
<br>
});
<br>
console.log('END');
<br>
// Output:
<br>
// 'START'
<br>
// 'asyncFunc'
<br>
// 'new Promise()'
<br>
// ' END '
<br>
// '.then()'
<br>

<br>
We can see that the callback of new Promise() is executed before the end of the code,
<br>
while the result is delivered later (line A).
<br>
Beneﬁts of this approach:
<br>
• Starting synchronously helps avoid race conditions because we can rely on the
<br>
order in which Promise-based functions begin. There is an example in the next
<br>
chapter, where text is written to a ﬁle and race conditions are avoided.
<br>
• Chaining Promises won’t starve other tasks of processing time because before a
<br>
Promise is settled, there will always be a break, during which the event loop can
<br>
run.
<br>
• Promise-based functions always return results asynchronously; we can be sure that
<br>
there is never a synchronous return. This kind of predictability makes code easier
<br>
to work with.
<br>

<br>
434
<br>

<br>
40 Promises for asynchronous programming
<br>

<br>
More information on this approach
<br>
“Designing APIs for Asynchrony” by Isaac Z. Schlueter
<br>

<br>
40.5
<br>

<br>
Promise.all(): concurrency and Arrays of Promises
<br>

<br>
40.5.1 Sequential execution vs. concurrent execution
<br>
Consider the following code:
<br>
const asyncFunc1 = () => Promise.resolve('one');
<br>
const asyncFunc2 = () => Promise.resolve('two');
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
assert.equal(result1, 'one');
<br>
return asyncFunc2();
<br>
})
<br>
.then(result2 => {
<br>
assert.equal(result2, 'two');
<br>
});
<br>

<br>
Using .then() in this manner executes Promise-based functions sequentially: only after
<br>
the result of asyncFunc1() is settled will asyncFunc2() be executed.
<br>
The static method Promise.all() helps execute Promise-based functions more concurrently:
<br>
Promise.all([asyncFunc1(), asyncFunc2()])
<br>
.then(arr => {
<br>
assert.deepEqual(arr, ['one', 'two']);
<br>
});
<br>

<br>
Its type signature is:
<br>
Promise.all<T>(promises: Iterable<Promise<T>>): Promise<T[]>
<br>

<br>
The parameter promises is an iterable of Promises. The result is a single Promise that is
<br>
settled as follows:
<br>
• If and when all input Promises are fulﬁlled, the output Promise is fulﬁlled with an
<br>
Array of the fulﬁllment values.
<br>
• As soon as at least one input Promise is rejected, the output Promise is rejected
<br>
with the rejection value of that input Promise.
<br>
In other words: We go from an iterable of Promises to a Promise for an Array.
<br>

<br>
40.5.2 Concurrency tip: focus on when operations start
<br>
Tip for determining how “concurrent” asynchronous code is: Focus on when asynchronous operations start, not on how their Promises are handled.
<br>

<br>
40.5 Promise.all(): concurrency and Arrays of Promises
<br>

<br>
435
<br>

<br>
For example, each of the following functions executes asyncFunc1() and asyncFunc2()
<br>
concurrently because they are started at nearly the same time.
<br>
function concurrentAll() {
<br>
return Promise.all([asyncFunc1(), asyncFunc2()]);
<br>
}
<br>
function concurrentThen() {
<br>
const p1 = asyncFunc1();
<br>
const p2 = asyncFunc2();
<br>
return p1.then(r1 => p2.then(r2 => [r1, r2]));
<br>
}
<br>

<br>
On the other hand, both of the following functions execute asyncFunc1() and asyncFunc2() sequentially: asyncFunc2() is only invoked after the Promise of asyncFunc1()
<br>
is fulﬁlled.
<br>
function sequentialThen() {
<br>
return asyncFunc1()
<br>
.then(r1 => asyncFunc2()
<br>
.then(r2 => [r1, r2]));
<br>
}
<br>
function sequentialAll() {
<br>
const p1 = asyncFunc1();
<br>
const p2 = p1.then(() => asyncFunc2());
<br>
return Promise.all([p1, p2]);
<br>
}
<br>

<br>
40.5.3
<br>

<br>
Promise.all() is fork-join
<br>

<br>
Promise.all() is loosely related to the concurrency pattern “fork join” – for example:
<br>
Promise.all([
<br>
// Fork async computations
<br>
httpGet('http://example.com/file1.txt'),
<br>
httpGet('http://example.com/file2.txt'),
<br>
])
<br>
// Join async computations
<br>
.then(([text1, text2]) => {
<br>
assert.equal(text1, 'Content of file1.txt\n');
<br>
assert.equal(text2, 'Content of file2.txt\n');
<br>
});
<br>
httpGet() is the promisiﬁed version of XMLHttpRequest that we implemented earlier.
<br>

<br>
40.5.4 Asynchronous .map() via Promise.all()
<br>
Array transformation methods such as .map(), .filter(), etc., are made for synchronous computations – for example:
<br>

<br>
436
<br>

<br>
40 Promises for asynchronous programming
<br>

<br>
function timesTwoSync(x) {
<br>
return 2 * x;
<br>
}
<br>
const arr = [1, 2, 3];
<br>
const result = arr.map(timesTwoSync);
<br>
assert.deepEqual(result, [2, 4, 6]);
<br>

<br>
What happens if the callback of .map() is a Promise-based function (a function that
<br>
maps normal values to Promises)? Then the result of .map() is an Array of Promises.
<br>
Alas, that is not data that normal code can work with. Thankfully, we can ﬁx that via
<br>
Promise.all(): It converts an Array of Promises into a Promise that is fulﬁlled with an
<br>
Array of normal values.
<br>
function timesTwoAsync(x) {
<br>
return new Promise(resolve => resolve(x * 2));
<br>
}
<br>
const arr = [1, 2, 3];
<br>
const promiseArr = arr.map(timesTwoAsync);
<br>
Promise.all(promiseArr)
<br>
.then(result => {
<br>
assert.deepEqual(result, [2, 4, 6]);
<br>
});
<br>

<br>
40.5.4.1 A more realistic example
<br>
The following code is a more realistic example: in the section on fork-join, there was an
<br>
example where we downloaded two resources identiﬁed by two ﬁxed URLs. Let’s turn
<br>
that code fragment into a function that accepts an Array of URLs and downloads the
<br>
corresponding resources:
<br>
function downloadTexts(urls) {
<br>
const promisedTexts = urls.map(httpGet);
<br>
return Promise.all(promisedTexts);
<br>
}
<br>
downloadTexts([
<br>
'http://example.com/file1.txt',
<br>
'http://example.com/file2.txt',
<br>
])
<br>
.then(texts => {
<br>
assert.deepEqual(
<br>
texts, [
<br>
'Content of file1.txt\n',
<br>
'Content of file2.txt\n',
<br>
]);
<br>
});
<br>

<br>
Exercise: Promise.all() and listing ﬁles
<br>

<br>
40.6 Tips for chaining Promises
<br>

<br>
437
<br>

<br>
exercises/promises/list_files_async_test.mjs
<br>

<br>
40.6 Tips for chaining Promises
<br>
This section gives tips for chaining Promises.
<br>

<br>
40.6.1 Chaining mistake: losing the tail
<br>
Problem:
<br>
// Don’t do this
<br>
function foo() {
<br>
const promise = asyncFunc();
<br>
promise.then(result => {
<br>
// ···
<br>
});
<br>
return promise;
<br>
}
<br>

<br>
Computation starts with the Promise returned by asyncFunc(). But afterward, computation continues and another Promise is created via .then(). foo() returns the former
<br>
Promise, but should return the latter. This is how to ﬁx it:
<br>
function foo() {
<br>
const promise = asyncFunc();
<br>
return promise.then(result => {
<br>
// ···
<br>
});
<br>
}
<br>

<br>
40.6.2 Chaining mistake: nesting
<br>
Problem:
<br>
// Don’t do this
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
return asyncFunc2()
<br>
.then(result2 => { // (A)
<br>
// ···
<br>
});
<br>
});
<br>

<br>
The .then() in line A is nested. A ﬂat structure would be better:
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
return asyncFunc2();
<br>
})
<br>
.then(result2 => {
<br>

<br>
438
<br>

<br>
40 Promises for asynchronous programming
<br>
// ···
<br>
});
<br>

<br>
40.6.3 Chaining mistake: more nesting than necessary
<br>
This is another example of avoidable nesting:
<br>
// Don’t do this
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
if (result1 < 0) {
<br>
return asyncFuncA()
<br>
.then(resultA => 'Result: ' + resultA);
<br>
} else {
<br>
return asyncFuncB()
<br>
.then(resultB => 'Result: ' + resultB);
<br>
}
<br>
});
<br>

<br>
We can once again get a ﬂat structure:
<br>
asyncFunc1()
<br>
.then(result1 => {
<br>
return result1 < 0 ? asyncFuncA() : asyncFuncB();
<br>
})
<br>
.then(resultAB => {
<br>
return 'Result: ' + resultAB;
<br>
});
<br>

<br>
40.6.4 Not all nesting is bad
<br>
In the following code, we actually beneﬁt from nesting:
<br>
db.open()
<br>
.then(connection => { // (A)
<br>
return connection.select({ name: 'Jane' })
<br>
.then(result => { // (B)
<br>
// Process result
<br>
// Use `connection` to make more queries
<br>
})
<br>
// ···
<br>
.finally(() => {
<br>
connection.close(); // (C)
<br>
});
<br>
})
<br>

<br>
We are receiving an asynchronous result in line A. In line B, we are nesting so that we
<br>
have access to variable connection inside the callback and in line C.
<br>

<br>
40.7 Advanced topics
<br>

<br>
439
<br>

<br>
40.6.5 Chaining mistake: creating Promises instead of chaining
<br>
Problem:
<br>
// Don’t do this
<br>
class Model {
<br>
insertInto(db) {
<br>
return new Promise((resolve, reject) => { // (A)
<br>
db.insert(this.fields)
<br>
.then(resultCode => {
<br>
this.notifyObservers({event: 'created', model: this});
<br>
resolve(resultCode);
<br>
}).catch(err => {
<br>
reject(err);
<br>
})
<br>
});
<br>
}
<br>
// ···
<br>
}
<br>

<br>
In line A, we are creating a Promise to deliver the result of db.insert(). That is unnecessarily verbose and can be simpliﬁed:
<br>
class Model {
<br>
insertInto(db) {
<br>
return db.insert(this.fields)
<br>
.then(resultCode => {
<br>
this.notifyObservers({event: 'created', model: this});
<br>
return resultCode;
<br>
});
<br>
}
<br>
// ···
<br>
}
<br>

<br>
The key idea is that we don’t need to create a Promise; we can return the result of the
<br>
.then() call. An additional beneﬁt is that we don’t need to catch and re-reject the failure
<br>
of db.insert(). We simply pass its rejection on to the caller of .insertInto().
<br>

<br>
40.7 Advanced topics
<br>
• In addition to Promise.all(), there is also Promise.race(), which is not used often and described in Exploring ES6.
<br>
• Exploring ES6 has a section that shows a very simple implementation of Promises.
<br>
That may be helpful if you want a deeper understanding of how Promises work.
<br>

<br>
440
<br>

<br>
40 Promises for asynchronous programming
<br>

<br>
Chapter 41
<br>

<br>
Async functions
<br>
Contents
<br>
41.1 Async functions: the basics . . . . . . . . . . . . . . . . . . . . . . . 441
<br>
41.1.1 Async constructs . . . . . . . . . . . . . . . . . . . . . . . . . 443
<br>
41.2 Returning from async functions
<br>

<br>
. . . . . . . . . . . . . . . . . . . . 443
<br>

<br>
41.2.1 Async functions always return Promises . . . . . . . . . . . . 443
<br>
41.2.2 Returned Promises are not wrapped . . . . . . . . . . . . . . . 444
<br>
41.2.3 Executing async functions: synchronous start, asynchronous
<br>
settlement (advanced) . . . . . . . . . . . . . . . . . . . . . . 444
<br>
41.3 await: working with Promises . . . . . . . . . . . . . . . . . . . . . 445
<br>
41.3.1 await and fulﬁlled Promises . . . . . . . . . . . . . . . . . . . 446
<br>
41.3.2 await and rejected Promises . . . . . . . . . . . . . . . . . . . 446
<br>
41.3.3 await is shallow (we can’t use it in callbacks) . . . . . . . . . . 446
<br>
41.4 (Advanced) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
<br>
41.5 Immediately invoked async arrow functions
<br>

<br>
. . . . . . . . . . . . . 447
<br>

<br>
41.6 Concurrency and await . . . . . . . . . . . . . . . . . . . . . . . . . 448
<br>
41.6.1 await: running asynchronous functions sequentially . . . . . . 448
<br>
41.6.2 await: running asynchronous functions concurrently . . . . . 448
<br>
41.7 Tips for using async functions
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . 449
<br>

<br>
41.7.1 We don’t need await if we “ﬁre and forget” . . . . . . . . . . . 449
<br>
41.7.2 It can make sense to await and ignore the result . . . . . . . . 450
<br>

<br>
Roughly, async functions provide better syntax for code that uses Promises. In order to
<br>
use async functions, we should therefore understand Promises. They are explained in
<br>
the previous chapter.
<br>

<br>
41.1 Async functions: the basics
<br>
Consider the following async function:
<br>
441
<br>

<br>
442
<br>

<br>
41 Async functions
<br>

<br>
async function fetchJsonAsync(url) {
<br>
try {
<br>
const request = await fetch(url); // async
<br>
const text = await request.text(); // async
<br>
return JSON.parse(text); // sync
<br>
}
<br>
catch (error) {
<br>
assert.fail(error);
<br>
}
<br>
}
<br>

<br>
The previous, rather synchronous-looking code is equivalent to the following code that
<br>
uses Promises directly:
<br>
function fetchJsonViaPromises(url) {
<br>
return fetch(url) // async
<br>
.then(request => request.text()) // async
<br>
.then(text => JSON.parse(text)) // sync
<br>
.catch(error => {
<br>
assert.fail(error);
<br>
});
<br>
}
<br>

<br>
A few observations about the async function fetchJsonAsync():
<br>
• Async functions are marked with the keyword async.
<br>
• Inside the body of an async function, we write Promise-based code as if it were
<br>
synchronous. We only need to apply the await operator whenever a value is a
<br>
Promise. That operator pauses the async function and resumes it once the Promise
<br>
is settled:
<br>
– If the Promise is fulﬁlled, await returns the fulﬁllment value.
<br>
– If the Promise is rejected, await throws the rejection value.
<br>
• The result of an async function is always a Promise:
<br>
– Any value that is returned (explicitly or implicitly) is used to fulﬁll the
<br>
Promise.
<br>
– Any exception that is thrown is used to reject the Promise.
<br>
Both fetchJsonAsync() and fetchJsonViaPromises() are called in exactly the same way,
<br>
like this:
<br>
fetchJsonAsync('http://example.com/person.json')
<br>
.then(obj => {
<br>
assert.deepEqual(obj, {
<br>
first: 'Jane',
<br>
last: 'Doe',
<br>
});
<br>
});
<br>

<br>
41.2 Returning from async functions
<br>

<br>
443
<br>

<br>
Async functions are as Promise-based as functions that use Promises directly
<br>
From the outside, it is virtually impossible to tell the difference between an async
<br>
function and a function that returns a Promise.
<br>

<br>
41.1.1 Async constructs
<br>
JavaScript has the following async versions of synchronous callable entities. Their roles
<br>
are always either real function or method.
<br>
// Async function declaration
<br>
async function func1() {}
<br>
// Async function expression
<br>
const func2 = async function () {};
<br>
// Async arrow function
<br>
const func3 = async () => {};
<br>
// Async method definition in an object literal
<br>
const obj = { async m() {} };
<br>
// Async method definition in a class definition
<br>
class MyClass { async m() {} }
<br>

<br>
Asynchronous functions vs. async functions
<br>
The difference between the terms asynchronous function and async function is subtle,
<br>
but important:
<br>
• An asynchronous function is any function that delivers its result asynchronously – for example, a callback-based function or a Promise-based
<br>
function.
<br>
• An async function is deﬁned via special syntax, involving the keywords async
<br>
and await. It is also called async/await due to these two keywords. Async
<br>
functions are based on Promises and therefore also asynchronous functions
<br>
(which is somewhat confusing).
<br>

<br>
41.2 Returning from async functions
<br>
41.2.1 Async functions always return Promises
<br>
Each async function always returns a Promise.
<br>
Inside the async function, we fulﬁll the result Promise via return (line A):
<br>
async function asyncFunc() {
<br>

<br>
444
<br>

<br>
41 Async functions
<br>
return 123; // (A)
<br>

<br>
}
<br>
asyncFunc()
<br>
.then(result => {
<br>
assert.equal(result, 123);
<br>
});
<br>

<br>
As usual, if we don’t explicitly return anything, undefined is returned for us:
<br>
async function asyncFunc() {
<br>
}
<br>
asyncFunc()
<br>
.then(result => {
<br>
assert.equal(result, undefined);
<br>
});
<br>

<br>
We reject the result Promise via throw (line A):
<br>
async function asyncFunc() {
<br>
throw new Error('Problem!'); // (A)
<br>
}
<br>
asyncFunc()
<br>
.catch(err => {
<br>
assert.deepEqual(err, new Error('Problem!'));
<br>
});
<br>

<br>
41.2.2 Returned Promises are not wrapped
<br>
If we return a Promise p from an async function, then p becomes the result of the function
<br>
(or rather, the result “locks in” on p and behaves exactly like it). That is, the Promise is
<br>
not wrapped in yet another Promise.
<br>
async function asyncFunc() {
<br>
return Promise.resolve('abc');
<br>
}
<br>
asyncFunc()
<br>
.then(result => assert.equal(result, 'abc'));
<br>

<br>
Recall that any Promise q is treated similarly in the following situations:
<br>
• resolve(q) inside new Promise((resolve, reject) => { ··· })
<br>
• return q inside .then(result => { ··· })
<br>
• return q inside .catch(err => { ··· })
<br>

<br>
41.2.3 Executing async functions: synchronous start, asynchronous
<br>
settlement (advanced)
<br>
Async functions are executed as follows:
<br>

<br>
41.3 await: working with Promises
<br>

<br>
445
<br>

<br>
• The Promise p for the result is created when the async function is started.
<br>
• Then the body is executed. There are two ways in which execution can leave the
<br>
body:
<br>
– Execution can leave permanently while settling p:
<br>
* A return fulﬁlls p.
<br>
* A throw rejects p.
<br>
– Execution can also leave temporarily when awaiting the settlement of another Promise q via await. The async function is paused and execution leaves
<br>
it. It is resumed once q is settled.
<br>
• Promise p is returned after execution has left the body for the ﬁrst time (permanently or temporarily).
<br>
Note that the notiﬁcation of the settlement of the result p happens asynchronously, as is
<br>
always the case with Promises.
<br>
The following code demonstrates that an async function is started synchronously (line A),
<br>
then the current task ﬁnishes (line C), then the result Promise is settled – asynchronously
<br>
(line B).
<br>
async function asyncFunc() {
<br>
console.log('asyncFunc() starts'); // (A)
<br>
return 'abc';
<br>
}
<br>
asyncFunc().
<br>
then(x => { // (B)
<br>
console.log(`Resolved: ${x}`);
<br>
});
<br>
console.log('Task ends'); // (C)
<br>
// Output:
<br>
// 'asyncFunc() starts'
<br>
// 'Task ends'
<br>
// 'Resolved: abc'
<br>

<br>
41.3
<br>

<br>
await: working with Promises
<br>

<br>
The await operator can only be used inside async functions and async generators (which
<br>
are explained in §42.2 “Asynchronous generators”). Its operand is usually a Promise and
<br>
leads to the following steps being performed:
<br>
• The current async function is paused and returned from. This step is similar to
<br>
how yield works in sync generators.
<br>
• Eventually, the current task is ﬁnished and processing of the task queue continues.
<br>
• When and if the Promise is settled, the async function is resumed in a new task:
<br>
– If the Promise is fulﬁlled, await returns the fulﬁllment value.
<br>
– If the Promise is rejected, await throws the rejection value.
<br>
Read on to ﬁnd out more about how await handles Promises in various states.
<br>

<br>
446
<br>

<br>
41 Async functions
<br>

<br>
41.3.1
<br>

<br>
await and fulﬁlled Promises
<br>

<br>
If its operand ends up being a fulﬁlled Promise, await returns its fulﬁllment value:
<br>
assert.equal(await Promise.resolve('yes!'), 'yes!');
<br>

<br>
Non-Promise values are allowed, too, and simply passed on (synchronously, without
<br>
pausing the async function):
<br>
assert.equal(await 'yes!', 'yes!');
<br>

<br>
41.3.2
<br>

<br>
await and rejected Promises
<br>

<br>
If its operand is a rejected Promise, then await throws the rejection value:
<br>
try {
<br>
await Promise.reject(new Error());
<br>
assert.fail(); // we never get here
<br>
} catch (e) {
<br>
assert.equal(e instanceof Error, true);
<br>
}
<br>

<br>
Instances of Error (including instances of its subclasses) are treated specially and also
<br>
thrown:
<br>
try {
<br>
await new Error();
<br>
assert.fail(); // we never get here
<br>
} catch (e) {
<br>
assert.equal(e instanceof Error, true);
<br>
}
<br>

<br>
Exercise: Fetch API via async functions
<br>
exercises/async-functions/fetch_json2_test.mjs
<br>

<br>
41.3.3
<br>

<br>
await is shallow (we can’t use it in callbacks)
<br>

<br>
If we are inside an async function and want to pause it via await, we must do so directly
<br>
within that function; we can’t use it inside a nested function, such as a callback. That is,
<br>
pausing is shallow.
<br>
For example, the following code can’t be executed:
<br>
async function downloadContent(urls) {
<br>
return urls.map((url) => {
<br>
return await httpGet(url); // SyntaxError!
<br>
});
<br>
}
<br>

<br>
The reason is that normal arrow functions don’t allow await inside their bodies.
<br>
OK, let’s try an async arrow function then:
<br>

<br>
41.4 (Advanced)
<br>

<br>
447
<br>

<br>
async function downloadContent(urls) {
<br>
return urls.map(async (url) => {
<br>
return await httpGet(url);
<br>
});
<br>
}
<br>

<br>
Alas, this doesn’t work either: Now .map() (and therefore downloadContent()) returns
<br>
an Array with Promises, not an Array with (unwrapped) values.
<br>
One possible solution is to use Promise.all() to unwrap all Promises:
<br>
async function downloadContent(urls) {
<br>
const promiseArray = urls.map(async (url) => {
<br>
return await httpGet(url); // (A)
<br>
});
<br>
return await Promise.all(promiseArray);
<br>
}
<br>

<br>
Can this code be improved? Yes it can: in line A, we are unwrapping a Promise via await,
<br>
only to re-wrap it immediately via return. If we omit await, we don’t even need an async
<br>
arrow function:
<br>
async function downloadContent(urls) {
<br>
const promiseArray = urls.map(
<br>
url => httpGet(url));
<br>
return await Promise.all(promiseArray); // (B)
<br>
}
<br>

<br>
For the same reason, we can also omit await in line B.
<br>

<br>
Exercise: Mapping and ﬁltering asynchronously
<br>
exercises/async-functions/map_async_test.mjs
<br>

<br>
41.4 (Advanced)
<br>
All remaining sections are advanced.
<br>

<br>
41.5 Immediately invoked async arrow functions
<br>
If we need an await outside an async function (e.g., at the top level of a module), then
<br>
we can immediately invoke an async arrow function:
<br>
(async () => { // start
<br>
const promise = Promise.resolve('abc');
<br>
const value = await promise;
<br>
assert.equal(value, 'abc');
<br>
})(); // end
<br>

<br>
The result of an immediately invoked async arrow function is a Promise:
<br>

<br>
448
<br>

<br>
41 Async functions
<br>

<br>
const promise = (async () => 123)();
<br>
promise.then(x => assert.equal(x, 123));
<br>

<br>
41.6 Concurrency and await
<br>
In the next two subsections, we’ll use the helper function paused():
<br>
/**
<br>
* Resolves after `ms` milliseconds
<br>
*/
<br>
function delay(ms) {
<br>
return new Promise((resolve, _reject) => {
<br>
setTimeout(resolve, ms);
<br>
});
<br>
}
<br>
async function paused(id) {
<br>
console.log('START ' + id);
<br>
await delay(10); // pause
<br>
console.log('END ' + id);
<br>
return id;
<br>
}
<br>

<br>
41.6.1
<br>

<br>
await: running asynchronous functions sequentially
<br>

<br>
If we preﬁx the invocations of multiple asynchronous functions with await, then those
<br>
functions are executed sequentially:
<br>
async function sequentialAwait() {
<br>
const result1 = await paused('first');
<br>
assert.equal(result1, 'first');
<br>
const result2 = await paused('second');
<br>
assert.equal(result2, 'second');
<br>
}
<br>
// Output:
<br>
// 'START first'
<br>
// ' END first'
<br>
// 'START second'
<br>
// ' END second'
<br>

<br>
That is, paused('second') is only started after paused('first') is completely ﬁnished.
<br>

<br>
41.6.2
<br>

<br>
await: running asynchronous functions concurrently
<br>

<br>
If we want to run multiple functions concurrently, we can use the tool method
<br>
Promise.all():
<br>
async function concurrentPromiseAll() {
<br>
const result = await Promise.all([
<br>

<br>
41.7 Tips for using async functions
<br>

<br>
449
<br>

<br>
paused('first'), paused('second')
<br>
]);
<br>
assert.deepEqual(result, ['first', 'second']);
<br>
}
<br>
// Output:
<br>
// 'START first'
<br>
// 'START second'
<br>
// ' END first'
<br>
// ' END second'
<br>

<br>
Here, both asynchronous functions are started at the same time. Once both are settled,
<br>
await gives us either an Array of fulﬁllment values or – if at least one Promise is rejected
<br>
– an exception.
<br>
Recall from §40.5.2 “Concurrency tip: focus on when operations start” that what counts
<br>
is when we start a Promise-based computation; not how we process its result. Therefore,
<br>
the following code is as “concurrent” as the previous one:
<br>
async function concurrentAwait() {
<br>
const resultPromise1 = paused('first');
<br>
const resultPromise2 = paused('second');
<br>
assert.equal(await resultPromise1, 'first');
<br>
assert.equal(await resultPromise2, 'second');
<br>
}
<br>
// Output:
<br>
// 'START first'
<br>
// 'START second'
<br>
// ' END first'
<br>
// ' END second'
<br>

<br>
41.7 Tips for using async functions
<br>
41.7.1 We don’t need await if we “ﬁre and forget”
<br>
await is not required when working with a Promise-based function; we only need it if
<br>
we want to pause and wait until the returned Promise is settled. If we only want to start
<br>
an asynchronous operation, then we don’t need it:
<br>
async function asyncFunc() {
<br>
const writer = openFile('someFile.txt');
<br>
writer.write('hello'); // don’t wait
<br>
writer.write('world'); // don’t wait
<br>
await writer.close(); // wait for file to close
<br>
}
<br>

<br>
In this code, we don’t await .write() because we don’t care when it is ﬁnished. We do,
<br>
however, want to wait until .close() is done.
<br>
Note: Each invocation of .write() starts synchronously. That prevents race conditions.
<br>

<br>
450
<br>

<br>
41 Async functions
<br>

<br>
41.7.2 It can make sense to await and ignore the result
<br>
It can occasionally make sense to use await, even if we ignore its result – for example:
<br>
await longRunningAsyncOperation();
<br>
console.log('Done!');
<br>

<br>
Here, we are using await to join a long-running asynchronous operation. That ensures
<br>
that the logging really happens after that operation is done.
<br>

<br>
Chapter 42
<br>

<br>
Asynchronous iteration
<br>
Contents
<br>
42.1 Basic asynchronous iteration . . . . . . . . . . . . . . . . . . . . . . 451
<br>
42.1.1 Protocol: async iteration . . . . . . . . . . . . . . . . . . . . . 451
<br>
42.1.2 Using async iteration directly . . . . . . . . . . . . . . . . . . 452
<br>
42.1.3 Using async iteration via for-await-of . . . . . . . . . . . . . 454
<br>
42.2 Asynchronous generators . . . . . . . . . . . . . . . . . . . . . . . . 454
<br>
42.2.1 Example: creating an async iterable via an async generator . . 455
<br>
42.2.2 Example: converting a sync iterable to an async iterable . . . . 456
<br>
42.2.3 Example: converting an async iterable to an Array . . . . . . . 456
<br>
42.2.4 Example: transforming an async iterable . . . . . . . . . . . . 457
<br>
42.2.5 Example: mapping over asynchronous iterables . . . . . . . . 457
<br>
42.3 Async iteration over Node.js streams . . . . . . . . . . . . . . . . . . 458
<br>
42.3.1 Node.js streams: async via callbacks (push) . . . . . . . . . . . 458
<br>
42.3.2 Node.js streams: async via async iteration (pull) . . . . . . . . 459
<br>
42.3.3 Example: from chunks to lines . . . . . . . . . . . . . . . . . . 459
<br>

<br>
Required knowledge
<br>
For this chapter, you should be familiar with:
<br>
• Promises
<br>
• Async functions
<br>

<br>
42.1 Basic asynchronous iteration
<br>
42.1.1 Protocol: async iteration
<br>
To understand how asynchronous iteration works, let’s ﬁrst revisit synchronous iteration.
<br>
It comprises the following interfaces:
<br>
451
<br>

<br>
452
<br>

<br>
42 Asynchronous iteration
<br>

<br>
interface Iterable<T> {
<br>
[Symbol.iterator]() : Iterator<T>;
<br>
}
<br>
interface Iterator<T> {
<br>
next() : IteratorResult<T>;
<br>
}
<br>
interface IteratorResult<T> {
<br>
value: T;
<br>
done: boolean;
<br>
}
<br>

<br>
• An Iterable is a data structure whose contents can be accessed via iteration. It is
<br>
a factory for iterators.
<br>
• An Iterator is a factory for iteration results that we retrieve by calling the method
<br>
.next().
<br>
• Each IterationResult contains the iterated .value and a boolean .done that is
<br>
true after the last element and false before.
<br>
For the protocol for asynchronous iteration, we only want to change one thing: the values
<br>
produced by .next() should be delivered asynchronously. There are two conceivable
<br>
options:
<br>
• The .value could contain a Promise<T>.
<br>
• .next() could return Promise<IteratorResult<T>>.
<br>
In other words, the question is whether to wrap just values or whole iterator results in
<br>
Promises.
<br>
It has to be the latter because when .next() returns a result, it starts an asynchronous
<br>
computation. Whether or not that computation produces a value or signals the end of the
<br>
iteration can only be determined after it is ﬁnished. Therefore, both .done and .value
<br>
need to be wrapped in a Promise.
<br>
The interfaces for async iteration look as follows.
<br>
interface AsyncIterable<T> {
<br>
[Symbol.asyncIterator]() : AsyncIterator<T>;
<br>
}
<br>
interface AsyncIterator<T> {
<br>
next() : Promise<IteratorResult<T>>; // (A)
<br>
}
<br>
interface IteratorResult<T> {
<br>
value: T;
<br>
done: boolean;
<br>
}
<br>

<br>
The only difference to the synchronous interfaces is the return type of .next() (line A).
<br>

<br>
42.1.2 Using async iteration directly
<br>
The following code uses the asynchronous iteration protocol directly:
<br>

<br>
42.1 Basic asynchronous iteration
<br>

<br>
453
<br>

<br>
const asyncIterable = syncToAsyncIterable(['a', 'b']); // (A)
<br>
const asyncIterator = asyncIterable[Symbol.asyncIterator]();
<br>
// Call .next() until .done is true:
<br>
asyncIterator.next() // (B)
<br>
.then(iteratorResult => {
<br>
assert.deepEqual(
<br>
iteratorResult,
<br>
{ value: 'a', done: false });
<br>
return asyncIterator.next(); // (C)
<br>
})
<br>
.then(iteratorResult => {
<br>
assert.deepEqual(
<br>
iteratorResult,
<br>
{ value: 'b', done: false });
<br>
return asyncIterator.next(); // (D)
<br>
})
<br>
.then(iteratorResult => {
<br>
assert.deepEqual(
<br>
iteratorResult,
<br>
{ value: undefined, done: true });
<br>
})
<br>
;
<br>

<br>
In line A, we create an asynchronous iterable over the value 'a' and 'b'. We’ll see an
<br>
implementation of syncToAsyncIterable() later.
<br>
We call .next() in line B, line C and line D. Each time, we use .next() to unwrap the
<br>
Promise and assert.deepEqual() to check the unwrapped value.
<br>
We can simplify this code if we use an async function. Now we unwrap Promises via
<br>
await and the code looks almost like we are doing synchronous iteration:
<br>
async function f() {
<br>
const asyncIterable = syncToAsyncIterable(['a', 'b']);
<br>
const asyncIterator = asyncIterable[Symbol.asyncIterator]();
<br>
// Call .next() until .done is true:
<br>
assert.deepEqual(
<br>
await asyncIterator.next(),
<br>
{ value: 'a', done: false });
<br>
assert.deepEqual(
<br>
await asyncIterator.next(),
<br>
{ value: 'b', done: false });
<br>
assert.deepEqual(
<br>
await asyncIterator.next(),
<br>
{ value: undefined, done: true });
<br>
}
<br>

<br>
454
<br>

<br>
42 Asynchronous iteration
<br>

<br>
42.1.3 Using async iteration via for-await-of
<br>
The asynchronous iteration protocol is not meant to be used directly. One of the language
<br>
constructs that supports it is the for-await-of loop, which is an asynchronous version
<br>
of the for-of loop. It can be used in async functions and async generators (which are
<br>
introduced later in this chapter). This is an example of for-await-of in use:
<br>
for await (const x of syncToAsyncIterable(['a', 'b'])) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>
for-await-of is relatively ﬂexible. In addition to asynchronous iterables, it also supports
<br>

<br>
synchronous iterables:
<br>
for await (const x of ['a', 'b']) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
And it supports synchronous iterables over values that are wrapped in Promises:
<br>
const arr = [Promise.resolve('a'), Promise.resolve('b')];
<br>
for await (const x of arr) {
<br>
console.log(x);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'b'
<br>

<br>
Exercise: Convert an async iterable to an Array
<br>
Warning: We’ll soon see the solution for this exercise in this chapter.
<br>
• exercises/async-iteration/async_iterable_to_array_test.mjs
<br>

<br>
42.2 Asynchronous generators
<br>
An asynchronous generator is two things at the same time:
<br>
• An async function (input): We can use await and for-await-of to retrieve data.
<br>
• A generator that returns an asynchronous iterable (output): We can use yield and
<br>
yield* to produce data.
<br>

<br>
Asynchronous generators are very similar to synchronous generators
<br>

<br>
42.2 Asynchronous generators
<br>

<br>
455
<br>

<br>
Due to async generators and sync generators being so similar, I don’t explain how
<br>
exactly yield and yield* work. Please consult §38 “Synchronous generators” if
<br>
you have doubts.
<br>
Therefore, an asynchronous generator has:
<br>
• Input that can be:
<br>
– synchronous (single values, sync iterables) or
<br>
– asynchronous (Promises, async iterables).
<br>
• Output that is an asynchronous iterable.
<br>
This looks as follows:
<br>
async function* asyncGen() {
<br>
// Input: Promises, async iterables
<br>
const x = await somePromise;
<br>
for await (const y of someAsyncIterable) {
<br>
// ···
<br>
}
<br>
// Output
<br>
yield someValue;
<br>
yield* otherAsyncGen();
<br>
}
<br>

<br>
42.2.1 Example: creating an async iterable via an async generator
<br>
Let’s look at an example. The following code creates an async iterable with three numbers:
<br>
async function* yield123() {
<br>
for (let i=1; i<=3; i++) {
<br>
yield i;
<br>
}
<br>
}
<br>

<br>
Does the result of yield123() conform to the async iteration protocol?
<br>
(async () => {
<br>
const asyncIterable = yield123();
<br>
const asyncIterator = asyncIterable[Symbol.asyncIterator]();
<br>
assert.deepEqual(
<br>
await asyncIterator.next(),
<br>
{ value: 1, done: false });
<br>
assert.deepEqual(
<br>
await asyncIterator.next(),
<br>
{ value: 2, done: false });
<br>
assert.deepEqual(
<br>
await asyncIterator.next(),
<br>
{ value: 3, done: false });
<br>

<br>
456
<br>

<br>
42 Asynchronous iteration
<br>
assert.deepEqual(
<br>
await asyncIterator.next(),
<br>
{ value: undefined, done: true });
<br>

<br>
})();
<br>

<br>
We wrapped the code in an immediately invoked async arrow function.
<br>

<br>
42.2.2 Example: converting a sync iterable to an async iterable
<br>
The following asynchronous generator converts a synchronous iterable to an asynchronous iterable. It implements the function syncToAsyncIterable() that we have
<br>
used previously.
<br>
async function* syncToAsyncIterable(syncIterable) {
<br>
for (const elem of syncIterable) {
<br>
yield elem;
<br>
}
<br>
}
<br>

<br>
Note: The input is synchronous in this case (no await is needed).
<br>

<br>
42.2.3 Example: converting an async iterable to an Array
<br>
The following function is a solution to a previous exercise. It converts an async iterable
<br>
to an Array (think spreading, but for async iterables instead of sync iterables).
<br>
async function asyncIterableToArray(asyncIterable) {
<br>
const result = [];
<br>
for await (const value of asyncIterable) {
<br>
result.push(value);
<br>
}
<br>
return result;
<br>
}
<br>

<br>
Note that we can’t use an async generator in this case: We get our input via for-awaitof and return an Array wrapped in a Promise. The latter requirement rules out async
<br>
generators.
<br>
This is a test for asyncIterableToArray():
<br>
async function* createAsyncIterable() {
<br>
yield 'a';
<br>
yield 'b';
<br>
}
<br>
const asyncIterable = createAsyncIterable();
<br>
assert.deepEqual(
<br>
await asyncIterableToArray(asyncIterable), // (A)
<br>
['a', 'b']
<br>
);
<br>

<br>
Note the await in line A, which is needed to unwrap the Promise returned by asyncIterableToArray(). In order for await to work, this code fragment must be run inside an
<br>

<br>
42.2 Asynchronous generators
<br>

<br>
457
<br>

<br>
async function.
<br>

<br>
42.2.4 Example: transforming an async iterable
<br>
Let’s implement an async generator that produces a new async iterable by transforming
<br>
an existing async iterable.
<br>
async function* timesTwo(asyncNumbers) {
<br>
for await (const x of asyncNumbers) {
<br>
yield x * 2;
<br>
}
<br>
}
<br>

<br>
To test this function, we use asyncIterableToArray() from the previous section.
<br>
async function* createAsyncIterable() {
<br>
for (let i=1; i<=3; i++) {
<br>
yield i;
<br>
}
<br>
}
<br>
assert.deepEqual(
<br>
await asyncIterableToArray(timesTwo(createAsyncIterable())),
<br>
[2, 4, 6]
<br>
);
<br>

<br>
Exercise: Async generators
<br>
Warning: We’ll soon see the solution for this exercise in this chapter.
<br>
• exercises/async-iteration/number_lines_test.mjs
<br>

<br>
42.2.5 Example: mapping over asynchronous iterables
<br>
As a reminder, this is how to map over synchronous iterables:
<br>
function* mapSync(iterable, func) {
<br>
let index = 0;
<br>
for (const x of iterable) {
<br>
yield func(x, index);
<br>
index++;
<br>
}
<br>
}
<br>
const syncIterable = mapSync(['a', 'b', 'c'], s => s.repeat(3));
<br>
assert.deepEqual(
<br>
[...syncIterable],
<br>
['aaa', 'bbb', 'ccc']);
<br>

<br>
The asynchronous version looks as follows:
<br>
async function* mapAsync(asyncIterable, func) { // (A)
<br>
let index = 0;
<br>

<br>
458
<br>

<br>
42 Asynchronous iteration
<br>
for await (const x of asyncIterable) { // (B)
<br>
yield func(x, index);
<br>
index++;
<br>
}
<br>

<br>
}
<br>

<br>
Note how similar the sync implementation and the async implementation are. The only
<br>
two differences are the async in line A and the await in line B. That is comparable to
<br>
going from a synchronous function to an asynchronous function – we only need to add
<br>
the keyword async and the occasional await.
<br>
To test mapAsync(), we use the helper function asyncIterableToArray() (shown previously in this chapter):
<br>
async function* createAsyncIterable() {
<br>
yield 'a';
<br>
yield 'b';
<br>
}
<br>
const mapped = mapAsync(
<br>
createAsyncIterable(), s => s.repeat(3));
<br>
assert.deepEqual(
<br>
await asyncIterableToArray(mapped), // (A)
<br>
['aaa', 'bbb']);
<br>

<br>
Once again, we await to unwrap a Promise (line A) and this code fragment must run
<br>
inside an async function.
<br>

<br>
Exercise: filterAsyncIter()
<br>
exercises/async-iteration/filter_async_iter_test.mjs
<br>

<br>
42.3 Async iteration over Node.js streams
<br>
42.3.1 Node.js streams: async via callbacks (push)
<br>
Traditionally, reading asynchronously from Node.js streams is done via callbacks:
<br>
function main(inputFilePath) {
<br>
const readStream = fs.createReadStream(inputFilePath,
<br>
{ encoding: 'utf8', highWaterMark: 1024 });
<br>
readStream.on('data', (chunk) => {
<br>
console.log('>>> '+chunk);
<br>
});
<br>
readStream.on('end', () => {
<br>
console.log('### DONE ###');
<br>
});
<br>
}
<br>

<br>
That is, the stream is in control and pushes data to the reader.
<br>

<br>
42.3 Async iteration over Node.js streams
<br>

<br>
459
<br>

<br>
42.3.2 Node.js streams: async via async iteration (pull)
<br>
Starting with Node.js 10, we can also use asynchronous iteration to read from streams:
<br>
async function main(inputFilePath) {
<br>
const readStream = fs.createReadStream(inputFilePath,
<br>
{ encoding: 'utf8', highWaterMark: 1024 });
<br>
for await (const chunk of readStream) {
<br>
console.log('>>> '+chunk);
<br>
}
<br>
console.log('### DONE ###');
<br>
}
<br>

<br>
This time, the reader is in control and pulls data from the stream.
<br>

<br>
42.3.3 Example: from chunks to lines
<br>
Node.js streams iterate over chunks (arbitrarily long pieces) of data. The following asynchronous generator converts an async iterable over chunks to an async iterable over lines:
<br>
/**
<br>
* Parameter: async iterable of chunks (strings)
<br>
* Result: async iterable of lines (incl. newlines)
<br>
*/
<br>
async function* chunksToLines(chunksAsync) {
<br>
let previous = '';
<br>
for await (const chunk of chunksAsync) { // input
<br>
previous += chunk;
<br>
let eolIndex;
<br>
while ((eolIndex = previous.indexOf('\n')) >= 0) {
<br>
// line includes the EOL (Windows '\r\n' or Unix '\n')
<br>
const line = previous.slice(0, eolIndex+1);
<br>
yield line; // output
<br>
previous = previous.slice(eolIndex+1);
<br>
}
<br>
}
<br>
if (previous.length > 0) {
<br>
yield previous;
<br>
}
<br>
}
<br>

<br>
Let’s apply chunksToLines() to an async iterable over chunks (as produced by chunkIterable()):
<br>
async function* chunkIterable() {
<br>
yield 'First\nSec';
<br>
yield 'ond\nThird\nF';
<br>
yield 'ourth';
<br>
}
<br>
const linesIterable = chunksToLines(chunkIterable());
<br>

<br>
460
<br>

<br>
42 Asynchronous iteration
<br>

<br>
assert.deepEqual(
<br>
await asyncIterableToArray(linesIterable),
<br>
[
<br>
'First\n',
<br>
'Second\n',
<br>
'Third\n',
<br>
'Fourth',
<br>
]);
<br>

<br>
Now that we have an asynchronous iterable over lines, we can use the solution of a previous exercise, numberLines(), to number those lines:
<br>
async function* numberLines(linesAsync) {
<br>
let lineNumber = 1;
<br>
for await (const line of linesAsync) {
<br>
yield lineNumber + ': ' + line;
<br>
lineNumber++;
<br>
}
<br>
}
<br>
const numberedLines = numberLines(chunksToLines(chunkIterable()));
<br>
assert.deepEqual(
<br>
await asyncIterableToArray(numberedLines),
<br>
[
<br>
'1: First\n',
<br>
'2: Second\n',
<br>
'3: Third\n',
<br>
'4: Fourth',
<br>
]);
<br>

<br>
Part IX
<br>

<br>
More standard library
<br>

<br>
461
<br>

<br>
Chapter 43
<br>

<br>
Regular expressions (RegExp)
<br>
Contents
<br>
43.1 Creating regular expressions . . . . . . . . . . . . . . . . . . . . . . 464
<br>
43.1.1 Literal vs. constructor . . . . . . . . . . . . . . . . . . . . . . . 464
<br>
43.1.2 Cloning and non-destructively modifying regular expressions
<br>

<br>
464
<br>

<br>
43.2 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
<br>
43.2.1 Syntax characters . . . . . . . . . . . . . . . . . . . . . . . . . 465
<br>
43.2.2 Basic atoms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
<br>
43.2.3 Unicode property escapes [ES2018] . . . . . . . . . . . . . . . . . 466
<br>
43.2.4 Character classes . . . . . . . . . . . . . . . . . . . . . . . . . 467
<br>
43.2.5 Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
<br>
43.2.6 Quantiﬁers
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
<br>

<br>
43.2.7 Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
<br>
43.2.8 Disjunction (|) . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
<br>
43.3 Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
<br>
43.3.1 Flag: Unicode mode via /u . . . . . . . . . . . . . . . . . . . . 471
<br>
43.4 Properties of regular expression objects . . . . . . . . . . . . . . . . 472
<br>
43.4.1 Flags as properties . . . . . . . . . . . . . . . . . . . . . . . . 473
<br>
43.4.2 Other properties . . . . . . . . . . . . . . . . . . . . . . . . . . 473
<br>
43.5 Methods for working with regular expressions . . . . . . . . . . . . 473
<br>
43.5.1 In general, regular expressions match anywhere in a string . . 473
<br>
43.5.2 regExp.test(str): is there a match?
<br>

<br>
[ES3]
<br>

<br>
. . . . . . . . . . . . 474
<br>

<br>
43.5.3 str.search(regExp): at what index is the match?
<br>
43.5.4 regExp.exec(str): capturing groups
<br>

<br>
[ES3]
<br>

<br>
[ES3]
<br>

<br>
. . . . . 474
<br>

<br>
. . . . . . . . . . . . 474
<br>

<br>
43.5.5 str.match(regExp): return all matching substrings [ES3] . . . . 476
<br>
43.5.6 str.replace(searchValue, replacementValue) [ES3] . . . . . 476
<br>
43.5.7 Other methods for working with regular expressions
<br>

<br>
. . . . . 478
<br>

<br>
43.6 Flag /g and its pitfalls . . . . . . . . . . . . . . . . . . . . . . . . . . 478
<br>
43.6.1 Pitfall: You can’t inline a regular expression with ﬂag /g . . . . 478
<br>
43.6.2 Pitfall: Removing /g can break code . . . . . . . . . . . . . . . 479
<br>

<br>
463
<br>

<br>
464
<br>

<br>
43 Regular expressions (RegExp)
<br>
43.6.3 Pitfall: Adding /g can break code . . . . . . . . . . . . . . . . 479
<br>
43.6.4 Pitfall: Code can break if .lastIndex isn’t zero . . . . . . . . . 479
<br>
43.6.5 Dealing with /g and .lastIndex . . . . . . . . . . . . . . . . . 480
<br>
43.7 Techniques for working with regular expressions . . . . . . . . . . . 481
<br>
43.7.1 Escaping arbitrary text for regular expressions . . . . . . . . . 481
<br>
43.7.2 Matching everything or nothing . . . . . . . . . . . . . . . . . 481
<br>

<br>
Availability of features
<br>
Unless stated otherwise, each regular expression feature has been available since
<br>
ES3.
<br>

<br>
43.1 Creating regular expressions
<br>
43.1.1 Literal vs. constructor
<br>
The two main ways of creating regular expressions are:
<br>
• Literal: compiled statically (at load time).
<br>
/abc/ui
<br>

<br>
• Constructor: compiled dynamically (at runtime).
<br>
new RegExp('abc', 'ui')
<br>

<br>
Both regular expressions have the same two parts:
<br>
• The body abc – the actual regular expression.
<br>
• The ﬂags u and i. Flags conﬁgure how the pattern is interpreted. For example,
<br>
i enables case-insensitive matching. A list of available ﬂags is given later in this
<br>
chapter.
<br>

<br>
43.1.2 Cloning and non-destructively modifying regular expressions
<br>
There are two variants of the constructor RegExp():
<br>
• new RegExp(pattern : string, flags = '') [ES3]
<br>
A new regular expression is created as speciﬁed via pattern. If flags is missing,
<br>
the empty string '' is used.
<br>
• new RegExp(regExp : RegExp, flags = regExp.flags) [ES6]
<br>
regExp is cloned. If flags is provided, then it determines the ﬂags of the clone.
<br>

<br>
The second variant is useful for cloning regular expressions, optionally while modifying
<br>
them. Flags are immutable and this is the only way of changing them – for example:
<br>
function copyAndAddFlags(regExp, flagsToAdd='') {
<br>
// The constructor doesn’t allow duplicate flags;
<br>
// make sure there aren’t any:
<br>

<br>
43.2 Syntax
<br>

<br>
465
<br>

<br>
const newFlags = [...new Set(regExp.flags + flagsToAdd)].join('');
<br>
return new RegExp(regExp, newFlags);
<br>
}
<br>
assert.equal(/abc/i.flags, 'i');
<br>
assert.equal(copyAndAddFlags(/abc/i, 'g').flags, 'gi');
<br>

<br>
43.2 Syntax
<br>
43.2.1 Syntax characters
<br>
At the top level of a regular expression, the following syntax characters are special. They
<br>
are escaped by preﬁxing a backslash (\).
<br>
\ ^ $ . * + ? ( ) [ ] { } |
<br>

<br>
In regular expression literals, you must escape slashs:
<br>
> /\//.test('/')
<br>
true
<br>

<br>
In the argument of new RegExp(), you don’t have to escape slashes:
<br>
> new RegExp('/').test('/')
<br>
true
<br>

<br>
43.2.2 Basic atoms
<br>
Atoms are the basic building blocks of regular expressions.
<br>

<br>
• Pattern characters are all characters except syntax characters (^, $, etc.). Pattern characters match themselves. Examples: A b %
<br>
• . matches any character. You can use the ﬂag /s (dotall) to control if the dot
<br>
matches line terminators or not (more below).
<br>
• Character escapes (each escape matches a single ﬁxed character):
<br>
– Control escapes (for a few control characters):
<br>
* \f: form feed (FF)
<br>
* \n: line feed (LF)
<br>
* \r: carriage return (CR)
<br>
* \t: character tabulation
<br>
* \v: line tabulation
<br>
– Arbitrary control characters: \cA (Ctrl-A), …, \cZ (Ctrl-Z)
<br>
– Unicode code units: \u00E4
<br>
– Unicode code points (require ﬂag /u): \u{1F44D}
<br>
• Character class escapes (each escape matches one out of a set of characters):
<br>
– \d: digits (same as [0-9])
<br>
* \D: non-digits
<br>
– \w: “word” characters (same as [A-Za-z0-9_], related to identiﬁers in programming languages)
<br>
* \W: non-word characters
<br>
– \s: whitespace (space, tab, line terminators, etc.)
<br>
* \S: non-whitespace
<br>

<br>
466
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
– Unicode property escapes [ES2018] : \p{White_Space}, \P{White_Space}, etc.
<br>
* Require ﬂag /u.
<br>
* Described in the next subsection.
<br>

<br>
43.2.3 Unicode property escapes [ES2018]
<br>
43.2.3.1 Unicode character properties
<br>
In the Unicode standard, each character has properties – metadata describing it. Properties play an important role in deﬁning the nature of a character. Quoting the Unicode
<br>
Standard, Sect. 3.3, D3:
<br>
The semantics of a character are determined by its identity, normative properties, and behavior.
<br>
These are a few examples of properties:
<br>
• Name: a unique name, composed of uppercase letters, digits, hyphens, and spaces
<br>
– for example:
<br>
– A: Name = LATIN CAPITAL LETTER A
<br>
– ☺: Name = SLIGHTLY SMILING FACE
<br>
• General_Category: categorizes characters – for example:
<br>
– x: General_Category = Lowercase_Letter
<br>
– $: General_Category = Currency_Symbol
<br>
• White_Space: used for marking invisible spacing characters, such as spaces, tabs
<br>
and newlines – for example:
<br>
– \t: White_Space = True
<br>
– π: White_Space = False
<br>
• Age: version of the Unicode Standard in which a character was introduced – for
<br>
example: The Euro sign € was added in version 2.1 of the Unicode standard.
<br>
– €: Age = 2.1
<br>
• Block: a contiguous range of code points. Blocks don’t overlap and their names
<br>
are unique. For example:
<br>
– S: Block = Basic_Latin (range U+0000..U+007F)
<br>
– ☺: Block = Emoticons (range U+1F600..U+1F64F)
<br>
• Script: is a collection of characters used by one or more writing systems.
<br>
– Some scripts support several writing systems. For example, the Latin script
<br>
supports the writing systems English, French, German, Latin, etc.
<br>
– Some languages can be written in multiple alternate writing systems that are
<br>
supported by multiple scripts. For example, Turkish used the Arabic script
<br>
before it transitioned to the Latin script in the early 20th century.
<br>
– Examples:
<br>
* α: Script = Greek
<br>
* Д: Script = Cyrillic
<br>
43.2.3.2 Unicode property escapes
<br>
Unicode property escapes look like this:
<br>
1. \p{prop=value}: matches all characters whose property prop has the value value.
<br>

<br>
43.2 Syntax
<br>

<br>
467
<br>

<br>
2. \P{prop=value}: matches all characters that do not have a property prop whose
<br>
value is value.
<br>
3. \p{bin_prop}: matches all characters whose binary property bin_prop is True.
<br>
4. \P{bin_prop}: matches all characters whose binary property bin_prop is False.
<br>
Comments:
<br>
• You can only use Unicode property escapes if the ﬂag /u is set. Without /u, \p is
<br>
the same as p.
<br>
• Forms (3) and (4) can be used as abbreviations if the property is General_Category.
<br>
For example, the following two escapes are equivalent:
<br>
\p{Lowercase_Letter}
<br>
\p{General_Category=Lowercase_Letter}
<br>

<br>
Examples:
<br>
• Checking for whitespace:
<br>
> /^\p{White_Space}+$/u.test('\t \n\r')
<br>
true
<br>

<br>
• Checking for Greek letters:
<br>
> /^\p{Script=Greek}+$/u.test('μετά')
<br>
true
<br>

<br>
• Deleting any letters:
<br>
> '1π2ü3é4'.replace(/\p{Letter}/ug, '')
<br>
'1234'
<br>

<br>
• Deleting lowercase letters:
<br>
> 'AbCdEf'.replace(/\p{Lowercase_Letter}/ug, '')
<br>
'ACE'
<br>

<br>
Further reading:
<br>
• Lists of Unicode properties and their values: “Unicode Standard Annex #44: Unicode Character Database” (Editors: Mark Davis, Laurențiu Iancu, Ken Whistler)
<br>

<br>
43.2.4 Character classes
<br>
A character class wraps class ranges in square brackets. The class ranges specify a set of
<br>
characters:
<br>
• [«class ranges»] matches any character in the set.
<br>
• [^«class ranges»] matches any character not in the set.
<br>
Rules for class ranges:
<br>
• Non-syntax characters stand for themselves: [abc]
<br>
• Only the following four characters are special and must be escaped via slashes:
<br>
^ \ - ]
<br>

<br>
468
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
– ^ only has to be escaped if it comes ﬁrst.
<br>
– - need not be escaped if it comes ﬁrst or last.
<br>
• Character escapes (\n, \u{1F44D}, etc.) have the usual meaning.
<br>
– Watch out: \b stands for backspace. Elsewhere in a regular expression, it
<br>
matches word boundaries.
<br>
• Character class escapes (\d, \p{White_Space}, etc.) have the usual meaning.
<br>
• Ranges of characters are speciﬁed via dashes: [a-z]
<br>

<br>
43.2.5 Groups
<br>
• Positional capture group: (#+)
<br>
– Backreference: \1, \2, etc.
<br>
• Named capture group [ES2018] : (?<hashes>#+)
<br>
– Backreference: \k<hashes>
<br>
• Noncapturing group: (?:#+)
<br>

<br>
43.2.6 Quantiﬁers
<br>
By default, all of the following quantiﬁers are greedy (they match as many characters as
<br>
possible):
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
?: match never or once
<br>
*: match zero or more times
<br>
+: match one or more times
<br>
{n}: match n times
<br>
{n,}: match n or more times
<br>
{n,m}: match at least n times, at most m times.
<br>

<br>
To make them reluctant (so that they match as few characters as possible), put question
<br>
marks (?) after them:
<br>
> /".*"/.exec('"abc"def"')[0]
<br>

<br>
// greedy
<br>

<br>
'"abc"def"'
<br>
> /".*?"/.exec('"abc"def"')[0] // reluctant
<br>
'"abc"'
<br>

<br>
43.2.7 Assertions
<br>
• ^ matches only at the beginning of the input
<br>
• $ matches only at the end of the input
<br>
• \b matches only at a word boundary
<br>
– \B matches only when not at a word boundary
<br>
43.2.7.1 Lookahead
<br>
Positive lookahead: (?=«pattern») matches if pattern matches what comes next.
<br>
Example: sequences of lowercase letters that are followed by an X.
<br>

<br>
469
<br>

<br>
43.3 Flags
<br>
> 'abcX def'.match(/[a-z]+(?=X)/g)
<br>
[ 'abc' ]
<br>

<br>
Note that the X itself is not part of the matched substring.
<br>
Negative lookahead: (?!«pattern») matches if pattern does not match what comes
<br>
next.
<br>
Example: sequences of lowercase letters that are not followed by an X.
<br>
> 'abcX def'.match(/[a-z]+(?!X)/g)
<br>
[ 'ab', 'def' ]
<br>

<br>
43.2.7.2 Lookbehind [ES2018]
<br>
Positive lookbehind: (?<=«pattern») matches if pattern matches what came before.
<br>
Example: sequences of lowercase letters that are preceded by an X.
<br>
> 'Xabc def'.match(/(?<=X)[a-z]+/g)
<br>
[ 'abc' ]
<br>

<br>
Negative lookbehind: (?<!«pattern») matches if pattern does not match what came
<br>
before.
<br>
Example: sequences of lowercase letters that are not preceded by an X.
<br>
> 'Xabc def'.match(/(?<!X)[a-z]+/g)
<br>
[ 'bc', 'def' ]
<br>

<br>
Example: replace “.js” with “.html”, but not in “Node.js”.
<br>
> 'Node.js: index.js and main.js'.replace(/(?<!Node)\.js/g, '.html')
<br>
'Node.js: index.html and main.html'
<br>

<br>
43.2.8 Disjunction (|)
<br>
Caveat: this operator has low precedence. Use groups if necessary:
<br>
• ^aa|zz$ matches all strings that start with aa and/or end with zz. Note that | has
<br>
a lower precedence than ^ and $.
<br>
• ^(aa|zz)$ matches the two strings 'aa' and 'zz'.
<br>
• ^a(a|z)z$ matches the two strings 'aaz' and 'azz'.
<br>

<br>
43.3 Flags
<br>
Table 43.1:
<br>
JavaScript.
<br>

<br>
These are the regular expression ﬂags supported by
<br>

<br>
Literal ﬂag
<br>

<br>
Property name
<br>

<br>
ES
<br>

<br>
Description
<br>

<br>
g
<br>

<br>
global
<br>

<br>
i
<br>

<br>
ignoreCase
<br>

<br>
m
<br>

<br>
multiline
<br>

<br>
ES3
<br>
ES3
<br>
ES3
<br>

<br>
Match multiple times
<br>
Match case-insensitively
<br>
^ and $ match per line
<br>

<br>
470
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
Literal ﬂag
<br>

<br>
Property name
<br>

<br>
ES
<br>

<br>
Description
<br>

<br>
s
<br>

<br>
dotall
<br>

<br>
u
<br>

<br>
unicode
<br>

<br>
y
<br>

<br>
sticky
<br>

<br>
ES2018
<br>
ES6
<br>
ES6
<br>

<br>
Dot matches line terminators
<br>
Unicode mode (recommended)
<br>
No characters between matches
<br>

<br>
The following regular expression ﬂags are available in JavaScript (tbl. 43.1 provides a
<br>
compact overview):
<br>
• /g (.global): fundamentally changes how the following methods work.
<br>
– RegExp.prototype.test()
<br>
– RegExp.prototype.exec()
<br>
– String.prototype.match()
<br>
How, is explained in §43.6 “Flag /g and its pitfalls”. In a nutshell, without /g, the
<br>
methods only consider the ﬁrst match for a regular expression in an input string.
<br>
With /g, they consider all matches.
<br>
• /i (.ignoreCase): switches on case-insensitive matching:
<br>
> /a/.test('A')
<br>
false
<br>
> /a/i.test('A')
<br>
true
<br>

<br>
• /m (.multiline): If this ﬂag is on, ^ matches the beginning of each line and $
<br>
matches the end of each line. If it is off, ^ matches the beginning of the whole
<br>
input string and $ matches the end of the whole input string.
<br>
> 'a1\na2\na3'.match(/^a./gm)
<br>
[ 'a1', 'a2', 'a3' ]
<br>
> 'a1\na2\na3'.match(/^a./g)
<br>
[ 'a1' ]
<br>

<br>
• /u (.unicode): This ﬂag switches on the Unicode mode for a regular expression.
<br>
That mode is explained in the next subsection.
<br>
• /y (.sticky): This ﬂag mainly makes sense in conjunction with /g. When both are
<br>
switched on, any match must directly follow the previous one (that is, it must start
<br>
at index .lastIndex of the regular expression object). Therefore, the ﬁrst match
<br>
must be at index 0.
<br>
> 'a1a2 a3'.match(/a./gy)
<br>
[ 'a1', 'a2' ]
<br>
> '_a1a2 a3'.match(/a./gy) // first match must be at index 0
<br>
null
<br>
> 'a1a2 a3'.match(/a./g)
<br>
[ 'a1', 'a2', 'a3' ]
<br>
> '_a1a2 a3'.match(/a./g)
<br>
[ 'a1', 'a2', 'a3' ]
<br>

<br>
471
<br>

<br>
43.3 Flags
<br>

<br>
The main use case for /y is tokenization (during parsing).
<br>
• /s (.dotall): By default, the dot does not match line terminators. With this ﬂag, it
<br>
does:
<br>
> /./.test('\n')
<br>
false
<br>
> /./s.test('\n')
<br>
true
<br>

<br>
Workaround if /s isn’t supported: Use [^] instead of a dot.
<br>
> /[^]/.test('\n')
<br>
true
<br>

<br>
43.3.1 Flag: Unicode mode via /u
<br>
The ﬂag /u switches on a special Unicode mode for regular expressions. That mode enables several features:
<br>
• In patterns, you can use Unicode code point escapes such as \u{1F42A} to specify
<br>
characters. Code unit escapes such as \u03B1 only have a range of four hexadecimal digits (which corresponds to the basic multilingual plane).
<br>
• In patterns, you can use Unicode property escapes such as \p{White_Space}.
<br>
• Many escapes are now forbidden. For example: \a \- \:
<br>
Pattern characters always match themselves:
<br>
> /pa-:/.test('pa-:')
<br>
true
<br>

<br>
Without /u, there are some pattern characters that still match themselves if you
<br>
escape them with backslashes:
<br>
> /\p\a\-\:/.test('pa-:')
<br>
true
<br>

<br>
With /u:
<br>
– \p starts a Unicode property escape.
<br>
– The remaining “self-matching” escapes are forbidden. As a consequence,
<br>
they can now be used for new features in the future.
<br>
• The atomic units for matching are Unicode characters (code points), not JavaScript
<br>
characters (code units).
<br>
The following subsections explain the last item in more detail. They use the following
<br>
Unicode character to explain when the atomic units are Unicode characters and when
<br>
they are JavaScript characters:
<br>
const codePoint = '☺';
<br>
const codeUnits = '\uD83D\uDE42'; // UTF-16
<br>
assert.equal(codePoint, codeUnits); // same string!
<br>

<br>
472
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
I’m only switching between ☺ and \uD83D\uDE42, to illustrate how JavaScript sees things.
<br>
Both are equivalent and can be used interchangeably in strings and regular expressions.
<br>
43.3.1.1 Consequence: you can put Unicode characters in character classes
<br>
With /u, the two code units of ☺ are treated as a single character:
<br>
> /^[☺]$/u.test('☺')
<br>
true
<br>

<br>
Without /u, ☺ is treated as two characters:
<br>
> /^[\uD83D\uDE42]$/.test('\uD83D\uDE42')
<br>
false
<br>
> /^[\uD83D\uDE42]$/.test('\uDE42')
<br>
true
<br>

<br>
Note that ^ and $ demand that the input string have a single character. That’s why the
<br>
ﬁrst result is false.
<br>
43.3.1.2 Consequence: the dot operator (.)
<br>
JavaScript characters
<br>

<br>
matches Unicode characters, not
<br>

<br>
With /u, the dot operator matches Unicode characters:
<br>
> '☺'.match(/./gu).length
<br>
1
<br>
.match() plus /g returns an Array with all the matches of a regular expression.
<br>

<br>
Without /u, the dot operator matches JavaScript characters:
<br>
> '\uD83D\uDE80'.match(/./g).length
<br>
2
<br>

<br>
43.3.1.3 Consequence: quantiﬁers apply to Unicode characters, not JavaScript characters
<br>
With /u, a quantiﬁer applies to the whole preceding Unicode character:
<br>
> /^☺{3}$/u.test('☺☺☺')
<br>
true
<br>

<br>
Without /u, a quantiﬁer only applies to the preceding JavaScript character:
<br>
> /^\uD83D\uDE80{3}$/.test('\uD83D\uDE80\uDE80\uDE80')
<br>
true
<br>

<br>
43.4 Properties of regular expression objects
<br>
Noteworthy:
<br>
• Strictly speaking, only .lastIndex is a real instance property. All other properties
<br>
are implemented via getters.
<br>

<br>
43.5 Methods for working with regular expressions
<br>

<br>
473
<br>

<br>
• Accordingly, .lastIndex is the only mutable property. All other properties are
<br>
read-only. If you want to change them, you need to copy the regular expression
<br>
(consult §43.1.2 “Cloning and non-destructively modifying regular expressions”
<br>
for details).
<br>

<br>
43.4.1 Flags as properties
<br>
Each regular expression ﬂag exists as a property with a longer, more descriptive name:
<br>
> /a/i.ignoreCase
<br>
true
<br>
> /a/.ignoreCase
<br>
false
<br>

<br>
This is the complete list of ﬂag properties:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
.dotall (/s)
<br>
.global (/g)
<br>
.ignoreCase (/i)
<br>
.multiline (/m)
<br>
.sticky (/y)
<br>
.unicode (/u)
<br>

<br>
43.4.2 Other properties
<br>
Each regular expression also has the following properties:
<br>
• .source [ES3] : The regular expression pattern
<br>
> /abc/ig.source
<br>
'abc'
<br>

<br>
• .flags [ES6] : The ﬂags of the regular expression
<br>
> /abc/ig.flags
<br>
'gi'
<br>

<br>
• .lastIndex [ES3] : Used when ﬂag /g is switched on. Consult §43.6 “Flag /g and its
<br>
pitfalls” for details.
<br>

<br>
43.5 Methods for working with regular expressions
<br>
43.5.1 In general, regular expressions match anywhere in a string
<br>
Note that, in general, regular expressions match anywhere in a string:
<br>
> /a/.test('__a__')
<br>
true
<br>

<br>
You can change that by using assertions such as ^ or by using the ﬂag /y:
<br>
> /^a/.test('__a__')
<br>
false
<br>

<br>
474
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
> /^a/.test('a__')
<br>
true
<br>

<br>
43.5.2
<br>

<br>
regExp.test(str): is there a match?
<br>

<br>
[ES3]
<br>

<br>
The regular expression method .test() returns true if regExp matches str:
<br>
> /bc/.test('ABCD')
<br>
false
<br>
> /bc/i.test('ABCD')
<br>
true
<br>
> /\.mjs$/.test('main.mjs')
<br>
true
<br>

<br>
With .test() you should normally avoid the /g ﬂag. If you use it, you generally don’t
<br>
get the same result every time you call the method:
<br>
> const r = /a/g;
<br>
> r.test('aab')
<br>
true
<br>
> r.test('aab')
<br>
true
<br>
> r.test('aab')
<br>
false
<br>

<br>
The results are due to /a/ having two matches in the string. After all of those were found,
<br>
.test() returns false.
<br>

<br>
43.5.3
<br>

<br>
str.search(regExp): at what index is the match?
<br>

<br>
[ES3]
<br>

<br>
The string method .search() returns the ﬁrst index of str at which there is a match for
<br>
regExp:
<br>
> '_abc_'.search(/abc/)
<br>
1
<br>
> 'main.mjs'.search(/\.mjs$/)
<br>
4
<br>

<br>
43.5.4
<br>

<br>
regExp.exec(str): capturing groups [ES3]
<br>

<br>
43.5.4.1 Getting a match object for the ﬁrst match
<br>
Without the ﬂag /g, .exec() returns the captures of the ﬁrst match for regExp in str:
<br>
assert.deepEqual(
<br>
/(a+)b/.exec('ab aab'),
<br>
{
<br>
0: 'ab',
<br>
1: 'a',
<br>
index: 0,
<br>
input: 'ab aab',
<br>
groups: undefined,
<br>

<br>
43.5 Methods for working with regular expressions
<br>

<br>
475
<br>

<br>
}
<br>
);
<br>

<br>
The result is a match object with the following properties:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
[0]: the complete substring matched by the regular expression
<br>
[1]: capture of positional group 1 (etc.)
<br>
.index: where did the match occur?
<br>
.input: the string that was matched against
<br>
.groups: captures of named groups
<br>

<br>
43.5.4.2 Named capture groups [ES2018]
<br>
The previous example contained a single positional group. The following example
<br>
demonstrates named groups:
<br>
assert.deepEqual(
<br>
/(?<as>a+)b/.exec('ab aab'),
<br>
{
<br>
0: 'ab',
<br>
1: 'a',
<br>
index: 0,
<br>
input: 'ab aab',
<br>
groups: { as: 'a' },
<br>
}
<br>
);
<br>

<br>
In the result of .exec(), you can see that a named group is also a positional group – its
<br>
capture exists twice:
<br>
• Once as a positional capture (property '1').
<br>
• Once as a named capture (property groups.as).
<br>
43.5.4.3 Looping over multiple matches
<br>
If you want to retrieve all matches of a regular expression (not just the ﬁrst one), you need
<br>
to switch on the ﬂag /g. Then you can call .exec() multiple times and get one match each
<br>
time. After the last match, .exec() returns null.
<br>
> const regExp = /(a+)b/g;
<br>
> regExp.exec('ab aab')
<br>
{ 0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined }
<br>
> regExp.exec('ab aab')
<br>
{ 0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined }
<br>
> regExp.exec('ab aab')
<br>
null
<br>

<br>
Therefore, you can loop over all matches as follows:
<br>
const regExp = /(a+)b/g;
<br>
const str = 'ab aab';
<br>

<br>
476
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
let match;
<br>
// Check for null via truthiness
<br>
// Alternative: while ((match = regExp.exec(str)) !== null)
<br>
while (match = regExp.exec(str)) {
<br>
console.log(match[1]);
<br>
}
<br>
// Output:
<br>
// 'a'
<br>
// 'aa'
<br>

<br>
Sharing regular expressions with /g has a few pitfalls, which are explained later.
<br>

<br>
Exercise: Extract quoted text via .exec()
<br>
exercises/regexps/extract_quoted_test.mjs
<br>

<br>
43.5.5
<br>

<br>
str.match(regExp): return all matching substrings [ES3]
<br>

<br>
Without /g, .match() works like .exec() – it returns a single match object.
<br>
With /g, .match() returns all substrings of str that match regExp:
<br>
> 'ab aab'.match(/(a+)b/g)
<br>
[ 'ab', 'aab' ]
<br>

<br>
If there is no match, .match() returns null:
<br>
> 'xyz'.match(/(a+)b/g)
<br>
null
<br>

<br>
You can use the Or operator to protect yourself against null:
<br>
const numberOfMatches = (str.match(regExp) || []).length;
<br>

<br>
43.5.6
<br>

<br>
str.replace(searchValue, replacementValue) [ES3]
<br>

<br>
.replace() is overloaded – it works differently, depending on the types of its parameters:
<br>

<br>
• If searchValue is:
<br>
– Regular expression without /g: Replace ﬁrst match of this regular expression.
<br>
– Regular expression with /g: Replace all matches of this regular expression.
<br>
– String: Replace ﬁrst occurrence of this string (the string is interpreted verbatim, not as a regular expression). Alas, there is no way to replace every
<br>
occurrence of a string. Later in this chapter, we’ll see a tool function that
<br>
converts a string into a regular expression that matches this string (e.g., '*'
<br>
becomes /\*/).
<br>
• If replacementValue is:
<br>
– String: Replace matches with this string. The character $ has special meaning
<br>
and lets you insert captures of groups and more (read on for details).
<br>
– Function: Compute strings that replace matches via this function.
<br>
The next two subsubsections assume that a regular expression with /g is being used.
<br>

<br>
43.5 Methods for working with regular expressions
<br>

<br>
477
<br>

<br>
43.5.6.1 replacementValue is a string
<br>
If the replacement value is a string, the dollar sign has special meaning – it inserts text
<br>
matched by the regular expression:
<br>
Text
<br>

<br>
Result
<br>

<br>
$$
<br>

<br>
single $
<br>
complete match
<br>
text before match
<br>
text after match
<br>
capture of positional group n (n > 0)
<br>
capture of named group name [ES2018]
<br>

<br>
$&
<br>
$`
<br>
$'
<br>
$n
<br>
$<name>
<br>

<br>
Example: Inserting the text before, inside, and after the matched substring.
<br>
> 'a1 a2'.replace(/a/g, "($`|$&|$')")
<br>
'(|a|1 a2)1 (a1 |a|2)2'
<br>

<br>
Example: Inserting the captures of positional groups.
<br>
> const regExp = /^([A-Za-z]+): (.*)$/ug;
<br>
> 'first: Jane'.replace(regExp, 'KEY: $1, VALUE: $2')
<br>
'KEY: first, VALUE: Jane'
<br>

<br>
Example: Inserting the captures of named groups.
<br>
> const regExp = /^(?<key>[A-Za-z]+): (?<value>.*)$/ug;
<br>
> 'first: Jane'.replace(regExp, 'KEY: $<key>, VALUE: $<value>')
<br>
'KEY: first, VALUE: Jane'
<br>

<br>
43.5.6.2 replacementValue is a function
<br>
If the replacement value is a function, you can compute each replacement. In the following example, we multiply each non-negative integer that we ﬁnd by two.
<br>
assert.equal(
<br>
'3 cats and 4 dogs'.replace(/[0-9]+/g, (all) => 2 * Number(all)),
<br>
'6 cats and 8 dogs'
<br>
);
<br>

<br>
The replacement function gets the following parameters. Note how similar they are to
<br>
match objects. These parameters are all positional, but I’ve included how one might name
<br>
them:
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
all: complete match
<br>
g1: capture of positional group 1
<br>

<br>
Etc.
<br>
index: where did the match occur?
<br>
input: the string in which we are replacing
<br>
groups [ES2018] : captures of named groups (an object)
<br>

<br>
478
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
Exercise: Change quotes via .replace() and a named group
<br>
exercises/regexps/change_quotes_test.mjs
<br>

<br>
43.5.7 Other methods for working with regular expressions
<br>
String.prototype.split() is described in the chapter on strings. Its ﬁrst parameter of
<br>
String.prototype.split() is either a string or a regular expression. If it is the latter,
<br>

<br>
then captures of groups appear in the result:
<br>
> 'a:b : c'.split(':')
<br>
[ 'a', 'b ', ' c' ]
<br>
> 'a:b : c'.split(/ *: */)
<br>
[ 'a', 'b', 'c' ]
<br>
> 'a:b : c'.split(/( *):( *)/)
<br>
[ 'a', '', '', 'b', ' ', ' ', 'c' ]
<br>

<br>
43.6 Flag /g and its pitfalls
<br>
The following two regular expression methods work differently if /g is switched on:
<br>
• RegExp.prototype.exec()
<br>
• RegExp.prototype.test()
<br>
Then they can be called repeatedly and deliver all matches inside a string. Property
<br>
.lastIndex of the regular expression is used to track the current position inside the string
<br>
– for example:
<br>
const r = /a/g;
<br>
assert.equal(r.lastIndex, 0);
<br>
assert.equal(r.test('aa'), true); // 1st match?
<br>
assert.equal(r.lastIndex, 1); // after 1st match
<br>
assert.equal(r.test('aa'), true); // 2nd match?
<br>
assert.equal(r.lastIndex, 2); // after 2nd match
<br>
assert.equal(r.test('aa'), false); // 3rd match?
<br>
assert.equal(r.lastIndex, 0); // start over
<br>

<br>
The next subsections explain the pitfalls of using /g. They are followed by a subsection
<br>
that explains how to work around those pitfalls.
<br>

<br>
43.6.1 Pitfall: You can’t inline a regular expression with ﬂag /g
<br>
A regular expression with /g can’t be inlined. For example, in the following while loop,
<br>
the regular expression is created fresh, every time the condition is checked. Therefore, its
<br>
.lastIndex is always zero and the loop never terminates.
<br>

<br>
43.6 Flag /g and its pitfalls
<br>

<br>
479
<br>

<br>
let count = 0;
<br>
// Infinite loop
<br>
while (/a/g.test('babaa')) {
<br>
count++;
<br>
}
<br>

<br>
43.6.2 Pitfall: Removing /g can break code
<br>
If code expects a regular expression with /g and has a loop over the results of .exec() or
<br>
.test(), then a regular expression without /g can cause an inﬁnite loop:
<br>
function countMatches(regExp) {
<br>
let count = 0;
<br>
// Infinite loop
<br>
while (regExp.exec('babaa')) {
<br>
count++;
<br>
}
<br>
return count;
<br>
}
<br>
countMatches(/a/); // Missing: flag /g
<br>

<br>
Why? Because .exec() always returns the ﬁrst result, a match object, and never null.
<br>

<br>
43.6.3 Pitfall: Adding /g can break code
<br>
With .test(), there is another caveat: if you want to check exactly once if a regular expression matches a string, then the regular expression must not have /g. Otherwise, you
<br>
generally get a different result every time you call .test():
<br>
function isMatching(regExp) {
<br>
return regExp.test('Xa');
<br>
}
<br>
const myRegExp = /^X/g;
<br>
assert.equal(isMatching(myRegExp), true);
<br>
assert.equal(isMatching(myRegExp), false);
<br>

<br>
Normally, you won’t add /g if you intend to use .test() in this manner. But it can
<br>
happen if, for example, you use the same regular expression for testing and for replacing.
<br>

<br>
43.6.4 Pitfall: Code can break if .lastIndex isn’t zero
<br>
If you match a regular expression multiple times via .exec() or .test(), the current
<br>
position inside the input string is stored in the regular expression property .lastIndex.
<br>
Therefore, code that matches multiple times may break if .lastIndex is not zero:
<br>
function countMatches(regExp) {
<br>
let count = 0;
<br>
while (regExp.exec('babaa')) {
<br>
count++;
<br>
}
<br>
return count;
<br>

<br>
480
<br>

<br>
43 Regular expressions (RegExp)
<br>

<br>
}
<br>
const myRegExp = /a/g;
<br>
myRegExp.lastIndex = 4;
<br>
assert.equal(countMatches(myRegExp), 1); // should be 3
<br>

<br>
Note that .lastIndex is always zero in newly created regular expressions, but it may not
<br>
be if the same regular expression is used multiple times.
<br>

<br>
43.6.5 Dealing with /g and .lastIndex
<br>
As an example of dealing with /g and .lastIndex, we will implement the following
<br>
function:
<br>
countMatches(regExp, str)
<br>

<br>
It counts how often regExp has a match inside str. How do we prevent a wrong regExp
<br>
from breaking our code? Let’s look at three approaches.
<br>
First, we can throw an exception if /g isn’t set or .lastIndex isn’t zero:
<br>
function countMatches(regExp, str) {
<br>
if (!regExp.global) {
<br>
throw new Error('Flag /g of regExp must be set');
<br>
}
<br>
if (regExp.lastIndex !== 0) {
<br>
throw new Error('regExp.lastIndex must be zero');
<br>
}
<br>
let count = 0;
<br>
while (regExp.test(str)) {
<br>
count++;
<br>
}
<br>
return count;
<br>
}
<br>

<br>
Second, we can clone the parameter. That has the added beneﬁt that regExp won’t be
<br>
changed.
<br>
function countMatches(regExp, str) {
<br>
const cloneFlags = regExp.flags + (regExp.global ? '' : 'g');
<br>
const clone = new RegExp(regExp, cloneFlags);
<br>
let count = 0;
<br>
while (clone.test(str)) {
<br>
count++;
<br>
}
<br>
return count;
<br>
}
<br>

<br>
Third, we can use .match() to count occurrences, which doesn’t change or depend on
<br>
.lastIndex.
<br>

<br>
43.7 Techniques for working with regular expressions
<br>

<br>
481
<br>

<br>
function countMatches(regExp, str) {
<br>
if (!regExp.global) {
<br>
throw new Error('Flag /g of regExp must be set');
<br>
}
<br>
return (str.match(regExp) || []).length;
<br>
}
<br>

<br>
43.7 Techniques for working with regular expressions
<br>
43.7.1 Escaping arbitrary text for regular expressions
<br>
The following function escapes an arbitrary text so that it is matched verbatim if you put
<br>
it inside a regular expression:
<br>
function escapeForRegExp(str) {
<br>
return str.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'); // (A)
<br>
}
<br>
assert.equal(escapeForRegExp('[yes?]'), String.raw`\[yes\?\]`);
<br>
assert.equal(escapeForRegExp('_g_'), String.raw`_g_`);
<br>

<br>
In line A, we escape all syntax characters. We have to be selective because the regular
<br>
expression ﬂag /u forbids many escapes – for example: \a \: \The regular expression method .replace() only lets you replace plain text once. With
<br>
escapeForRegExp(), we can work around that limitation and replace plain text multiple
<br>
times:
<br>
const plainText = ':-)';
<br>
const regExp = new RegExp(escapeForRegExp(plainText), 'ug');
<br>
assert.equal(
<br>
':-) :-) :-)'.replace(regExp, '☺'), '☺ ☺ ☺');
<br>

<br>
43.7.2 Matching everything or nothing
<br>
Sometimes, you may need a regular expression that matches everything or nothing – for
<br>
example, as a default value.
<br>
• Match everything: /(?:)/
<br>
The empty group () matches everything. We make it non-capturing (via ?:), to
<br>
avoid unnecessary work.
<br>
> /(?:)/.test('')
<br>
true
<br>
> /(?:)/.test('abc')
<br>
true
<br>

<br>
• Match nothing: /.^/
<br>
^ only matches at the beginning of a string. The dot moves matching beyond the
<br>

<br>
ﬁrst character and now ^ doesn’t match anymore.
<br>

<br>
482
<br>

<br>
43 Regular expressions (RegExp)
<br>
> /.^/.test('')
<br>
false
<br>
> /.^/.test('abc')
<br>
false
<br>

<br>
Chapter 44
<br>

<br>
Dates (Date)
<br>
Contents
<br>
44.1 Best practice: avoid the built-in Date . . . . . . . . . . . . . . . . . . 483
<br>
44.1.1 Things to look for in a date library . . . . . . . . . . . . . . . . 484
<br>
44.2 Time standards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484
<br>
44.2.1 Background: UTC vs. Z vs. GMT
<br>

<br>
. . . . . . . . . . . . . . . . 484
<br>

<br>
44.2.2 Dates do not support time zones . . . . . . . . . . . . . . . . . 484
<br>
44.3 Background: date time formats (ISO) . . . . . . . . . . . . . . . . . . 485
<br>
44.3.1 Tip: append a Z to make date parsing deterministic . . . . . . 486
<br>
44.4 Time values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 486
<br>
44.4.1 Creating time values . . . . . . . . . . . . . . . . . . . . . . . 487
<br>
44.4.2 Getting and setting time values . . . . . . . . . . . . . . . . . 487
<br>
44.5 Creating Dates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
<br>
44.5.1 Creating dates via numbers
<br>

<br>
. . . . . . . . . . . . . . . . . . . 487
<br>

<br>
44.5.2 Parsing dates from strings . . . . . . . . . . . . . . . . . . . . 488
<br>
44.5.3 Other ways of creating dates . . . . . . . . . . . . . . . . . . . 488
<br>
44.6 Getters and setters . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488
<br>
44.6.1 Time unit getters and setters . . . . . . . . . . . . . . . . . . . 488
<br>
44.7 Converting Dates to strings . . . . . . . . . . . . . . . . . . . . . . . 489
<br>
44.7.1 Strings with times . . . . . . . . . . . . . . . . . . . . . . . . . 489
<br>
44.7.2 Strings with dates . . . . . . . . . . . . . . . . . . . . . . . . . 490
<br>
44.7.3 Strings with dates and times . . . . . . . . . . . . . . . . . . . 490
<br>
44.7.4 Other methods . . . . . . . . . . . . . . . . . . . . . . . . . . 490
<br>

<br>
This chapter describes JavaScript’s API for working with dates – the class Date.
<br>

<br>
44.1 Best practice: avoid the built-in Date
<br>
The JavaScript Date API is cumbersome to use. Hence, it’s best to rely on a library for
<br>
anything related to dates. Popular libraries include:
<br>
483
<br>

<br>
484
<br>

<br>
44 Dates (Date)
<br>

<br>
•
<br>
•
<br>
•
<br>
•
<br>
•
<br>

<br>
Moment.js
<br>
Day.js
<br>
Luxon
<br>
js-joda
<br>
date-fns
<br>

<br>
Consult the blog post “Why you shouldn’t use Moment.js…” for the pros and cons of
<br>
these libraries.
<br>
Additionally, TC39 is working on a new date API for JavaScript: temporal.
<br>

<br>
44.1.1 Things to look for in a date library
<br>
Two things are important to keep in mind:
<br>
• Tree-shaking can considerably reduce the size of a library. It is a technique of only
<br>
deploying those exports of a library to a web server that are imported somewhere.
<br>
Functions are much more amenable to tree-shaking than classes.
<br>
• Support for time zones: As explained later, Date does not support time zones,
<br>
which introduces a number of pitfalls and is a key weakness. Make sure that your
<br>
date library supports them.
<br>

<br>
44.2 Time standards
<br>
44.2.1 Background: UTC vs. Z vs. GMT
<br>
UTC, Z, and GMT are ways of specifying time that are similar, but subtly different:
<br>
• UTC (Coordinated Universal Time) is the time standard that all times zones are
<br>
based on. They are speciﬁed relative to it. That is, no country or territory has UTC
<br>
as its local time zone.
<br>
• Z (Zulu Time Zone) is a military time zone that is often used in aviation and the
<br>
military as another name for UTC+0.
<br>
• GMT (Greenwich Mean Time) is a time zone used in some European and African
<br>
countries. It is UTC plus zero hours and therefore has the same time as UTC.
<br>
Sources:
<br>
• “The Difference Between GMT and UTC” at TimeAndDate.com
<br>
• “Z – Zulu Time Zone (Military Time)” at TimeAndDate.com
<br>

<br>
44.2.2 Dates do not support time zones
<br>
Dates support the following time standards:
<br>
• The local time zone (which depends on the current location)
<br>
• UTC
<br>
• Time offsets (relative to UTC)
<br>

<br>
44.3 Background: date time formats (ISO)
<br>

<br>
485
<br>

<br>
Depending on the operation, only some of those options are available. For example,
<br>
when converting dates to strings or extracting time units such as the day of the month,
<br>
you can only choose between the local time zone and UTC.
<br>
Internally, Dates are stored as UTC. When converting from or to the local time zone, the
<br>
necessary offsets are determined via the date. In the following example, the local time
<br>
zone is Europe/Paris:
<br>
// CEST (Central European Summer Time)
<br>
assert.equal(
<br>
new Date('2122-06-29').getTimezoneOffset(), -120);
<br>
// CET (Central European Time)
<br>
assert.equal(
<br>
new Date('2122-12-29').getTimezoneOffset(), -60);
<br>

<br>
Whenever you create or convert dates, you need to be mindful of the time standard being
<br>
used – for example: new Date() uses the local time zone while .toISOString() uses UTC.
<br>
> new Date(2077, 0, 27).toISOString()
<br>
'2077-01-26T23:00:00.000Z'
<br>

<br>
Dates interpret 0 as January. The day of the month is 27 in the local time zone, but 26 in
<br>
UTC.
<br>

<br>
Documenting the time standards supported by each operation
<br>
In the remainder of this chapter, the supported time standards are noted for each
<br>
operation.
<br>
44.2.2.1 The downsides of not being able to specify time zones
<br>
Not being able to specify time zones has two downsides:
<br>
• It makes it impossible to support multiple time zones.
<br>
• It can lead to location-speciﬁc bugs. For example, the previous example produces
<br>
different results depending on where it is executed. To be safe:
<br>
– Use UTC-based operations whenever possible
<br>
– Use Z or a time offset when parsing strings (see the next section for more
<br>
information).
<br>

<br>
44.3 Background: date time formats (ISO)
<br>
Date time formats describe:
<br>
• The strings accepted by:
<br>
– Date.parse()
<br>
– new Date()
<br>
• The strings returned by (always longest format):
<br>

<br>
486
<br>

<br>
44 Dates (Date)
<br>

<br>
– Date.prototype.toISOString()
<br>
The following is an example of a date time string returned by .toISOString():
<br>
'2033-05-28T15:59:59.123Z'
<br>

<br>
Date time formats have the following structures:
<br>
• Date formats: Y=year; M=month; D=day
<br>
YYYY-MM-DD
<br>
YYYY-MM
<br>
YYYY
<br>

<br>
• Time formats: T=separator (the string 'T'); H=hour; m=minute; s=second and millisecond; Z=Zulu Time Zone (the string 'Z')
<br>
THH:mm:ss.sss
<br>
THH:mm:ss.sssZ
<br>
THH:mm:ss
<br>
THH:mm:ssZ
<br>
THH:mm
<br>
THH:mmZ
<br>

<br>
• Date time formats: are date formats followed by time formats.
<br>
– For example (longest): YYYY-MM-DDTHH:mm:ss.sssZ
<br>
Instead of Z (which is UTC+0), we can also specify time offsets relative to UTC:
<br>
• THH:mm+HH:mm (etc.)
<br>
• THH:mm-HH:mm (etc.)
<br>

<br>
44.3.1 Tip: append a Z to make date parsing deterministic
<br>
If you add a Z to the end of a string, date parsing doesn’t produce different results at
<br>
different locations:
<br>
• Without Z: Input is January 27 (in the Europe/Paris time zone), output is January
<br>
26 (in UTC).
<br>
> new Date('2077-01-27T00:00').toISOString()
<br>
'2077-01-26T23:00:00.000Z'
<br>

<br>
• With Z: Input is January 27, output is January 27.
<br>
> new Date('2077-01-27T00:00Z').toISOString()
<br>
'2077-01-27T00:00:00.000Z'
<br>

<br>
44.4 Time values
<br>
A time value represents a date via the number of milliseconds since 1 January 1970 00:00:00
<br>
UTC.
<br>

<br>
44.5 Creating Dates
<br>

<br>
487
<br>

<br>
Time values can be used to create Dates:
<br>
const timeValue = 0;
<br>
assert.equal(
<br>
new Date(timeValue).toISOString(),
<br>
'1970-01-01T00:00:00.000Z');
<br>

<br>
Coercing a Date to a number returns its time value:
<br>
> Number(new Date(123))
<br>
123
<br>

<br>
Ordering operators coerce their operands to numbers. Therefore, you can use these operators to compare Dates:
<br>
assert.equal(
<br>
new Date('1972-05-03') < new Date('2001-12-23'), true);
<br>
// Internally:
<br>
assert.equal(73699200000 < 1009065600000, true);
<br>

<br>
44.4.1 Creating time values
<br>
The following methods create time values:
<br>
• Date.now(): number (UTC)
<br>
Returns the current time as a time value.
<br>
• Date.parse(dateTimeStr: string): number (local time zone, UTC, time offset)
<br>
Parses dateTimeStr and returns the corresponding time value.
<br>
• Date.UTC(year,month,date?,hours?,minutes?,seconds?,milliseconds?):
<br>
number (UTC)
<br>
Returns the time value for the speciﬁed UTC date time.
<br>

<br>
44.4.2 Getting and setting time values
<br>
• Date.prototype.getTime(): number (UTC)
<br>
Returns the time value corresponding to the Date.
<br>
• Date.prototype.setTime(timeValue) (UTC)
<br>
Sets this to the date encoded by timeValue.
<br>

<br>
44.5 Creating Dates
<br>
44.5.1 Creating dates via numbers
<br>
new Date(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number) (local time zone)
<br>

<br>
488
<br>

<br>
44 Dates (Date)
<br>

<br>
Two of the parameters have pitfalls:
<br>
• For month, 0 is January, 1 is February, etc.
<br>
• If 0 ≤ year ≤ 99, then 1900 is added:
<br>
> new Date(12, 1, 22, 19, 11).getFullYear()
<br>
1912
<br>

<br>
That’s why, elsewhere in this chapter, we avoid the time unit year and always use
<br>
fullYear. But in this case, we have no choice.
<br>
Example:
<br>
> new Date(2077,0,27, 21,49).toISOString() // CET (UTC+1)
<br>
'2077-01-27T20:49:00.000Z'
<br>

<br>
Note that the input hours (21) are different from the output hours (20). The former refer
<br>
to the local time zone, the latter to UTC.
<br>

<br>
44.5.2 Parsing dates from strings
<br>
new Date(dateTimeStr: string) (local time zone, UTC, time offset)
<br>

<br>
If there is a Z at the end, UTC is used:
<br>
> new Date('2077-01-27T00:00Z').toISOString()
<br>
'2077-01-27T00:00:00.000Z'
<br>

<br>
If there is not Z or time offset at the end, the local time zone is used:
<br>
> new Date('2077-01-27T00:00').toISOString() // CET (UTC+1)
<br>
'2077-01-26T23:00:00.000Z'
<br>

<br>
If a string only contains a date, it is interpreted as UTC:
<br>
> new Date('2077-01-27').toISOString()
<br>
'2077-01-27T00:00:00.000Z'
<br>

<br>
44.5.3 Other ways of creating dates
<br>
• new Date(timeValue: number) (UTC)
<br>
> new Date(0).toISOString()
<br>
'1970-01-01T00:00:00.000Z'
<br>

<br>
• new Date() (UTC)
<br>
The same as new Date(Date.now()).
<br>

<br>
44.6 Getters and setters
<br>
44.6.1 Time unit getters and setters
<br>
Dates have getters and setters for time units – for example:
<br>

<br>
44.7 Converting Dates to strings
<br>

<br>
489
<br>

<br>
• Date.prototype.getFullYear()
<br>
• Date.prototype.setFullYear(num)
<br>
These getters and setters conform to the following patterns:
<br>
• Local time zone:
<br>
– Date.prototype.get«Unit»()
<br>
– Date.prototype.set«Unit»(num)
<br>
• UTC:
<br>
– Date.prototype.getUTC«Unit»()
<br>
– Date.prototype.setUTC«Unit»(num)
<br>
These are the time units that are supported:
<br>
• Date
<br>
– FullYear
<br>
– Month: month (0–11). Pitfall: 0 is January, etc.
<br>
– Date: day of the month (1–31)
<br>
– Day (getter only): day of the week (0–6, 0 is Sunday)
<br>
• Time
<br>
– Hours: hour (0–23)
<br>
– Minutes: minutes (0–59)
<br>
– Seconds: seconds (0–59)
<br>
– Milliseconds: milliseconds (0–999)
<br>
There is one more getter that doesn’t conform to the previously mentioned patterns:
<br>
• Date.prototype.getTimezoneOffset()
<br>
Returns the time difference between local time zone and UTC in minutes. For example, for Europe/Paris, it returns -120 (CEST, Central European Summer Time)
<br>
or -60 (CET, Central European Time):
<br>
> new Date('2122-06-29').getTimezoneOffset()
<br>
-120
<br>
> new Date('2122-12-29').getTimezoneOffset()
<br>
-60
<br>

<br>
44.7 Converting Dates to strings
<br>
Example Date:
<br>
const d = new Date(0);
<br>

<br>
44.7.1 Strings with times
<br>
• Date.prototype.toTimeString() (local time zone)
<br>
> d.toTimeString()
<br>
'01:00:00 GMT+0100 (Central European Standard Time)'
<br>

<br>
490
<br>

<br>
44 Dates (Date)
<br>

<br>
44.7.2 Strings with dates
<br>
• Date.prototype.toDateString() (local time zone)
<br>
> d.toDateString()
<br>
'Thu Jan 01 1970'
<br>

<br>
44.7.3 Strings with dates and times
<br>
• Date.prototype.toString() (local time zone)
<br>
> d.toString()
<br>
'Thu Jan 01 1970 01:00:00 GMT+0100 (Central European Standard Time)'
<br>

<br>
• Date.prototype.toUTCString() (UTC)
<br>
> d.toUTCString()
<br>
'Thu, 01 Jan 1970 00:00:00 GMT'
<br>

<br>
• Date.prototype.toISOString() (UTC)
<br>
> d.toISOString()
<br>
'1970-01-01T00:00:00.000Z'
<br>

<br>
44.7.4 Other methods
<br>
The following three methods are not really part of ECMAScript, but rather of the ECMAScript internationalization API. That API has much functionality for formatting dates
<br>
(including support for time zones), but not for parsing them.
<br>
• Date.prototype.toLocaleTimeString()
<br>
• Date.prototype.toLocaleDateString()
<br>
• Date.prototype.toLocaleString()
<br>

<br>
Exercise: Creating a date string
<br>
exercises/dates/create_date_string_test.mjs
<br>

<br>
Chapter 45
<br>

<br>
Creating and parsing JSON (JSON)
<br>
Contents
<br>
45.1 The discovery and standardization of JSON . . . . . . . . . . . . . . 492
<br>
45.1.1 JSON’s grammar is frozen . . . . . . . . . . . . . . . . . . . . 492
<br>
45.2 JSON syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
<br>
45.3 Using the JSON API . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
<br>
45.3.1 JSON.stringify(data, replacer?, space?) . . . . . . . . . 493
<br>
45.3.2 JSON.parse(text, reviver?) . . . . . . . . . . . . . . . . . . 494
<br>
45.3.3 Example: converting to and from JSON . . . . . . . . . . . . . 495
<br>
45.4 Customizing stringiﬁcation and parsing (advanced) . . . . . . . . . 495
<br>
45.4.1 .stringfy(): specifying which properties of objects to stringify 496
<br>
45.4.2 .stringify() and .parse(): value visitors . . . . . . . . . . . 496
<br>
45.4.3 Example: visiting values . . . . . . . . . . . . . . . . . . . . . 497
<br>
45.4.4 Example: stringifying unsupported values . . . . . . . . . . . 497
<br>
45.4.5 Example: parsing unsupported values
<br>

<br>
. . . . . . . . . . . . . 498
<br>

<br>
45.5 FAQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
<br>
45.5.1 Why doesn’t JSON support comments? . . . . . . . . . . . . . 499
<br>

<br>
JSON (“JavaScript Object Notation”) is a storage format that uses text to encode data. Its
<br>
syntax is a subset of JavaScript expressions. As an example, consider the following text,
<br>
stored in a ﬁle jane.json:
<br>
{
<br>
"first": "Jane",
<br>
"last": "Porter",
<br>
"married": true,
<br>
"born": 1890,
<br>
"friends": [ "Tarzan", "Cheeta" ]
<br>
}
<br>

<br>
JavaScript has the global namespace object JSON that provides methods for creating and
<br>
parsing JSON.
<br>
491
<br>

<br>
492
<br>

<br>
45 Creating and parsing JSON (JSON)
<br>

<br>
45.1 The discovery and standardization of JSON
<br>
A speciﬁcation for JSON was published by Douglas Crockford in 2001, at json.org. He
<br>
explains:
<br>
I discovered JSON. I do not claim to have invented JSON because it already
<br>
existed in nature. What I did was I found it, I named it, I described how it
<br>
was useful. I don’t claim to be the ﬁrst person to have discovered it; I know
<br>
that there are other people who discovered it at least a year before I did. The
<br>
earliest occurrence I’ve found was, there was someone at Netscape who was
<br>
using JavaScript array literals for doing data communication as early as 1996,
<br>
which was at least ﬁve years before I stumbled onto the idea.
<br>
Later, JSON was standardized as ECMA-404:
<br>
• 1st edition: October 2013
<br>
• 2nd edition: December 2017
<br>

<br>
45.1.1 JSON’s grammar is frozen
<br>
Quoting the ECMA-404 standard:
<br>
Because it is so simple, it is not expected that the JSON grammar will ever
<br>
change. This gives JSON, as a foundational notation, tremendous stability.
<br>
Therefore, JSON will never get improvements such as optional trailing commas, comments, or unquoted keys – independently of whether or not they are considered desirable. However, that still leaves room for creating supersets of JSON that compile to plain
<br>
JSON.
<br>

<br>
45.2 JSON syntax
<br>
JSON consists of the following parts of JavaScript:
<br>
• Compound:
<br>
– Object literals:
<br>
* Property keys are double-quoted strings.
<br>
* Property values are JSON values.
<br>
* No trailing commas are allowed.
<br>
– Array literals:
<br>
* Elements are JSON values.
<br>
* No holes or trailing commas are allowed.
<br>
• Atomic:
<br>
– null (but not undefined)
<br>
– Booleans
<br>
– Numbers (excluding NaN, +Infinity, -Infinity)
<br>
– Strings (must be double-quoted)
<br>
As a consequence, you can’t (directly) represent cyclic structures in JSON.
<br>

<br>
45.3 Using the JSON API
<br>

<br>
493
<br>

<br>
45.3 Using the JSON API
<br>
The global namespace object JSON contains methods for working with JSON data.
<br>

<br>
45.3.1
<br>

<br>
JSON.stringify(data, replacer?, space?)
<br>

<br>
.stringify() converts JavaScript data to a JSON string. In this section, we are ignoring
<br>
the parameter replacer; it is explained in §45.4 “Customizing stringiﬁcation and parsing”.
<br>

<br>
45.3.1.1 Result: a single line of text
<br>
If you only provide the ﬁrst argument, .stringify() returns a single line of text:
<br>
assert.equal(
<br>
JSON.stringify({foo: ['a', 'b']}),
<br>
'{"foo":["a","b"]}' );
<br>

<br>
45.3.1.2 Result: a tree of indented lines
<br>
If you provide a non-negative integer for space, then .stringify() returns one or more
<br>
lines and indents by space spaces per level of nesting:
<br>
assert.equal(
<br>
JSON.stringify({foo: ['a', 'b']}, null, 2),
<br>
`{
<br>
"foo": [
<br>
"a",
<br>
"b"
<br>
]
<br>
}`);
<br>

<br>
45.3.1.3 Details on how JavaScript data is stringiﬁed
<br>
Primitive values:
<br>
• Supported primitive values are stringiﬁed as expected:
<br>
> JSON.stringify('abc')
<br>
'"abc"'
<br>
> JSON.stringify(123)
<br>
'123'
<br>
> JSON.stringify(null)
<br>
'null'
<br>

<br>
• Unsupported numbers: 'null'
<br>
> JSON.stringify(NaN)
<br>
'null'
<br>
> JSON.stringify(Infinity)
<br>
'null'
<br>

<br>
494
<br>

<br>
45 Creating and parsing JSON (JSON)
<br>

<br>
• Other unsupported primitive values are not stringiﬁed; they produce the result
<br>
undefined:
<br>
> JSON.stringify(undefined)
<br>
undefined
<br>
> JSON.stringify(Symbol())
<br>
undefined
<br>

<br>
Objects:
<br>
• If an object has a method .toJSON(), then the result of that method is stringiﬁed:
<br>
> JSON.stringify({toJSON() {return true}})
<br>
'true'
<br>

<br>
Dates have a method .toJSON() that returns a string:
<br>
> JSON.stringify(new Date(2999, 11, 31))
<br>
'"2999-12-30T23:00:00.000Z"'
<br>

<br>
• Wrapped primitive values are unwrapped and stringiﬁed:
<br>
> JSON.stringify(new Boolean(true))
<br>
'true'
<br>
> JSON.stringify(new Number(123))
<br>
'123'
<br>

<br>
• Arrays are stringiﬁed as Array literals. Unsupported Array elements are stringiﬁed
<br>
as if they were null:
<br>
> JSON.stringify([undefined, 123, Symbol()])
<br>
'[null,123,null]'
<br>

<br>
• All other objects – except for functions – are stringiﬁed as object literals. Properties
<br>
with unsupported values are omitted:
<br>
> JSON.stringify({a: Symbol(), b: true})
<br>
'{"b":true}'
<br>

<br>
• Functions are not stringiﬁed:
<br>
> JSON.stringify(() => {})
<br>
undefined
<br>

<br>
45.3.2
<br>

<br>
JSON.parse(text, reviver?)
<br>

<br>
.parse() converts a JSON text to a JavaScript value. In this section, we are ignoring the
<br>

<br>
parameter reviver; it is explained §45.4 “Customizing stringiﬁcation and parsing”.
<br>
This is an example of using .parse():
<br>
> JSON.parse('{"foo":["a","b"]}')
<br>
{ foo: [ 'a', 'b' ] }
<br>

<br>
45.4 Customizing stringiﬁcation and parsing (advanced)
<br>

<br>
495
<br>

<br>
45.3.3 Example: converting to and from JSON
<br>
The following class implements conversions from (line A) and to (line B) JSON.
<br>
class Point {
<br>
static fromJson(jsonObj) { // (A)
<br>
return new Point(jsonObj.x, jsonObj.y);
<br>
}
<br>
constructor(x, y) {
<br>
this.x = x;
<br>
this.y = y;
<br>
}
<br>
toJSON() { // (B)
<br>
return {x: this.x, y: this.y};
<br>
}
<br>
}
<br>

<br>
• Converting JSON to a point: We use the static method Point.fromJson() to parse
<br>
JSON and create an instance of Point.
<br>
assert.deepEqual(
<br>
Point.fromJson(JSON.parse('{"x":3,"y":5}')),
<br>
new Point(3, 5) );
<br>

<br>
• Converting a point to JSON: JSON.stringify() internally calls the previously mentioned method .toJSON().
<br>
assert.equal(
<br>
JSON.stringify(new Point(3, 5)),
<br>
'{"x":3,"y":5}' );
<br>

<br>
Exercise: Converting an object to and from JSON
<br>
exercises/json/to_from_json_test.mjs
<br>

<br>
45.4 Customizing stringiﬁcation and parsing (advanced)
<br>
Stringiﬁcation and parsing can be customized as follows:
<br>
• JSON.stringify(data, replacer?, space?)
<br>
The optional parameter replacer contains either:
<br>
– An Array with names of properties. If a value in data is stringiﬁed as an
<br>
object literal, then only the mentioned properties are considered. All other
<br>
properties are ignored.
<br>
– A value visitor, a function that can transform JavaScript data before it is stringiﬁed.
<br>
• JSON.parse(text, reviver?)
<br>

<br>
496
<br>

<br>
45 Creating and parsing JSON (JSON)
<br>

<br>
The optional parameter reviver contains a value visitor that can transform the
<br>
parsed JSON data before it is returned.
<br>

<br>
45.4.1
<br>

<br>
.stringfy(): specifying which properties of objects to stringify
<br>

<br>
If the second parameter of .stringify() is an Array, then only object properties, whose
<br>
names are mentioned there, are included in the result:
<br>
const obj = {
<br>
a: 1,
<br>
b: {
<br>
c: 2,
<br>
d: 3,
<br>
}
<br>
};
<br>
assert.equal(
<br>
JSON.stringify(obj, ['b', 'c']),
<br>
'{"b":{"c":2}}');
<br>

<br>
45.4.2
<br>

<br>
.stringify() and .parse(): value visitors
<br>

<br>
What I call a value visitor is a function that transforms JavaScript data:
<br>
• JSON.stringify() lets the value visitor in its parameter replacer transform
<br>
JavaScript data before it is stringiﬁed.
<br>
• JSON.parse() lets the value visitor in its parameter reviver transform parsed
<br>
JavaScript data before it is returned.
<br>
In this section, JavaScript data is considered to be a tree of values. If the data is atomic,
<br>
it is a tree that only has a root. All values in the tree are fed to the value visitor, one at
<br>
a time. Depending on what the visitor returns, the current value is omitted, changed, or
<br>
preserved.
<br>
A value visitor has the following type signature:
<br>
type ValueVisitor = (key: string, value: any) => any;
<br>

<br>
The parameters are:
<br>
• value: The current value.
<br>
• this: Parent of current value. The parent of the root value r is {'': r}.
<br>
– Note: this is an implicit parameter and only available if the value visitor is
<br>
an ordinary function.
<br>
• key: Key or index of the current value inside its parent. The key of the root value
<br>
is ''.
<br>
The value visitor can return:
<br>
• value: means there won’t be any change.
<br>
• A different value x: leads to value being replaced with x in the output tree.
<br>
• undefined: leads to value being omitted in the output tree.
<br>

<br>
497
<br>

<br>
45.4 Customizing stringiﬁcation and parsing (advanced)
<br>

<br>
45.4.3 Example: visiting values
<br>
The following code shows in which order a value visitor sees values:
<br>
const log = [];
<br>
function valueVisitor(key, value) {
<br>
log.push({this: this, key, value});
<br>
return value; // no change
<br>
}
<br>
const root = {
<br>
a: 1,
<br>
b: {
<br>
c: 2,
<br>
d: 3,
<br>
}
<br>
};
<br>
JSON.stringify(root, valueVisitor);
<br>
assert.deepEqual(log, [
<br>
{ this: { '': root }, key: '',
<br>

<br>
value: root
<br>

<br>
},
<br>

<br>
{ this: root
<br>

<br>
, key: 'a', value: 1
<br>

<br>
{ this: root
<br>

<br>
, key: 'b', value: root.b },
<br>

<br>
},
<br>

<br>
{ this: root.b
<br>

<br>
, key: 'c', value: 2
<br>

<br>
},
<br>

<br>
{ this: root.b
<br>

<br>
, key: 'd', value: 3
<br>

<br>
},
<br>

<br>
]);
<br>

<br>
As we can see, the replacer of JSON.stringify() visits values top-down (root ﬁrst, leaves
<br>
last). The rationale for going in that direction is that we are converting JavaScript values
<br>
to JSON values. And a single JavaScript object may be expanded into a tree of JSONcompatible values.
<br>
In contrast, the reviver of JSON.parse() visits values bottom-up (leaves ﬁrst, root last).
<br>
The rationale for going in that direction is that we are assembling JSON values into
<br>
JavaScript values. Therefore, we need to convert the parts before we can convert the
<br>
whole.
<br>

<br>
45.4.4 Example: stringifying unsupported values
<br>
JSON.stringify() has no special support for regular expression objects – it stringiﬁes
<br>
them as if they were plain objects:
<br>
const obj = {
<br>
name: 'abc',
<br>
regex: /abc/ui,
<br>
};
<br>
assert.equal(
<br>
JSON.stringify(obj),
<br>
'{"name":"abc","regex":{}}');
<br>

<br>
We can ﬁx that via a replacer:
<br>

<br>
498
<br>

<br>
45 Creating and parsing JSON (JSON)
<br>

<br>
function replacer(key, value) {
<br>
if (value instanceof RegExp) {
<br>
return {
<br>
__type__: 'RegExp',
<br>
source: value.source,
<br>
flags: value.flags,
<br>
};
<br>
} else {
<br>
return value; // no change
<br>
}
<br>
}
<br>
assert.equal(
<br>
JSON.stringify(obj, replacer, 2),
<br>
`{
<br>
"name": "abc",
<br>
"regex": {
<br>
"__type__": "RegExp",
<br>
"source": "abc",
<br>
"flags": "iu"
<br>
}
<br>
}`);
<br>

<br>
45.4.5 Example: parsing unsupported values
<br>
To JSON.parse() the result from the previous section, we need a reviver:
<br>
function reviver(key, value) {
<br>
// Very simple check
<br>
if (value && value.__type__ === 'RegExp') {
<br>
return new RegExp(value.source, value.flags);
<br>
} else {
<br>
return value;
<br>
}
<br>
}
<br>
const str = `{
<br>
"name": "abc",
<br>
"regex": {
<br>
"__type__": "RegExp",
<br>
"source": "abc",
<br>
"flags": "iu"
<br>
}
<br>
}`;
<br>
assert.deepEqual(
<br>
JSON.parse(str, reviver),
<br>
{
<br>
name: 'abc',
<br>
regex: /abc/ui,
<br>
});
<br>

<br>
45.5 FAQ
<br>

<br>
45.5 FAQ
<br>
45.5.1 Why doesn’t JSON support comments?
<br>
Douglas Crockford explains why in a Google+ post from 1 May 2012:
<br>
I removed comments from JSON because I saw people were using them to
<br>
hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it
<br>
shouldn’t.
<br>
Suppose you are using JSON to keep conﬁguration ﬁles, which you would
<br>
like to annotate. Go ahead and insert all the comments you like. Then pipe
<br>
it through JSMin [a miniﬁer for JavaScript] before handing it to your JSON
<br>
parser.
<br>

<br>
499
<br>

<br>
500
<br>

<br>
45 Creating and parsing JSON (JSON)
<br>

<br>
Part X
<br>

<br>
Miscellaneous topics
<br>

<br>
501
<br>

<br>
Chapter 46
<br>

<br>
Next steps: overview of web
<br>
development (bonus)
<br>
Contents
<br>
46.1 Tips against feeling overwhelmed . . . . . . . . . . . . . . . . . . . 503
<br>
46.2 Things worth learning for web development . . . . . . . . . . . . . 504
<br>
46.2.1 Keep an eye on WebAssembly (Wasm)! . . . . . . . . . . . . . 505
<br>
46.3 Example: tool-based JavaScript workﬂow . . . . . . . . . . . . . . . 506
<br>
46.4 An overview of JavaScript tools . . . . . . . . . . . . . . . . . . . . . 508
<br>
46.4.1 Building: getting from the JavaScript you write to the JavaScript
<br>
you deploy . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508
<br>
46.4.2 Static checking
<br>

<br>
. . . . . . . . . . . . . . . . . . . . . . . . . . 509
<br>

<br>
46.4.3 Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
<br>
46.4.4 Package managers . . . . . . . . . . . . . . . . . . . . . . . . 510
<br>
46.4.5 Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
<br>
46.5 Tools not related to JavaScript . . . . . . . . . . . . . . . . . . . . . . 510
<br>

<br>
You now know most of the JavaScript language. This chapter gives an overview of web
<br>
development and describes next steps. It answers questions such as:
<br>
• What should I learn next for web development?
<br>
• What JavaScript-related tools should I know about?
<br>

<br>
46.1 Tips against feeling overwhelmed
<br>
Web development has become a vast ﬁeld: Between JavaScript, web browsers, server-side
<br>
JavaScript, JavaScript libraries, and JavaScript tools, there is a lot to know. Additionally,
<br>
everything is always changing: some things go out of style, new things are invented, etc.
<br>
How can you avoid feeling overwhelmed when faced with this constantly changing vastness of knowledge?
<br>
503
<br>

<br>
504
<br>

<br>
46 Next steps: overview of web development (bonus)
<br>

<br>
• Focus on the web technologies that you work with most often and learn them well.
<br>
If you do frontend development, that may be JavaScript, CSS, SVG, or something
<br>
else.
<br>
• For JavaScript: Know the language, but also try out one tool in each of the following
<br>
categories (which are covered in more detail later).
<br>
– Compilers: compile future JavaScript or supersets of JavaScript to normal
<br>
JavaScript.
<br>
– Bundlers: combine all modules used by a web app into a single ﬁle (a script
<br>
or a module). That makes loading faster and enables dead code elimination.
<br>
– Static checkers. For example:
<br>
* Linters: check for anti-patterns, style violations, and more.
<br>
* Type checkers: type JavaScript statically and report errors.
<br>
– Test libraries and tools
<br>
– Version control (usually git)
<br>

<br>
Trust in your ability to learn on demand
<br>
It is commendable to learn something out of pure curiosity. But I’m wary of trying
<br>
to learn everything and spreading yourself too thin. That also induces an anxiety
<br>
of not knowing enough (because you never will). Instead, trust in your ability to
<br>
learn things on demand!
<br>

<br>
46.2 Things worth learning for web development
<br>
These are a few things worth learning for web development:
<br>
• Browser APIs such as the Document Object Model (DOM), the browsers’ representation of HTML in memory. They are the foundations of any kind of frontend
<br>
development.
<br>
• JavaScript-adjacent technologies such as HTML and CSS.
<br>
• Frontend frameworks: When you get started with web development, it can be instructive to write user interfaces without any libraries. Once you feel more conﬁdent, frontend frameworks make many things easier, especially for larger apps.
<br>
Popular frameworks include React, Angular, Vue, Ember, Svelte.
<br>
• Node.js is the most popular platform for server-side JavaScript. But it also lets you
<br>
run JavaScript in the command line. Most JavaScript-related tools (even compilers!) are implemented in Node.js-based JavaScript and installed via npm. A good
<br>
way to get started with Node.js, is to use it for shell scripting.
<br>
• JavaScript tooling: Modern web development involves many tools. Later in this
<br>
chapter, there is an overview of the current tooling ecosystem.
<br>
• Progressive web apps: The driving idea behind progressive web apps is to give web
<br>
apps features that, traditionally, only native apps had – for example: native installation on mobile and desktop operating systems; ofﬂine operation; showing notiﬁcations to users. Google has published a checklist detailing what makes a web app
<br>
progressive. The minimum requirements are:
<br>

<br>
46.2 Things worth learning for web development
<br>

<br>
505
<br>

<br>
– The app must be served over HTTPS (not the unsecure HTTP).
<br>
– The app must have a Web App Manifest ﬁle, specifying metadata such as app
<br>
name and icon (often in multiple resolutions). The ﬁle(s) of the icon must also
<br>
be present.
<br>
– The app must have a service worker: a base layer of the app that runs in the
<br>
background, in a separate process (independently of web pages). One of its
<br>
responsibilities is to keep the app functioning when there is no internet connection. Among others, two mechanisms help it do that: It is a local proxy
<br>
that supervises all of the web resource requests of the app. And it has access to
<br>
a browser’s cache. Therefore, it can use the cache to fulﬁll requests when the
<br>
app is ofﬂine – after initially caching all critical resources. Other capabilities
<br>
of service workers include synchronizing data in the background; receiving
<br>
server-sent push messages; and the aforementioned showing notiﬁcations to
<br>
users.
<br>
One good resource for learning web development – including and beyond JavaScript – is
<br>
MDN web docs.
<br>

<br>
46.2.1 Keep an eye on WebAssembly (Wasm)!
<br>
WebAssembly is a universal virtual machine that is built into most JavaScript engines.
<br>
You get the following distribution of work:
<br>
• JavaScript is for dynamic, higher-level code.
<br>
• WebAssembly is for static, lower-level code.
<br>
For static code, WebAssembly is quite fast: C/C++ code, compiled to WebAssembly, is
<br>
about 50% as fast as the same code, compiled to native (source). Use cases include support for new video formats, machine learning, gaming, etc.
<br>
WebAssembly works well as a compilation target for various languages. Does this mean
<br>
JavaScript will be compiled to WebAssembly or replaced by another language?
<br>
46.2.1.1 Will JavaScript be compiled to WebAssembly?
<br>
JavaScript engines perform many optimizations for JavaScript’s highly dynamic features.
<br>
If you wanted to compile JavaScript to WebAssembly, you’d have to implement these
<br>
optimizations on top of WebAssembly. The result would be slower than current engines
<br>
and have a similar code base. Therefore, you wouldn’t gain anything.
<br>
46.2.1.2 Will JavaScript be replaced by another language?
<br>
Does WebAssembly mean that JavaScript is about to be replaced by another language?
<br>
WebAssembly does make it easier to support languages other than JavaScript in web
<br>
browsers. But those languages face several challenges on that platform:
<br>
• All browser APIs are based on JavaScript.
<br>
• The runtimes (standard library, etc.) of other languages incur an additional memory overhead, whereas JavaScript’s runtime is already built into web browsers.
<br>
• JavaScript is well-known, has many libraries and tools, etc.
<br>

<br>
506
<br>

<br>
46 Next steps: overview of web development (bonus)
<br>

<br>
Additionally, many parts of the WebAssembly ecosystem (e.g., debugging) are works in
<br>
progress.
<br>
For dynamic code, JavaScript is comparatively fast. Therefore, for the foreseeable future,
<br>
it will probably remain the most popular choice for high-level code. For low-level code,
<br>
compiling more static languages (such as Rust) to WebAssembly is an intriguing option.
<br>
Given that it is just a virtual machine, there are not that many practically relevant things
<br>
to learn about WebAssembly. But it is worth keeping an eye on its evolving role in web
<br>
development. It is also becoming popular as a stand-alone virtual machine; e.g., supported by the WebAssembly System Interface.
<br>

<br>
46.3 Example: tool-based JavaScript workﬂow
<br>
<script src="code.js">
<br>
<script src="library.js">
<br>
index.html
<br>
loads
<br>
code.js
<br>

<br>
loads
<br>
library.js
<br>

<br>
Figure 46.1: A classic, very simple web app: An HTML ﬁle refers to a JavaScript ﬁle
<br>
code.js, which imbues the former with interactivity. code.js uses the library library.js, which must also be loaded by the HTML ﬁle.
<br>
Fig. 46.1 depicts a classic web app – when web development was less sophisticated (for
<br>
better and for worse):
<br>
• index.html contains the HTML ﬁle that is opened in web browsers.
<br>
• code.js contains the JavaScript code loaded and used by index.html.
<br>
• That code depends on the library library.js, a ﬁle that was downloaded manually and put next to code.js. It is accessed via a global variable. Note that the
<br>
HTML ﬁle needs to load the dependency library.js for code.js. code.js can’t
<br>
do that itself.
<br>
Since then, JavaScript workﬂows have become more complex. Fig. 46.2 shows such a
<br>
workﬂow – one that is based on the JavaScript bundler webpack.
<br>
Let’s examine the pieces (data, tools, technologies) involved in this workﬂow:
<br>
• The app itself consists of multiple modules, written in TypeScript – a language that
<br>
is a statically typed superset of JavaScript. Each ﬁle is an ECMAScript module,
<br>
plus static type annotations.
<br>
• The library used by the app is now downloaded and installed via the npm package manager. It also transparently handles transitive dependencies – if this package
<br>

<br>
507
<br>

<br>
46.3 Example: tool-based JavaScript workﬂow
<br>

<br>
Entry
<br>
Library via imports TypeScript imports TypeScript
<br>
npm
<br>
module
<br>
module
<br>
compiled to
<br>

<br>
compiled to
<br>
JS code
<br>

<br>
d
<br>

<br>
de
<br>

<br>
ad
<br>

<br>
JS code
<br>

<br>
to
<br>

<br>
added to
<br>

<br>
Output
<br>

<br>
bundle.js
<br>

<br>
de
<br>
ad
<br>

<br>
o
<br>

<br>
dt
<br>

<br>
loads
<br>
index.html
<br>
<script src="bundle.js">
<br>

<br>
Figure 46.2: This is the workﬂow when developing a web app with the bundler webpack.
<br>
Our web app consists of multiple modules. We tell webpack, in which one execution
<br>
starts (the so-called entry point). It then analyzes the imports of the entry point, the imports of the imports, etc., to determine what code is needed to run the app. All of that
<br>
code is put into a single script ﬁle.
<br>

<br>
508
<br>

<br>
46 Next steps: overview of web development (bonus)
<br>

<br>
depends on other packages, etc.
<br>
• All TypeScript ﬁles are compiled to plain JS via a loader, a plugin for webpack.
<br>
• The tool webpack combines all plain JavaScript ﬁles into a single JavaScript script
<br>
ﬁle. This process is called bundling. Bundling is done for two reasons:
<br>
– Downloading a single ﬁle is usually faster in web browsers.
<br>
– During bundling, you can perform various optimizations, such as leaving out
<br>
code that isn’t used.
<br>
The basic structure is still the same: the HTML ﬁle loads a JavaScript script ﬁle via a
<br>
<script> element. However:
<br>
• The code is now modular without the HTML ﬁle having to know the modules.
<br>
• bundle.js only includes the code that is needed to run the app (vs. all of library.js).
<br>
• We used a package manager to install the libraries that our code depends on.
<br>
• The libraries aren’t accessed via global variables but via ES module speciﬁers.
<br>
In modern browsers, you can also deliver the bundle as a module (vs. as a script ﬁle).
<br>

<br>
46.4 An overview of JavaScript tools
<br>
Now that we have seen one workﬂow, let’s look at various categories of tools that are
<br>
popular in the world of JavaScript. You’ll see categories of tools and lots of names of
<br>
speciﬁc tools. The former are much more important. The names change, as tools come
<br>
into and out of style, but I wanted you to see at least some of them.
<br>

<br>
46.4.1 Building: getting from the JavaScript you write to the JavaScript
<br>
you deploy
<br>
Building JavaScript means getting from the JavaScript you write to the JavaScript you
<br>
deploy. The following tools are often involved in this process:
<br>

<br>
• Transpilers: A transpiler is a compiler that compiles source code to source code.
<br>
Two transpilers that are popular in the JavaScript community are:
<br>
– Babel compiles upcoming and modern JavaScript features to older versions
<br>
of the language. That means you can use new features in your code and still
<br>
run it on older browsers.
<br>
– TypeScript is a superset of JavaScript. Roughly, it is the latest version of
<br>
JavaScript plus static typing.
<br>
• Miniﬁers: A miniﬁer compiles JavaScript to equivalent, smaller (as in fewer characters) JavaScript. It does so by renaming variables, removing comments, removing
<br>
whitespace, etc.
<br>
For example, given the following input:
<br>
let numberOfOccurrences = 5;
<br>
if (Math.random()) {
<br>
// Math.random() is not zero
<br>

<br>
46.4 An overview of JavaScript tools
<br>

<br>
509
<br>

<br>
numberOfOccurrences++
<br>
}
<br>

<br>
A miniﬁer might produce:
<br>
let a=5;Math.random()&&a++;
<br>

<br>
– Popular miniﬁers include: UglifyJS, babel-minify, Terser, and Closure Compiler.
<br>
• Bundlers: compile and optimize the code of a JavaScript app. The input of a
<br>
bundler is many ﬁles – all of the app’s code plus the libraries it uses. A bundler
<br>
combines these input ﬁles to produce fewer output ﬁles (which tends to improve
<br>
performance).
<br>
A bundler minimizes the size of its output via techniques such as tree-shaking. Treeshaking is a form of dead code elimination: only those module exports are put in
<br>
the output that are imported somewhere (across all code, while considering transitive imports).
<br>
It is also common to perform compilation steps such as transpiling and miniﬁcation
<br>
while bundling. In these cases, a bundler relies on the previously mentioned tools,
<br>
packaged as libraries.
<br>
– Popular bundlers include webpack, browserify, Rollup, and Parcel.
<br>
All of these tools and build steps are usually coordinated via so-called task runners (think
<br>
“make” in Unix). There are:
<br>
• Dedicated task runners: grunt, gulp, broccoli, etc.
<br>
• Tools that can be used as simple task runners: npm (via its “scripts”) and webpack
<br>
(via plugins).
<br>

<br>
46.4.2 Static checking
<br>
Static checking means analyzing source code statically (without running it). It can be used
<br>
to detect a variety of problems. Tools include:
<br>

<br>
• Linters: check the source code for problematic patterns, unused variables, etc. Linters are especially useful if you are still learning the language because they point
<br>
out if you are doing something wrong.
<br>
– Popular linters include JSLint, JSHint, ESLint
<br>
• Code style checkers: check if code is formatted properly. They consider indentation, spaces after brackets, spaces after commas, etc.
<br>
– Example: JSCS (JavaScript Code Style checker)
<br>
• Code formatters: automatically format your code for you, according to rules that
<br>
you can customize.
<br>
– Example: Prettier
<br>
• Type checkers: add static type checking to JavaScript.
<br>
– Popular type checkers: TypeScript (which is also a transpiler), Flow.
<br>

<br>
510
<br>

<br>
46 Next steps: overview of web development (bonus)
<br>

<br>
46.4.3 Testing
<br>
JavaScript has many testing frameworks – for example:
<br>
• Unit testing: Jasmine, Mocha, AVA, Jest, Karma, etc.
<br>
• Integration testing: Jenkins, Travis CI, etc.
<br>
• User interface testing: CasperJS, Protractor, Nightwatch.js, TestCafé, etc.
<br>

<br>
46.4.4 Package managers
<br>
The most popular package manager for JavaScript is npm. It started as a package manager for Node.js but has since also become dominant for client-side web development
<br>
and tools of any kind.
<br>
There are alternatives to npm, but they are all based in one way or another on npm’s
<br>
software registry:
<br>
• Yarn is a different take on npm; some of the features it pioneered are now also
<br>
supported by npm.
<br>
• pnpm focuses on saving space when installing packages locally.
<br>

<br>
46.4.5 Libraries
<br>
• Various helpers: lodash (which was originally based on the Underscore.js library)
<br>
is one of the most popular general helper libraries for JavaScript.
<br>
• Data structures: The following libraries are two examples among many.
<br>
– Immutable.js provides immutable data structures for JavaScript.
<br>
– Immer is an interesting lightweight alternative to Immutable.js. It also
<br>
doesn’t mutate the data it operates on, but it works with normal objects and
<br>
Arrays.
<br>
• Date libraries: JavaScript’s built-in support for dates is limited and full of pitfalls.
<br>
The chapter on dates lists libraries that you can use instead.
<br>
• Internationalization: In this area, ECMAScript’s standard library is complemented
<br>
by the ECMAScript Internationalization API (ECMA-402). It is accessed via the
<br>
global variable Intl and available in most modern browsers.
<br>
• Implementing and accessing services: The following are two popular options that
<br>
are supported by a variety of libraries and tools.
<br>
– REST (Representative State Transfer) is one popular option for services and
<br>
based on HTTP(S).
<br>
– GraphQL is more sophisticated (for example, it can combine multiple data
<br>
sources) and supports a query language.
<br>

<br>
46.5 Tools not related to JavaScript
<br>
Given that JavaScript is just one of several kinds of artifacts involved in web development,
<br>
more tools exist. These are but a few examples:
<br>
• CSS:
<br>
– Miniﬁers: reduce the size of CSS by removing comments, etc.
<br>

<br>
46.5 Tools not related to JavaScript
<br>

<br>
511
<br>

<br>
– Preprocessors: let you write compact CSS (sometimes augmented with control ﬂow constructs, etc.) that is expanded into deployable, more verbose
<br>
CSS.
<br>
– Frameworks: provide help with layout, decent-looking user interface components, etc.
<br>
• Images: Automatically optimizing the size of bitmap images, etc.
<br>

<br>
512
<br>

<br>
46 Next steps: overview of web development (bonus)
<br>

<br>
Part XI
<br>

<br>
Appendices
<br>

<br>
513
<br>

<br>
Chapter 47
<br>

<br>
Index
<br>
!x, 119
<br>

<br>
anonymous function expression, 208
<br>
argument, 215
<br>
argument vs. parameter, 215
<br>
Array, 311
<br>
Array hole, 321
<br>
Array index, 320
<br>
Array literal, 312
<br>
Array, dense, 321
<br>
Array, multidimensional, 319
<br>
Array, roles of an, 312
<br>
Array, sparse, 321
<br>
Array-destructuring, 389
<br>
Array-like object, 316
<br>
ArrayBuffer, 344
<br>
arrow function, 211
<br>
ASI (automatic semicolon insertion), 51
<br>
assert (module), 65
<br>
assertion, 63
<br>
assignment operator, 101
<br>
async, 443
<br>
async function, 441
<br>
async function*, 454
<br>
async-await, 441
<br>
asynchronous generator, 454
<br>
asynchronous iterable, 451
<br>
asynchronous iteration, 451
<br>
asynchronous iterator, 451
<br>
asynchronous programming, 409
<br>
attribute of a property, 278
<br>
automatic semicolon insertion (ASI), 51
<br>
await (async function), 445
<br>

<br>
++x, 124
<br>
x++, 124
<br>
+x, 124
<br>
, (comma operator), 105
<br>
--x, 124
<br>
x--, 124
<br>
-x, 124
<br>
x && y, 118
<br>
x + y, 100
<br>
x - y, 123
<br>
x / y, 123
<br>
x << y, 135
<br>
x === y, 103
<br>
x >>> y, 135
<br>
x >> y, 135
<br>
x & y, 134
<br>
x ** y, 123
<br>
x * y, 123
<br>
x ^ y, 134
<br>
x ¦ y, 134
<br>
x ¦¦ y, 118
<br>
x ٪ y, 123
<br>
=, 101
<br>
c ? t : e, 117
<br>
__proto__, 282
<br>
~x, 135
<br>

<br>
accessor (object literal), 259
<br>
addition, 100
<br>
AMD module, 237
<br>
515
<br>

<br>
516
<br>
await (asynchronous generator), 455
<br>

<br>
big endian, 348
<br>
binary integer literal, 122
<br>
binding (variable), 76
<br>
bitwise And, 134
<br>
bitwise Not, 135
<br>
bitwise Or, 134
<br>
bitwise Xor, 134
<br>
boolean, 113
<br>
Boolean(), 113
<br>
bound variable, 86
<br>
break, 190
<br>
bundler, 508
<br>
bundling, 508
<br>
call stack, 412
<br>
callback (asynchronous pattern), 419
<br>
callback function, 215
<br>
camel case, 45
<br>
catch, 203
<br>
class, 287
<br>
class, 287
<br>
class declaration, 287
<br>
class deﬁnition, 287
<br>
class expression, 287
<br>
class, mixin, 299
<br>
classes, private data for, 291
<br>
closure, 86
<br>
code point, 149
<br>
code unit, 149
<br>
coercion, 96
<br>
comma operator, 105
<br>
CommonJS module, 237
<br>
comparing by identity, 93
<br>
comparing by value, 92
<br>
computed property key, 270
<br>
concatenating strings, 157
<br>
conditional operator, 117
<br>
console, 57
<br>
console.error(), 61
<br>
console.log(), 60
<br>
const, 76
<br>
constant, 75
<br>
constructor function (role of an
<br>
ordinary function), 209
<br>
continue, 191
<br>
Converting to [type], 113
<br>

<br>
Coordinated Universal Time (UTC),
<br>
484
<br>
copy object deeply, 261
<br>
copy object shallowly, 261
<br>
currying, 228
<br>
dash case, 45
<br>
DataView, 344
<br>
date, 483
<br>
date time format, 485
<br>
decimal ﬂoating point literal, 123
<br>
decimal integer literal, 122
<br>
decrementation operator (preﬁx), 124
<br>
decrementation operator (sufﬁx), 124
<br>
deep copy of an object, 261
<br>
default export, 241
<br>
default value (destructuring), 393
<br>
default value (parameter), 216
<br>
delete, 271
<br>
deleting a property, 271
<br>
dense Array, 321
<br>
descriptor of a property, 278
<br>
destructive operation, 323
<br>
destructuring, 385
<br>
destructuring an Array, 389
<br>
destructuring an object, 388
<br>
dictionary (role of an object), 257
<br>
direct method call, 298
<br>
dispatched method call, 298
<br>
divided by operator, 123
<br>
division, 123
<br>
do-while, 196
<br>
dynamic this, 212
<br>
dynamic vs. static, 79
<br>
early activation, 84
<br>
Ecma, 30
<br>
ECMA-262, 30
<br>
ECMAScript, 30
<br>
ECMAScript module, 238
<br>
Eich, Brendan, 29
<br>
endianness (Typed Arrays), 348
<br>
enumerability, 272
<br>
enumerable (property attribute), 272
<br>
environment (variables), 223
<br>
equality operator, 103
<br>
ES module, 238
<br>
escaping HTML, 179
<br>

<br>
517
<br>
eval(), 219
<br>

<br>
globalThis, 80
<br>

<br>
evaluating an expression, 48
<br>
event (asynchronous pattern), 417
<br>
event loop, 413
<br>
exception, 201
<br>
exercises, getting started with, 69
<br>
exponentiation, 123
<br>
export, 239
<br>
export default, 241
<br>
export, default, 241
<br>
export, named, 239
<br>
expression, 48
<br>
extends, 293
<br>
external iteration, 403
<br>
extracting a method, 265
<br>

<br>
GMT (Greenwich Mean Time), 484
<br>
grapheme cluster, 152
<br>
Greenwich Mean Time (GMT), 484
<br>

<br>
false, 113
<br>

<br>
falsiness, 114
<br>
falsy, 114
<br>
finally, 204
<br>
ﬂags (regular expression), 464
<br>
Float32Array, 344
<br>
Float64Array, 344
<br>
ﬂoating point literal, 123
<br>
for, 196
<br>
for-await-of, 454
<br>
for-in, 199
<br>
for-of, 197
<br>
free variable, 86
<br>
freezing an object, 278
<br>
fulﬁlled (Promise state), 423
<br>
function declaration, 208
<br>
function expression, anonymous, 208
<br>
function expression, named, 208
<br>
function, arrow, 211
<br>
function, ordinary, 207
<br>
function, roles of an ordinary, 209
<br>
function, specialized, 207
<br>
function*, 397
<br>
garbage collection, 93
<br>
generator, asynchronous, 454
<br>
generator, synchronous, 397
<br>
getter (object literal), 259
<br>
global, 81
<br>
global object, 80
<br>
global scope, 80
<br>
global variable, 80
<br>

<br>
heap, 93
<br>
hexadecimal integer literal, 122
<br>
hoisting, 85
<br>
hole in an Array, 321
<br>
identiﬁer, 45
<br>
identity of an object, 92
<br>
if, 192
<br>
IIFE (immediately invoked function
<br>
expression), 236
<br>
immediately invoked function
<br>
expression (IIFE), 236
<br>
import, 240
<br>
import(), 250
<br>
import, named, 240
<br>
import, namespace, 241
<br>
in, 271
<br>
incrementation operator (preﬁx), 124
<br>
incrementation operator (sufﬁx), 124
<br>
index of an Array, 320
<br>
Infinity, 128
<br>
inheritance, multiple, 299
<br>
inheritance, single, 299
<br>
instanceof, 93, 290
<br>
Int16Array, 344
<br>
Int32Array, 344
<br>
Int8Array, 344
<br>
integer, 131
<br>
integer, safe, 132
<br>
internal iteration, 403
<br>
iterable (asynchronous), 451
<br>
iterable (synchronous), 306
<br>
iteration, asynchronous, 451
<br>
iteration, external, 403
<br>
iteration, internal, 403
<br>
iteration, synchronous, 305
<br>
iterator (asynchronous), 451
<br>
iterator (synchronous), 306
<br>
JSON (data format), 491
<br>
JSON (namespace object), 491
<br>
kebab case, 45
<br>
keyword, 47
<br>

<br>
518
<br>
label, 191
<br>
left shift operator, 135
<br>
let, 76
<br>
lexical this, 212
<br>
listing properties, 271
<br>
little endian, 348
<br>
logical And, 118
<br>
logical Not, 119
<br>
logical Or, 118
<br>
Map, 359
<br>
Map, 359
<br>
Map vs. object, 368
<br>
Math (namespace object), 141
<br>
method, 262
<br>
method (object literal), 259
<br>
method (role of an ordinary function),
<br>
209
<br>
method call, direct, 298
<br>
method call, dispatched, 298
<br>
method, extracting a, 265
<br>
miniﬁcation, 508
<br>
miniﬁer, 508
<br>
minus operator (binary), 123
<br>
minus operator (unary), 124
<br>
mixin class, 299
<br>
module speciﬁer, 248
<br>
module, AMD, 237
<br>
module, CommonJS, 237
<br>
multidimensional Array, 319
<br>
multiple inheritance, 299
<br>
multiple return values, 391
<br>
multiplication, 123
<br>
named export, 239
<br>
named function expression, 208
<br>
named import, 240
<br>
named parameter, 217
<br>
namespace import, 241
<br>
NaN, 126
<br>
node_modules, 246
<br>
npm, 245
<br>
npm package, 245
<br>
null, 109
<br>
number, 121
<br>
Number(), 125
<br>
object, 255
<br>
object literal, 257
<br>

<br>
object vs. Map, 368
<br>
object vs. primitive value, 91
<br>
Object(), 96
<br>
object, copy deeply, 261
<br>
object, copy shallowly, 261
<br>
object, freezing an, 278
<br>
object, identity of an, 92
<br>
object, roles of an, 257
<br>
object-destructuring, 388
<br>
Object.is(), 104
<br>
octal integer literal, 122
<br>
ordinary function, 207
<br>
ordinary function, roles of an, 209
<br>
override a property, 283
<br>
package, npm, 245
<br>
package.json, 245
<br>
parameter, 215
<br>
parameter default value, 216
<br>
parameter vs. argument, 215
<br>
partial application, 228
<br>
passing by identity, 92
<br>
passing by value, 91
<br>
pattern (regular expression), 464
<br>
pending (Promise state), 423
<br>
plus operator (binary), 100
<br>
plus operator (unary), 124
<br>
polyﬁll, 254
<br>
polyﬁll, speculative, 254
<br>
ponyﬁll, 254
<br>
primitive value, 91
<br>
primitive value vs. object, 91
<br>
private data for classes, 291
<br>
progressive web app, 504
<br>
prollyﬁll, 254
<br>
Promise, 421
<br>
Promise, states of a, 423
<br>
properties, listing, 271
<br>
property (object), 256
<br>
property attribute, 278
<br>
property descriptor, 278
<br>
property key, 271
<br>
property key, computed, 270
<br>
property key, quoted, 269
<br>
property name, 271
<br>
property symbol, 271
<br>
property value shorthand, 258
<br>
property, deleting a, 271
<br>

<br>
519
<br>
prototype, 282
<br>
prototype chain, 282
<br>
publicly known symbol, 184
<br>
quizzes, getting started with, 69
<br>
quoted property key, 269
<br>
real function (role of an ordinary
<br>
function), 209
<br>
receiver, 259
<br>
record (role of an object), 257
<br>
RegExp, 463
<br>
regular expression, 463
<br>
regular expression literal, 464
<br>
rejected (Promise state), 423
<br>
remainder operator, 123
<br>
REPL, 59
<br>
replica, 254
<br>
RequireJS, 237
<br>
reserved word, 47
<br>
rest element (Array-destructuring), 390
<br>
rest parameter (function call), 216
<br>
rest property (object-destructuring),
<br>
389
<br>
return values, multiple, 391
<br>
revealing module pattern, 236
<br>
roles of an Array, 312
<br>
roles of an object, 257
<br>
roles of an ordinary function, 209
<br>
run-to-completion semantics, 416
<br>
safe integer, 132
<br>
scope of a variable, 77
<br>
script, 235
<br>
self, 81
<br>
sequence (role of an Array), 312
<br>
Set, 375
<br>
Set, 375
<br>
setter (object literal), 259
<br>
settled (Promise state), 423
<br>
shadowing, 79
<br>
shallow copy of an object, 261
<br>
shim, 254
<br>
signed right shift operator, 135
<br>
single inheritance, 299
<br>
sloppy mode, 53
<br>
snake case, 45
<br>
sparse Array, 321
<br>
specialized function, 207
<br>

<br>
speciﬁer, module, 248
<br>
speculative polyﬁll, 254
<br>
spreading (...) into a function call, 218
<br>
spreading into an Array literal, 314
<br>
spreading into an object literal, 260
<br>
statement, 48
<br>
states of a Promise, 423
<br>
static, 290
<br>
static vs. dynamic, 79
<br>
strict mode, 53
<br>
string, 155
<br>
String(), 157
<br>
subclass, 293
<br>
subtraction, 123
<br>
switch, 193
<br>
symbol, 181
<br>
symbol, publicly known, 184
<br>
synchronous generator, 397
<br>
synchronous iterable, 306
<br>
synchronous iteration, 305
<br>
synchronous iterator, 306
<br>
syntax, 42
<br>
tagged template, 173
<br>
task queue, 413
<br>
task runner, 508
<br>
TC39, 31
<br>
TC39 process, 31
<br>
TDZ (temporal dead zone), 82
<br>
Technical Committee 39, 31
<br>
template literal, 172
<br>
temporal dead zone, 82
<br>
ternary operator, 117
<br>
this, 259
<br>
this, dynamic, 212
<br>
this, lexical, 212
<br>
this, pitfalls of, 268
<br>
this, values of, 268
<br>
throw, 202
<br>
time value, 486
<br>
times operator, 123
<br>
to the power of operator, 123
<br>
transpilation, 508
<br>
transpiler, 508
<br>
tree-shaking, 508
<br>
true, 113
<br>
truthiness, 114
<br>
truthy, 114
<br>

<br>
520
<br>
try, 203
<br>

<br>
tuple (role of an Array), 312
<br>
type, 89
<br>
type hierarchy, 90
<br>
type signature, 18
<br>
Typed Array, 343
<br>
typeof, 93
<br>
TypeScript, 508
<br>
Uint16Array, 344
<br>
Uint32Array, 344
<br>
Uint8Array, 344
<br>
Uint8ClampedArray, 344
<br>
undefined, 109
<br>

<br>
underscore case, 45
<br>
Unicode, 149
<br>
Unicode Transformation Format (UTF),
<br>
150
<br>
unit test, 70
<br>
unsigned right shift operator, 135
<br>
UTC (Coordinated Universal Time),
<br>
484
<br>
UTF (Unicode Transformation Format),
<br>
150
<br>
UTF-16, 151
<br>

<br>
UTF-32, 150
<br>
UTF-8, 151
<br>
variable, bound, 86
<br>
variable, free, 86
<br>
variable, scope of a, 77
<br>
void operator, 105
<br>
Wasm (WebAssembly), 505
<br>
WeakMap, 371
<br>
WeakMap, 371
<br>
WeakSet, 383
<br>
WeakSet, 383
<br>
Web Worker, 415
<br>
WebAssembly, 505
<br>
while, 195
<br>
window, 81
<br>
wrapper types (for primitive types), 96
<br>
yield (asynchronous generator), 455
<br>
yield (synchronous generator), 398
<br>
yield* (asynchronous generator), 455
<br>
yield* (synchronous generator), 401
<br>

<br>
Z (Zulu Time Zone), 484
<br>
Zulu Time Zone (Z), 484
<br>

<br>

</body>
</html>